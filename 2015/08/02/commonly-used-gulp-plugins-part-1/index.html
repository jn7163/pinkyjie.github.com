<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="o7yQBnLIoWby8Y5vNMQywBiMtev-ilWjXt89RQpTvVw" />













  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="AngularJS,插件,generator-aio-angular,gulp," />





  <link rel="alternate" href="/atom.xml" title="进击的马斯特" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="在写generator-aio-angular的过程中，gulp这一块发现了很多非常实用的插件，大大的增加了能自动化的范围，这篇文章就分门别类的简单介绍下常用的gulp插件吧。">
<meta property="og:type" content="article">
<meta property="og:title" content="常用gulp插件介绍(一)">
<meta property="og:url" content="http://pinkyjie.com/2015/08/02/commonly-used-gulp-plugins-part-1/index.html">
<meta property="og:site_name" content="进击的马斯特">
<meta property="og:description" content="在写generator-aio-angular的过程中，gulp这一块发现了很多非常实用的插件，大大的增加了能自动化的范围，这篇文章就分门别类的简单介绍下常用的gulp插件吧。">
<meta property="og:updated_time" content="2017-02-20T10:01:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="常用gulp插件介绍(一)">
<meta name="twitter:description" content="在写generator-aio-angular的过程中，gulp这一块发现了很多非常实用的插件，大大的增加了能自动化的范围，这篇文章就分门别类的简单介绍下常用的gulp插件吧。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://pinkyjie.com/2015/08/02/commonly-used-gulp-plugins-part-1/"/>





  <title> 常用gulp插件介绍(一) | 进击的马斯特 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-45012422-1', 'auto');
  ga('send', 'pageview');
</script>








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1253033676&web_id=1253033676" language="JavaScript"></script>
  </div>






  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">进击的马斯特</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">CODING MY LIFE</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', '8k3UxSuRWYkrhVg55bC3','2.0.0');
</script>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://pinkyjie.com/2015/08/02/commonly-used-gulp-plugins-part-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马斯特">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pinkyjie-blog.qiniudn.com/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进击的马斯特">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                常用gulp插件介绍(一)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-02T13:45:59+10:00">
                Aug 2nd 2015
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端开发/" itemprop="url" rel="index">
                    <span itemprop="name">前端开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2015/08/02/commonly-used-gulp-plugins-part-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在写<a href="https://github.com/PinkyJie/generator-aio-angular" target="_blank" rel="external">generator-aio-angular</a>的过程中，gulp这一块发现了很多非常实用的插件，大大的增加了能自动化的范围，这篇文章就分门别类的简单介绍下常用的gulp插件吧。</p>
<a id="more"></a>
<h3 id="util工具类"><a href="#util工具类" class="headerlink" title="util工具类"></a>util工具类</h3><p>这个分类下主要介绍一些辅助工具类的插件。</p>
<h4 id="gulp-load-plugins"><a href="#gulp-load-plugins" class="headerlink" title="gulp-load-plugins"></a><a href="https://www.npmjs.com/package/gulp-load-plugins" target="_blank" rel="external">gulp-load-plugins</a></h4><p>顾名思义，本插件的功能就是帮你自动require你在<code>package.json</code>中声明的依赖。只要一句<code>var $ = require(&#39;gulp-load-plugins&#39;)()</code>，则<code>package.json</code>中声明的<code>gulp-</code>或<code>gulp.</code>开头的插件就会自动被放在变量<code>$</code>下面。如<code>$.util</code>就等于<code>require(&#39;gulp-util&#39;)</code>，而有两个连字符的插件则会自动命名为驼峰格式，如<code>$.taskListing</code>则等于<code>require(&#39;gulp-task-listing&#39;)</code>。有了这个插件，就不用一个一个的require了。这个插件还有一些常用的参数配置，这里列几个常用的：</p>
<ul>
<li><code>lazyload: true</code>，用到这个插件的时候再去require，默认为true。</li>
<li><code>rename: {&#39;gulp-task-listing&#39;: &#39;list&#39;}</code>，如果有些插件名字太长，可以使用该参数重命名。</li>
<li><code>scope: [&#39;dependencies&#39;]</code>，本插件默认会扫描<code>package.json</code>里的所有dependence，可以使用该参数进行限制。</li>
</ul>
<p>要使用这些参数只要在require的时候传入即可，如<code>require(&#39;gulp-load-plugins&#39;)({lazy: true})</code>。</p>
<h4 id="gulp-task-listing"><a href="#gulp-task-listing" class="headerlink" title="gulp-task-listing"></a><a href="https://www.npmjs.com/package/gulp-task-listing" target="_blank" rel="external">gulp-task-listing</a></h4><p>这个插件的作用也很容易猜，它可以打印出<code>gulpfile.js</code>中定义的所有task，这个插件我们在<a href="/2015/03/24/refactor-your-gulpfile/">重构你的gulpfile</a>这篇文章的最后介绍过，值得一提的是它还可以根据task的名字确定它是不是一个子task，比如带有<code>:</code>、<code>-</code>、<code>_</code>的task就被认为是子task。我一般把这个插件作为默认的task来调用，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'help'</span>]);</div><div class="line">gulp.task(<span class="string">'help'</span>, $.taskListing);</div></pre></td></tr></table></figure>
<p>这样，如果只执行<code>gulp</code>的话就会打印出所有定义好的task，非常实用。</p>
<h4 id="yargs"><a href="#yargs" class="headerlink" title="yargs"></a><a href="https://www.npmjs.com/package/yargs" target="_blank" rel="external">yargs</a></h4><p>严格的说，<code>yargs</code>不是专门用于gulp的，它是Node中处理命令行参数的通用解决方案。只要一句代码<code>var args = require(&#39;yargs&#39;).argv;</code>就可以让命令行的参数都放在变量<code>args</code>上，非常方便。它可以处理的参数类型也是多种多样的：</p>
<ul>
<li>单字符的简单参数，如传入<code>-m=5</code>或<code>-m 5</code>，则可得到<code>args.m = 5</code>。</li>
<li>多字符参数（必须使用双连字符），如传入<code>--test=5</code>或<code>--test 5</code>，则可得到<code>args.test = 5</code>。</li>
<li>不带值的参数，如传入<code>--mock</code>，则会被认为是布尔类型的参数，可得到<code>args.mock = true</code>。</li>
</ul>
<p>除此之外，还支持很多其他类型的传参方式，具体可参考<a href="https://www.npmjs.com/package/yargs" target="_blank" rel="external">它的文档</a>。</p>
<h4 id="gulp-util"><a href="#gulp-util" class="headerlink" title="gulp-util"></a><a href="https://www.npmjs.com/package/gulp-util" target="_blank" rel="external">gulp-util</a></h4><p>gulp-util带有很多方便的函数，其中最常用的应该就是log了。<code>$.util.log()</code>支持传入多个参数，打印结果会将多个参数用空格连接起来。它与<code>console.log</code>的区别就是所有<code>$.util.log</code>的结果会自动带上时间前缀。另外，它还支持颜色，如<code>$.util.log($.util.colors.magenta(&#39;123&#39;));</code>打印出来的123是品红色的。其实<code>$.util.colors</code>就是一个<a href="https://github.com/sindresorhus/chalk" target="_blank" rel="external">chalk</a>的实例，而chalk是专门用来处理命令行打印着色的一个工具。</p>
<h4 id="del"><a href="#del" class="headerlink" title="del"></a><a href="https://www.npmjs.com/package/del" target="_blank" rel="external">del</a></h4><p>grunt自身提供一个<a href="https://github.com/gruntjs/grunt-contrib-clean" target="_blank" rel="external">grunt-contrib-clean</a>用来处理支持glob匹配的删除，而del就是gulp上对应的工具。del支持和<code>gulp.src</code>参数同样的匹配，除此之外，它的第二个参数还支持一个回调函数，当删除完成以后执行，所以这是一个异步的删除。常用的调用方法为：<code>del([xxx], callback)</code>。</p>
<h4 id="gulp-bytediff"><a href="#gulp-bytediff" class="headerlink" title="gulp-bytediff"></a><a href="https://www.npmjs.com/package/gulp-bytediff" target="_blank" rel="external">gulp-bytediff</a></h4><p>这是一个统计文件大小变化的工具，通常与压缩类工具放在一起实用，比如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'**/*.html'</span>)</div><div class="line">    .pipe($.bytediff.start())</div><div class="line">    .pipe($.minifyHtml(&#123;<span class="attr">empty</span>: <span class="literal">true</span>&#125;))</div><div class="line">    .pipe($.bytediff.stop(bytediffFormatter))</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>));</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bytediffFormatter</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> difference = (data.savings &gt; <span class="number">0</span>) ? <span class="string">' smaller.'</span> : <span class="string">' larger.'</span>;</div><div class="line">    <span class="keyword">return</span> data.fileName + <span class="string">' went from '</span> +</div><div class="line">        (data.startSize / <span class="number">1000</span>).toFixed(<span class="number">2</span>) + <span class="string">' kB to '</span> +</div><div class="line">        (data.endSize / <span class="number">1000</span>).toFixed(<span class="number">2</span>) + <span class="string">' kB and is '</span> +</div><div class="line">        formatPercent(<span class="number">1</span> - data.percent, <span class="number">2</span>) + <span class="string">'%'</span> + difference;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在压缩的pipe前后加上<code>$.bytediff.start()</code>和<code>$.bytediff.stop(callback)</code>，即可统计压缩前后文件的变化。在callback中传入的参数data上，可以访问到很多变量，如文件名，变化前后的大小，变化百分比等等。</p>
<h4 id="gulp-print"><a href="#gulp-print" class="headerlink" title="gulp-print"></a><a href="https://www.npmjs.com/package/gulp-print" target="_blank" rel="external">gulp-print</a></h4><p>这个插件的作用很简单，打印出stream里面的所有文件名，通常调试的时候比较需要。</p>
<h4 id="gulp-bump"><a href="#gulp-bump" class="headerlink" title="gulp-bump"></a><a href="https://www.npmjs.com/package/gulp-bump" target="_blank" rel="external">gulp-bump</a></h4><p>这个插件也可以顾名思义：用来升级版本用的，废话不说，直接看例子吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> gulp</div><div class="line">    .src(<span class="string">'package.json'</span>)</div><div class="line">    .pipe($.bump(options))</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>));</div></pre></td></tr></table></figure>
<p>重点来看这里的options，我们可直接传递一个具体的version进去，也可以按照Node的版本规范传递一个type进去，让其自己生成对应的version：</p>
<ul>
<li><code>version</code>，直接传递要升级到的版本号，如<code>1.2.3</code>。</li>
<li><code>type</code>，可接受的值包括下面四个，倘若现在的版本号为<code>1.2.3</code>，则对应的新版本号为：<ul>
<li>prerelease：<code>1.2.3-0</code></li>
<li>patch：<code>1.2.4</code></li>
<li>minor：<code>1.3.0</code></li>
<li>major：<code>2.0.0</code></li>
</ul>
</li>
</ul>
<p>最终这个升级后的版本号会反映在<code>package.json</code>中，当然，你也可以在gulp.src中传入更多的文件（如<code>bower.json</code>）来替换更多的文件。</p>
<h4 id="gulp-header"><a href="#gulp-header" class="headerlink" title="gulp-header"></a><a href="https://www.npmjs.com/package/gulp-header" target="_blank" rel="external">gulp-header</a></h4><p>这个工具用来在压缩后的JS、CSS文件中添加头部注释，你可以包含任意想要的信息，通常就是作者、描述、版本号、license等，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHeader</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> pkg = <span class="built_in">require</span>(<span class="string">'package.json'</span>);</div><div class="line">    <span class="keyword">var</span> template = [<span class="string">'/**'</span>,</div><div class="line">        <span class="string">' * &lt;%= pkg.name %&gt; - &lt;%= pkg.description %&gt;'</span>,</div><div class="line">        <span class="string">' * @authors &lt;%= pkg.authors %&gt;'</span>,</div><div class="line">        <span class="string">' * @version v&lt;%= pkg.version %&gt;'</span>,</div><div class="line">        <span class="string">' * @link &lt;%= pkg.homepage %&gt;'</span>,</div><div class="line">        <span class="string">' * @license &lt;%= pkg.license %&gt;'</span>,</div><div class="line">        <span class="string">' */'</span>,</div><div class="line">        <span class="string">''</span></div><div class="line">    ].join(<span class="string">'\n'</span>);</div><div class="line">    <span class="keyword">return</span> $.header(template, &#123;</div><div class="line">        <span class="attr">pkg</span>: pkg</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数将<code>package.json</code>中的各种信息提取出来，变成头部注释，只要在压缩的pipe中调用<code>.pipe(getHeader())</code>即可。</p>
<h3 id="stream相关"><a href="#stream相关" class="headerlink" title="stream相关"></a>stream相关</h3><p>这个部分主要介绍一些跟stream操作有关的插件。</p>
<h4 id="gulp-filter"><a href="#gulp-filter" class="headerlink" title="gulp-filter"></a><a href="https://www.npmjs.com/package/gulp-filter" target="_blank" rel="external">gulp-filter</a></h4><p>gulp-filter可以把stream里的文件根据一定的规则进行筛选过滤。比如<code>gulp.src</code>中传入匹配符匹配了很多文件，可以把这些文件pipe给gulp-filter作二次筛选，如<code>gulp.src(&#39;**/*.js&#39;).pipe($.filter(**/a/*.js))</code>，本来选中了所有子文件下的js文件，经过筛选后变成名为a的子文件夹下的js文件。那有人要问了，为什么不直接将需要的筛选传入<code>gulp.src</code>，干嘛要多筛选一步呢？这里面有两种情况：</p>
<ul>
<li><code>gulp.src</code>与<code>$.filter</code>中间可能需要别的处理，比如我对所有文件做了操作1以后，还需要筛选出一部分做操作2。</li>
<li>第二种情况就要谈到gulp-filter的另外一个特性：筛选之后还可以restore回去。比如我对所有文件做了操作1，筛选了一部分做操作2，最后要把所有的文件都拷贝到最终的位置。代码如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> filter = $.filter(<span class="string">'**/a/*.js'</span>);</div><div class="line">gulp.src(<span class="string">'**/*.js'</span>)</div><div class="line">    .pipe(action1())</div><div class="line">    .pipe(filter)</div><div class="line">    .pipe(action2())</div><div class="line">    .pipe(filter.restore())</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>))</div></pre></td></tr></table></figure>
<p>可以看到，如果没有restore这个操作，那么拷贝到最终位置的文件将只包含被过滤出来的文件，这样一restore，所有的文件都被拷贝了。</p>
<h4 id="gulp-flatten"><a href="#gulp-flatten" class="headerlink" title="gulp-flatten"></a><a href="https://www.npmjs.com/package/gulp-flatten" target="_blank" rel="external">gulp-flatten</a></h4><p>gulp-flatten非常实用，可能知道别的库中flatten函数的同学已经猜到它是干嘛的了。比如<code>gulp.src(&#39;**/*.js&#39;)</code>匹配了很多文件，包括<code>a/b/c.js</code>，<code>d/e.js</code>，<code>f/g/h/i/j/k.js</code>，<code>l.js</code>，这些文件的层级都不一样，一旦我们将这个文件pipe给<code>$.flatten()</code>，则所有的文件夹层级都会去掉，最终的文件将是<code>c.js</code>，<code>e.js</code>，<code>k.js</code>，<code>l.js</code>，在一些场景下还是非常有用的。</p>
<h4 id="gulp-plumber"><a href="#gulp-plumber" class="headerlink" title="gulp-plumber"></a><a href="https://www.npmjs.com/package/gulp-plumber" target="_blank" rel="external">gulp-plumber</a></h4><p>这个插件的作用简单来说就是一旦pipe中的某一steam报错了，保证下面的steam还继续执行。因为pipe默认的onerror函数会把剩下的stream给unpipe掉，这个插件阻止了这种行为。那它一般用于哪种场景呢？比如，代码每次build之前要跑一遍jshint和jscs来确保所有代码都符合规范，但一旦某些代码不符合规范，整个build流程就会停止，这个时候就需要gulp-plumber出场了。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'build'</span>, [<span class="string">'jslint'</span>, <span class="string">'xxxx'</span>]);</div><div class="line">gulp.task(<span class="string">'jslint'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> gulp</div><div class="line">        .src(config.js.all)</div><div class="line">        .pipe($.plumber())</div><div class="line">        .pipe($.jshint())</div><div class="line">        .pipe($.jscs()); </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这样，一旦jshint或jscs报错，整个build流程还是可以继续走下去的，而且gulp-plumber会给出一个报错提醒我们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[16:52:36] Plumber found unhandled error:</div><div class="line"> Error in plugin &apos;gulp-jshint&apos;</div><div class="line">Message:</div><div class="line">    JSHint failed for: xxxx.js</div></pre></td></tr></table></figure>
<h4 id="gulp-if"><a href="#gulp-if" class="headerlink" title="gulp-if"></a><a href="https://www.npmjs.com/package/gulp-if" target="_blank" rel="external">gulp-if</a></h4><p>这个插件的功能也很简单，可以条件性的添加stream，如<code>.pipe($.if(flag, action1()))</code>，则只会在<code>flag</code>变量为true时才会将<code>action1()</code>添加到stream中去。其实不用这个插件也可以达到类似的效果，那就是gulp-util里有一个函数叫做<code>noop()</code>，也就是no operation，这个函数其实是返回一个什么都不干的空stream。利用这个函数我们可以这么写：<code>.pipe(flag ? action1() : $.util.noop())</code>，与上例的效果是一样的。</p>
<h4 id="merge-stream"><a href="#merge-stream" class="headerlink" title="merge-stream"></a><a href="https://www.npmjs.com/package/merge-stream" target="_blank" rel="external">merge-stream</a></h4><p>一个gulp的task只能返回一个stream，但有的时候有这么一种情景：有两类文件，它们的原始位置和处理后的位置都是不同的，但它们的处理流程相同。由于<code>gulp.src</code>和<code>gulp.dest</code>的参数不同，我们就需要写两个task来分别完成这个任务，一方面略显重复，另一方面逻辑上来讲这两个task本来就是处理同样的事情的。这种情况就需要merge-stream登场了，它的作用就是将多个stream合成一个返回。比如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> merge = <span class="built_in">require</span>(<span class="string">'merge-stream'</span>);</div><div class="line">gulp.task(<span class="string">'jade'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> stream1 = jade(src1, dest1);</div><div class="line">    <span class="keyword">var</span> stream2 = jade(src2, dest2);</div><div class="line">    <span class="keyword">return</span> merge(stream1, stream2);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jade</span> (<span class="params">src, dest</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> gulp</div><div class="line">        .src(src)</div><div class="line">        .pipe($.jade())</div><div class="line">        .pipe(gulp.dest(dest));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，处理的流程被提取出来放入一个函数，它接受两个参数，分别是src和dest。然后在task中直接调用这个函数生成两个stream，然后返回merge-stream合并后的结果。</p>
<h4 id="run-sequence"><a href="#run-sequence" class="headerlink" title="run-sequence"></a><a href="https://www.npmjs.com/package/run-sequence" target="_blank" rel="external">run-sequence</a></h4><p>gulp里的task都是异步并发执行的，有的时候我们需要一连串的task按顺序执行，这时就需要run-sequence登场了。它的调用很简单：<code>runSequence(&#39;task1&#39;, &#39;task2&#39;, [&#39;task3&#39;, &#39;task4&#39;], &#39;task5&#39;)</code>，这里的task都是gulp定义好的task名称，task1完成后才会执行task2，以此类推。注意到task3和task4被放在中括号里了，这表明，task3和task4可以并发执行的，但两个都执行完后才会执行task5。这里要说明的是，每个task要么返回一个stream，即<code>return gulp.src().pipe().pipe()</code>，要么支持回调函数，即<code>gulp.task(&#39;task1&#39;, function (done) { action1(done); })</code>，满足了这两点才能保证正常的执行顺序，因为这是gulp对<a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md#async-task-support" target="_blank" rel="external">异步task的基本要求</a>。</p>
<h3 id="inject相关"><a href="#inject相关" class="headerlink" title="inject相关"></a>inject相关</h3><p>这个部分主要介绍一些将JS/CSS自动插入到HTML的相关插件。</p>
<h4 id="wiredep"><a href="#wiredep" class="headerlink" title="wiredep"></a><a href="https://www.npmjs.com/package/wiredep" target="_blank" rel="external">wiredep</a></h4><p>wiredep就是wire dependence的意思，它的作用就是把<code>bower.json</code>中声明的dependence自动的包含到HTML中去。要插入文件，wiredep需要解决两个问题：</p>
<ul>
<li>插入的位置：wiredep通过识别HTML中的注释来识别插入位置，如</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- bower:css --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbower --&gt;</span></div><div class="line"><span class="comment">&lt;!-- bower:js --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbower --&gt;</span></div></pre></td></tr></table></figure>
<p>不同类型的文件被插入到不同的区块。</p>
<ul>
<li>插入什么文件：要插入的文件列表自然来自<code>bower.json</code>，每个bower安装的依赖库，根目录下边都有一个自己的<code>bower.json</code>文件，其中的<code>main</code>字段指明了使用这个库需要包含的文件，wiredep最终包含的文件列表就来自这个字段。有些情况下，库自身的<code>bower.json</code>的main字段可能会多包含文件或少包含文件，如果想要定制这个列表，则可以在自己的<code>bower.json</code>中使用<code>overrides</code>字段，如下面的代码覆盖了<code>mdi</code>这个库的<code>main</code>字段。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="string">"overrides"</span>: &#123;</div><div class="line">  <span class="string">"mdi"</span>: &#123;</div><div class="line">    <span class="string">"main"</span>: [</div><div class="line">      <span class="string">"css/materialdesignicons.css"</span></div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>wiredep插件支持很多参数，常用的主要有两个：</p>
<ul>
<li>bowerJson：指定<code>bower.json</code>的内容，注意这个字段不是<code>bower.json</code>文件的位置，这个参数需要使用require后的结果赋值：<code>require(&#39;bower.json&#39;)</code>。</li>
<li>directory：指定存放bower安装后的依赖包的路径，通常是bower_components。注意最终插入到HTML中的文件列表的路径是index.html文件相对于本文件夹的相对路径。</li>
</ul>
<p>使用wiredep也比较简单，直接把它传入到stream中即可，如<code>gulp.src(&#39;index.html&#39;).pipe(wiredep(options))</code>。</p>
<h4 id="gulp-inject"><a href="#gulp-inject" class="headerlink" title="gulp-inject"></a><a href="https://www.npmjs.com/package/gulp-inject" target="_blank" rel="external">gulp-inject</a></h4><p>这个插件的作用与wiredep类似，不同的是可以自己任意指定需要插入文件的列表。它同样是利用注释来寻找插入的位置，它识别的默认注释为<code>&lt;!-- inject:js --&gt;</code>，但更加智能：</p>
<ul>
<li>支持各种模板语言：可以根据<code>gulp.src</code>指定的源文件自动识别注释和插入内容，除了支持HTML外，还支持jade、haml等。若源为jade文件，则识别的注释为<code>//- inject:js</code>，插入的内容为：<code>script(src=&quot;&lt;filename&gt;.js&quot;)</code>。</li>
<li>配置非常灵活：<ul>
<li>name：默认识别的注释标签格式为<code>&lt;!-- name:ext --&gt;</code>，这里的name默认值就是“inject”，而ext的默认值是要插入的文件的扩展名。那么name属性可配置意味着可以添加自定义的插入区块，如<code>&lt;!-- production:js --&gt;</code>，这个标签可以只插入生产环境需要包含的JS文件。</li>
<li>starttag和endtag：支持自定义需要识别的注释内容。</li>
<li>addPrefix和addSuffix：支持在插入文件的路径上自定义前缀、后缀。</li>
<li>relative：指定插入文件的路径是否为相对路径。</li>
<li>ingorePath：指定插入文件的路径前面会忽略掉指定的路径。</li>
<li>read：这个参数通常给false，不需要真正的去读取文件。</li>
</ul>
</li>
</ul>
<p>这个插件的使用场景通常是，我们需要index里有多个区块，比如上面name的例子，只有当为production环境编译的时候才去包含相关的文件。</p>
<h4 id="gulp-useref-与-gulp-rev、gulp-rev-replace"><a href="#gulp-useref-与-gulp-rev、gulp-rev-replace" class="headerlink" title="gulp-useref 与 gulp-rev、gulp-rev-replace"></a><a href="https://www.npmjs.com/package/gulp-useref" target="_blank" rel="external">gulp-useref</a> 与 <a href="https://www.npmjs.com/package/gulp-rev" target="_blank" rel="external">gulp-rev</a>、<a href="https://www.npmjs.com/package/gulp-rev-replace" target="_blank" rel="external">gulp-rev-replace</a></h4><p>这三个工具之所以放在一起讲，是因为它们一般都是一起使用的。它们要解决什么问题呢？通过上面的wiredep也好，gulp-inject也好，插入了一堆JS、CSS文件到HTML中，一旦部署到生产环境，这么多文件必然是要合并压缩的。光是压缩还不够，为了解决缓存问题，每次合并压缩后要给最终的文件加hash，这样每次文件内容一变动，hash也会跟着变动，就不存在浏览器依然使用缓存的老文件的问题。这样得到最终的文件以后，肯定还要将这个文件替换回HTML中去，一大堆的script和link标签替换成最终合并压缩带hash的版本。</p>
<p>前面啰啰嗦嗦的一大堆工作就是这三个插件要解决的问题了。首先，gulp-useref根据注释将HTML中需要合并压缩的区块找出来，对区块内的所有文件进行合并。<strong>注意：它只负责合并，不负责压缩！</strong>所以合并出来的文件我们要自行压缩，压缩以后调用gulp-rev负责在文件名后追加hash。最后调用gulp-rev-replace负责把最终的文件名替换回HTML中去。扯了大半天，还是直接上例子吧。先来看看HTML中的注释：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- build:css static/styles/lib.css --&gt;</span></div><div class="line"><span class="comment">&lt;!-- bower:css --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbower --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- build:css static/styles/app.css --&gt;</span></div><div class="line"><span class="comment">&lt;!-- inject:css --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endinject --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- build:js static/js/lib.js --&gt;</span></div><div class="line"><span class="comment">&lt;!-- bower:js --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbower --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- build:js static/js/app.js --&gt;</span></div><div class="line"><span class="comment">&lt;!-- inject:js --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endinject --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></div></pre></td></tr></table></figure>
<p>gulp-useref识别的就是build开头的注释，build后面首先跟的是类型扩展名，然后后面的路径就是build区块中的所有文件进行合并后的文件路径，这个相对路径是相对于这个HTML的路径。上面的例子中我们用build区块把bower和inject进来的文件包起来，这些文件就可以被gulp-useref合并了。再来看gulp中useref相关task的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> assets = $.useref.assets(&#123;<span class="attr">searchPath</span>: <span class="string">'app/src/'</span>&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> cssFilter = $.filter(<span class="string">'**/*.css'</span>);</div><div class="line"><span class="keyword">var</span> jsAppFilter = $.filter(<span class="string">'**/app.js'</span>);</div><div class="line"><span class="keyword">var</span> jslibFilter = $.filter(<span class="string">'**/lib.js'</span>);</div><div class="line"></div><div class="line"><span class="keyword">return</span> gulp</div><div class="line">    .src(<span class="string">'index.html'</span>)</div><div class="line">    .pipe(assets)</div><div class="line">    .pipe(cssFilter)</div><div class="line">    .pipe($.csso())</div><div class="line">    .pipe(cssFilter.restore())</div><div class="line">    .pipe(jsAppFilter)</div><div class="line">    .pipe($.uglify())</div><div class="line">    .pipe(getHeader())</div><div class="line">    .pipe(jsAppFilter.restore())</div><div class="line">    .pipe(jslibFilter)</div><div class="line">    .pipe($.uglify())</div><div class="line">    .pipe(jslibFilter.restore())</div><div class="line">    .pipe($.rev())</div><div class="line">    .pipe(assets.restore())</div><div class="line">    .pipe($.useref())</div><div class="line">    .pipe($.revReplace())</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>));</div></pre></td></tr></table></figure>
<p>首先一上来，先调用<code>$.useref.assets()</code>函数，这个函数返回一个stream，包含已经合并后的文件。可以尝试在第9行后面加上前面介绍过的gulp-print插件<code>.pipe($.print())</code>，打印出stream里的文件，发现就是前面HTML中4个build注释块后面的4个文件。注意这里调用的时候跟了一个<code>searchPath</code>的参数，它的用处就是指定从哪个路径开始寻找build区块底下的文件。比如build区块底下有这么一行<code>&lt;script src=&quot;static/js/a.js&quot;&gt;&lt;/script&gt;</code>，那最终gulp-useref将从这个路径<code>app/src/static/js/a.js</code>找到这个文件。第3到5行定义了3个filter，这主要是为了后面压缩准备的。下面正式看stream的pipe流程。先选出要处理的HTML文件，然后调用刚才得到的<code>assets</code>得到合并后的4个文件，第10到12行筛选出合并后的CSS文件进行压缩（压缩类插件下篇文章再讲），第13到16行筛选出app.js进行压缩，第17到19行筛选出lib.js进行压缩。之所以要区别对待app.js和lib.js，是因为app.js是我们自己写的代码，压缩后要加上header（第15行，使用前面介绍过的gulp-header插件），而lib.js是第三方的各种库，直接压缩即可。后面调用gulp-rev给压缩后的4个文件加hash，然后调用<code>assets.restore()</code>将src源换回HTML文件，这是为了后面调用<code>$.useref()</code>，因为<code>$.useref()</code>做替换的src源是HTML文件，同样后面调用gulp-rev-replace将带hash的文件替换回HTML，它要求的src源也必须是HTML文件。这里的顺序很重要，因为这几个插件接受的源不一样，gulp-rev接受的是JS、CSS文件，而gulp-useref和gulp-rev-replace接受的是HTML。还有一个问题：gulp-rev-replace是怎么知道gulp-rev进行hash前后的文件名对应关系呢？其实gulp-rev会生成一个manifest的文件，内容是类似下面的JSON：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"static/styles/lib.css"</span>: <span class="string">"static/styles/lib-d41d8cd98f.css"</span></div><div class="line">    <span class="string">"static/js/lib.js"</span>: <span class="string">"static/js/lib-273c2cin3f.js"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然这个文件默认是不会生成在文件系统里的，可以通过<code>.pipe($.rev.manifest())</code>将这个文件保存到本地。有了这个文件，gulp-rev-replace甚至可以脱离gulp-rev独立工作哦！</p>
<p>好了，这篇就到这里，还有好多工具没介绍到，留着给下篇吧。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/AngularJS/" rel="tag"># AngularJS</a>
          
            <a href="/tags/插件/" rel="tag"># 插件</a>
          
            <a href="/tags/generator-aio-angular/" rel="tag"># generator-aio-angular</a>
          
            <a href="/tags/gulp/" rel="tag"># gulp</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/07/25/simple-layout-based-on-ui-router/" rel="next" title="基于ui-router的简单布局及其他应用">
                <i class="fa fa-chevron-left"></i> 基于ui-router的简单布局及其他应用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/08/12/commonly-used-gulp-plugins-part-2/" rel="prev" title="常用gulp插件介绍(二)">
                常用gulp插件介绍(二) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://pinkyjie-blog.qiniudn.com/images/avatar.jpg"
               alt="马斯特" />
          <p class="site-author-name" itemprop="name">马斯特</p>
           
              <p class="site-description motion-element" itemprop="description">前端 | 溜冰 | Mac</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">55</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">186</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#util工具类"><span class="nav-number">1.</span> <span class="nav-text">util工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gulp-load-plugins"><span class="nav-number">1.1.</span> <span class="nav-text">gulp-load-plugins</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gulp-task-listing"><span class="nav-number">1.2.</span> <span class="nav-text">gulp-task-listing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#yargs"><span class="nav-number">1.3.</span> <span class="nav-text">yargs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gulp-util"><span class="nav-number">1.4.</span> <span class="nav-text">gulp-util</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#del"><span class="nav-number">1.5.</span> <span class="nav-text">del</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gulp-bytediff"><span class="nav-number">1.6.</span> <span class="nav-text">gulp-bytediff</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gulp-print"><span class="nav-number">1.7.</span> <span class="nav-text">gulp-print</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gulp-bump"><span class="nav-number">1.8.</span> <span class="nav-text">gulp-bump</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gulp-header"><span class="nav-number">1.9.</span> <span class="nav-text">gulp-header</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stream相关"><span class="nav-number">2.</span> <span class="nav-text">stream相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gulp-filter"><span class="nav-number">2.1.</span> <span class="nav-text">gulp-filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gulp-flatten"><span class="nav-number">2.2.</span> <span class="nav-text">gulp-flatten</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gulp-plumber"><span class="nav-number">2.3.</span> <span class="nav-text">gulp-plumber</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gulp-if"><span class="nav-number">2.4.</span> <span class="nav-text">gulp-if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#merge-stream"><span class="nav-number">2.5.</span> <span class="nav-text">merge-stream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#run-sequence"><span class="nav-number">2.6.</span> <span class="nav-text">run-sequence</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inject相关"><span class="nav-number">3.</span> <span class="nav-text">inject相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#wiredep"><span class="nav-number">3.1.</span> <span class="nav-text">wiredep</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gulp-inject"><span class="nav-number">3.2.</span> <span class="nav-text">gulp-inject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gulp-useref-与-gulp-rev、gulp-rev-replace"><span class="nav-number">3.3.</span> <span class="nav-text">gulp-useref 与 gulp-rev、gulp-rev-replace</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2010 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马斯特</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "97c12f7d7900436ca445becffbe0dc1a",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
