<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="o7yQBnLIoWby8Y5vNMQywBiMtev-ilWjXt89RQpTvVw" />













  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="AngularJS,promise,ES6,angular1-webpack-starter,集成测试,protractor,PageObject,ComponentObject," />





  <link rel="alternate" href="/atom.xml" title="进击的马斯特" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="上一篇聊完了单元测试，这一篇来说说E2E测试。单元测试着眼的是“关注分离”，测的是一些函数单元是不是工作正常，而E2E则是集成测试，从最终用户的角度来进行端到端（End To End）的测试，测一些用户场景是不是正常。这篇文章就来探讨一下写E2E测试的最佳实践，本文使用protractor 2.x和jasmine 2.x，但一些思路和想法同样适用于别的框架。">
<meta property="og:type" content="article">
<meta property="og:title" content="Angular里的E2E测试">
<meta property="og:url" content="http://pinkyjie.com/2016/02/22/e2e-testing-in-angular/index.html">
<meta property="og:site_name" content="进击的马斯特">
<meta property="og:description" content="上一篇聊完了单元测试，这一篇来说说E2E测试。单元测试着眼的是“关注分离”，测的是一些函数单元是不是工作正常，而E2E则是集成测试，从最终用户的角度来进行端到端（End To End）的测试，测一些用户场景是不是正常。这篇文章就来探讨一下写E2E测试的最佳实践，本文使用protractor 2.x和jasmine 2.x，但一些思路和想法同样适用于别的框架。">
<meta property="og:image" content="http://7jptbo.com1.z0.glb.clouddn.com/images/e2e-testing-in-angular-1.png">
<meta property="og:image" content="http://7jptbo.com1.z0.glb.clouddn.com/images/e2e-testing-in-angular-2.png">
<meta property="og:updated_time" content="2017-02-20T10:01:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Angular里的E2E测试">
<meta name="twitter:description" content="上一篇聊完了单元测试，这一篇来说说E2E测试。单元测试着眼的是“关注分离”，测的是一些函数单元是不是工作正常，而E2E则是集成测试，从最终用户的角度来进行端到端（End To End）的测试，测一些用户场景是不是正常。这篇文章就来探讨一下写E2E测试的最佳实践，本文使用protractor 2.x和jasmine 2.x，但一些思路和想法同样适用于别的框架。">
<meta name="twitter:image" content="http://7jptbo.com1.z0.glb.clouddn.com/images/e2e-testing-in-angular-1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://pinkyjie.com/2016/02/22/e2e-testing-in-angular/"/>





  <title> Angular里的E2E测试 | 进击的马斯特 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-45012422-1', 'auto');
  ga('send', 'pageview');
</script>








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1253033676&web_id=1253033676" language="JavaScript"></script>
  </div>






  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">进击的马斯特</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">CODING MY LIFE</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', '8k3UxSuRWYkrhVg55bC3','2.0.0');
</script>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://pinkyjie.com/2016/02/22/e2e-testing-in-angular/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马斯特">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pinkyjie-blog.qiniudn.com/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进击的马斯特">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Angular里的E2E测试
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-22T01:39:13+11:00">
                Feb 22nd 2016
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端开发/" itemprop="url" rel="index">
                    <span itemprop="name">前端开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2016/02/22/e2e-testing-in-angular/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>上一篇聊完了<a href="/2016/02/20/separation-of-concerns-in-unit-test/">单元测试</a>，这一篇来说说E2E测试。单元测试着眼的是“关注分离”，测的是一些函数单元是不是工作正常，而E2E则是集成测试，从最终用户的角度来进行端到端（End To End）的测试，测一些用户场景是不是正常。这篇文章就来探讨一下写E2E测试的最佳实践，本文使用protractor 2.x和jasmine 2.x，但一些思路和想法同样适用于别的框架。</p>
<a id="more"></a>
<h3 id="使用mock-API和非真实后台"><a href="#使用mock-API和非真实后台" class="headerlink" title="使用mock API和非真实后台"></a>使用mock API和非真实后台</h3><p>这一点其实存在很大争议，很多人觉得E2E测试作为集成测试就应该使用纯真实的server环境，所有后台API都应该实打实。我个人认为E2E测试是更偏向于开发者的测试而不是QA的测试，QA的测试当然要“真枪实弹”，但开发者使用mock API我觉得更加方便。我认为好处主要有以下几点：</p>
<ul>
<li>mock的API不仅可以用于测试，还可以加速开发。现在的Web开发早已趋向彻底的前后分离，后端只提供API，其他的都归前端。前端在开发阶段就需要根据前后端商量好的contract来mock API，使得在后端API未完工的情况下可以方便的进行前端的开发。所以mock一次，开发和测试阶段都能用，划算啊！</li>
<li>迅速解决“前后端撕逼”问题。众所周知，<strong>所有的bug都是前端bug</strong>，因为QA测的是你的前端页面啊，不管bug是什么引起的，肯定都是报给前端啊。所以，前端每天要做的一件重要的事就是迅速分辨哪些bug是由后端API引起的。使用mock API跑E2E测试，就是要保证在后端API正常返回的情况下前端逻辑能正常工作。这样一旦E2E测试跑过了，就可以迅速撇清关系：对不起，请把这个bug assign给后台修！</li>
<li>节约测试成本。使用mock API使得E2E测试可以跑在自己的开发server上，不仅可以减轻测试 server的压力，更是避免了真实测试环境的一些资源消耗。</li>
<li>跑起来速度快！没了真实环境的束缚，API想几秒返回就几秒返回，测试跑起来自然非常快了。</li>
</ul>
<p>说完了好处，来说说问题。使用mock API带来的最大问题就是，你需要保证你mock的逻辑与后台的真实逻辑是相匹配的。比如说，后台有DB，你也要有一个类似数据库的地方存数据；后台可以根据不同的输入返回正确的值或错误代码，你的mock同样需要做到这一点。在谈具体的解决方案之前，让我们先从文件夹结构说起，下图是我在项目中常用的E2E文件夹结构：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/e2e-testing-in-angular-1.png" class="center-img" title="图1">
<p>e2e文件夹下分了mocks和specs两个目录，specs不多说，重点看看mocks目录。</p>
<ul>
<li>index.js：这个文件是“带mock API的app”的入口，来看一个简单的例子：</li>
</ul>
<figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'appTest'</span>, [</div><div class="line">    app.name,</div><div class="line">    <span class="string">'ngMockE2E'</span></div><div class="line">])</div><div class="line">    .service(MockData.name, MockData)</div><div class="line">    .config(appTestConfig)</div><div class="line">    .run(userServiceMock)</div><div class="line">    .run(phoneServiceMock);</div></pre></td></tr></table></figure>
<p>其中定义了新的module，它依赖原始的app的module，并在其上定义一些新的配置和service。</p>
<ul>
<li>e2e.config.js：这是“带mock API的app”的配置，就是上面代码第6行的<code>appTestConfig</code>，一般我们可以用它定义API的请求延迟。由于使用了mock API，HTTP请求是可以立即返回的，为了让其更逼真，我们可以使用interceptor来监听所有<code>/api</code>开头的请求，让其过几秒再返回，以此来模拟真实的环境。</li>
</ul>
<figure class="highlight javascript"><figcaption><span>e2e.config.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">appTestConfig.$inject = [<span class="string">'$httpProvider'</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">appTestConfig</span> (<span class="params">$httpProvider</span>) </span>&#123;</div><div class="line">    $httpProvider.interceptors.push(apiDelayInterceptor);</div><div class="line">    apiDelayInterceptor.$inject = [<span class="string">'$timeout'</span>, <span class="string">'$q'</span>];</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">apiDelayInterceptor</span> (<span class="params">$timeout, $q</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            response (response) &#123;</div><div class="line">                <span class="comment">// all API response will be delayed 1s to simulate real network</span></div><div class="line">                <span class="keyword">const</span> delay = <span class="number">1000</span>;</div><div class="line">                <span class="keyword">if</span> (response.config.url.match(<span class="regexp">/^api\//</span>)) &#123;</div><div class="line">                    <span class="keyword">const</span> d = $q.defer();</div><div class="line">                    $timeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">                        d.resolve(response);</div><div class="line">                    &#125;, delay);</div><div class="line">                    <span class="keyword">return</span> d.promise;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> response;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> appTestConfig;</div></pre></td></tr></table></figure>
<ul>
<li>e2e.data.js：这个文件定义了一个service（就是index里的<code>MockData</code>），它的作用就是我们前面提到的DB，它包含API要返回的各种数据。之所以将它定义为service，是利用service单例的特性，在E2E测试中，只要页面不刷新，前一个请求对数据的写操作就可以反映到后一个请求的读操作中，这样就跟真实环境的DB很类似了。</li>
<li>e2e.phone.js/e2e.user.js：这两个文件分别对应原始app中定义的service，针对每个service都要有这么一个文件，这个文件的作用就是mock原始service里的各种API请求。来看一个登录API的例子：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">userServiceMock.$inject = [<span class="string">'MockData'</span>, <span class="string">'$httpBackend'</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">userServiceMock</span> (<span class="params">MockData, $httpBackend</span>) </span>&#123;</div><div class="line">    $httpBackend.whenPOST(<span class="string">'api/user/login'</span>).respond(loginHandler);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loginHandler</span> (<span class="params">method, url, data</span>) </span>&#123;</div><div class="line">        <span class="keyword">const</span> req = <span class="built_in">JSON</span>.parse(data);</div><div class="line">        <span class="keyword">if</span> (req.email === <span class="string">'error@error.com'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> [<span class="number">200</span>, &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">message</span>: <span class="string">'LOGIN_WRONG_EMAIL_PASSWORD_PAIR'</span>,</div><div class="line">                <span class="attr">result</span>: <span class="literal">null</span></div><div class="line">            &#125;];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.email === <span class="string">'lock@lock.com'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> [<span class="number">200</span>, &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">message</span>: <span class="string">'LOGIN_USER_IN_LOCK'</span>,</div><div class="line">                <span class="attr">result</span>: <span class="literal">null</span></div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">        MockData.loginStatus = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">return</span> [<span class="number">200</span>, &#123;</div><div class="line">            <span class="attr">code</span>: <span class="number">0</span>, <span class="attr">message</span>: <span class="literal">null</span>,</div><div class="line">            <span class="attr">result</span>: &#123;</div><div class="line">                <span class="attr">user</span>: MockData.userInfo</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> userServiceMock;</div></pre></td></tr></table></figure>
<p>可以看到，为了让其更逼真，我们可以根据请求发过来的不同数据来mock不同的响应，给出不同的错误代码，这样在E2E测试里我们就可以模拟更多的用户场景了。</p>
<h3 id="PageObject应该包含啥"><a href="#PageObject应该包含啥" class="headerlink" title="PageObject应该包含啥"></a>PageObject应该包含啥</h3><p>PageObject是protractor官方推荐的<a href="http://www.protractortest.org/#/page-objects#with-pageobjects" target="_blank" rel="external">最佳实践</a>，它最大的好处就是将页面元素的选择器与测试本身隔离开，这样一旦页面结构发生变化，只需要更新PageObject即可，测试部分的代码不用变动。在<a href="http://www.protractortest.org/#/page-objects#with-pageobjects" target="_blank" rel="external">官方的例子</a>中，PageObject除了包含元素的定义以外，还包含一个<code>get()</code>函数来加载这个页面，包含两个其他函数来对元素进行输入和获取文字的操作。对于这个例子我持有保留意见，我的看法是好的PageObject应该包含以下这些东西：</p>
<ul>
<li><code>load()</code>或<code>get()</code>函数，用来加载页面。</li>
<li>页面上所有测试需要用到的元素。</li>
<li>页面测试需要用到的数据，比如测试表单页面时需要填入的测试数据。</li>
<li>共享的测试用例，比如多个测试用例可能都需要用到公用的代码来assert特定的逻辑，那么这个公用逻辑可以作为函数提出来放入PageObject。</li>
<li>不要包含对元素的操作函数，像官方例子中的函数，只是简单的在元素上调用<code>.sendKey(xxx)</code>或<code>getText()</code>，我认为没必要将其封装成函数，直接写会更加直观，看测试代码的人也比较容易明白。</li>
<li>每个PageObject单独放一个文件，然后每个文件export这个class，这样一来，如果其他的PageObject依赖这个页面，可以方便的引入。</li>
</ul>
<p>另外，ES6让继承写起来更方便了，我们完全可以打开脑洞，给所用的PageObject来一个基类：<code>BasePageObject</code>，来看一个例子（完整的实现可以看<a href="https://github.com/PinkyJie/angular1-webpack-starter/blob/master/source/test/e2e/helper.js" target="_blank" rel="external">这里</a>）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePageObject</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (url) &#123;</div><div class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;url&#125;);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.ele = <span class="keyword">this</span>._getAllElements();</div><div class="line">        <span class="keyword">this</span>.mainTitle = <span class="string">'Aio Angular App'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    load () &#123;</div><div class="line">        browser.get(<span class="string">`<span class="subst">$&#123;browser.baseUrl&#125;</span>/<span class="subst">$&#123;<span class="keyword">this</span>.url&#125;</span>`</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getHeader () &#123;...&#125;</div><div class="line">    getFooter () &#123;...&#125;</div><div class="line">    getSidebar () &#123;...&#125;</div><div class="line">    getBreadcrumb () &#123;...&#125;</div><div class="line">    getModal () &#123;...&#125;</div><div class="line"></div><div class="line">    <span class="comment">// shared test case</span></div><div class="line">    assertCorrectLayout (config) &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BasePageObject包含所有PageObject都会使用到的公用函数，它的构造函数接收一个url作用参数，这个url被<code>load()</code>函数使用来加载页面，它是子类继承后在子类构造函数中通过<code>super(xxx)</code>来传入的。另外它调用了一个<code>_getAllElements()</code>的函数获得所有元素的定义并将其挂在<code>this.ele</code>对象上方便使用，而这个<code>_getAllElements</code>也是要靠子类自己来实现的。除此之外，我们看到第13-17行定义了四个函数用来获取一些公共的布局组件，因为基本各个页面都包含这些组件，放在基类中子类就可以直接用了。最后基类还包含了公共的测试用例函数<code>assertCorrectLayout()</code>，它接受一个config。从函数名字就可以大致猜到它的作用：每个页面可能都要测试一些公共的布局，比如页面的URL、标题是不是正确啊，header和footer显示是否正常，sidebar和breadcrumb导航是不是能正常工作等等。这些测试每个页面都做，所以把它放在基类中，子类只需要传入一个配置对象即可。来看一个子类PageObject的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> LoginPage <span class="keyword">from</span> <span class="string">'./login.page'</span>;</div><div class="line"><span class="comment">// phone page object</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhonePage</span> <span class="keyword">extends</span> <span class="title">browser</span>.<span class="title">_BasePageObject</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> () &#123;</div><div class="line">        <span class="keyword">super</span>(<span class="string">'phone'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _getAllElements () &#123;</div><div class="line">        <span class="keyword">const</span> $page = $(<span class="string">'.phone-main-view'</span>);</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">addNewBtn</span>: $page.$(<span class="string">'.btn-add-new'</span>),</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// overrite load function to support login</span></div><div class="line">    load () &#123;</div><div class="line">        <span class="keyword">super</span>.load();</div><div class="line">        <span class="keyword">const</span> loginPage = <span class="keyword">new</span> LoginPage();</div><div class="line">        browser._.expectUrlToMatch(loginPage.url);</div><div class="line">        loginPage.loginWithCredential(<span class="string">'f@f'</span>, <span class="string">'f'</span>);</div><div class="line">        browser._.expectUrlToMatch(<span class="keyword">this</span>.url);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，继承了父类后，子类的PageObject要做的就是：</p>
<ul>
<li>子类构造函数中调用父类的构造函数并传入自己的URL。</li>
<li>实现<code>_getAllElements</code>函数，定义自己的页面元素。</li>
<li>根绝需要覆盖父类的<code>load()</code>函数。在这个例子中，假设phone页面需要登录后才能查看，那么直接访问<code>/phone</code>就会被重定向到login页面，那我们就需要依赖LoginPageObject的一些定义和函数，如这里的登录逻辑，成功登录后才能看到自己的页面。所以对于需要登录的页面，我们都要覆盖父类的load函数。</li>
</ul>
<blockquote>
<p>load函数里调用了一些<code>browser._</code>上的函数，这是我们自己定义的helper函数，后面会讲到。</p>
</blockquote>
<h3 id="PageObject里的元素该咋定义"><a href="#PageObject里的元素该咋定义" class="headerlink" title="PageObject里的元素该咋定义"></a>PageObject里的元素该咋定义</h3><p>看到这个标题有人会问：这算问题吗？那我换个方式问，挂在<code>this.ele</code>上的（也就是<code>_getAllElements()</code>函数返回的）应该是选择器本身<code>.xxx</code>还是element包装过的对象<code>$(.xxx)</code>呢？从使用者的角度讲，当然是包装过的对象了，因为方便直接调用上面的一些函数啊。但有些情况下，你还是需要选择器的，举个例子：一个表格里四行三列，行选择器是<code>.row</code>，列选择器分别是<code>.col1/.col2/.col3</code>等。测试里可能需要验证每一个格子里的文字，我们不可能把12个元素都写死放在ele变量上，如何更方便的解决这种需求呢？我的方案是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_getAllElements () &#123;</div><div class="line">    <span class="keyword">const</span> $table = $(<span class="string">'.table'</span>);</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">row</span>: &#123;</div><div class="line">            <span class="attr">view</span>: $page.$$(<span class="string">'.row'</span>),</div><div class="line">            <span class="attr">col1</span>: <span class="string">'.col1'</span>,</div><div class="line">            <span class="attr">col2</span>: <span class="string">'.col2'</span>,</div><div class="line">            <span class="attr">col3</span>: <span class="string">'.col3'</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，我们只返回一个<code>row</code>的元素，它是一个对象，里面的view属性返回包装过的多个元素（<code>$$</code>等价于<code>element.all</code>），其他属性则是它的子元素选择器。简单的说，存在多个实例的父元素（如表格的行）我们使用包装过的对象，对于每行的格子我们使用纯选择器。然后具体的测试中我们就可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> rowList = page.ele.row;</div><div class="line">expect(rowList.view.count()).toBe(<span class="number">4</span>);</div><div class="line"><span class="comment">// first row</span></div><div class="line"><span class="keyword">const</span> first = rowList.view.get(<span class="number">0</span>);</div><div class="line">expect(first.$(rowList.col1).getText()).toBe(xxx);</div></pre></td></tr></table></figure>
<p>遇到存在多个父元素，而每个父元素里又存在很多不同子元素的情况下，可以尝试使用这种方式来定义元素。定义的时候不显得重复，使用的时候也没有很麻烦。</p>
<h3 id="使用ComponentObject"><a href="#使用ComponentObject" class="headerlink" title="使用ComponentObject"></a>使用ComponentObject</h3><p>在<a href="2016/01/31/component-based-development-with-angular-1x/">前面的文章</a>里我们讲过，在基于组件开发的实践中，页面其实是由各个组件搭成的。那么很自然的，PageObject也应该由ComponentObject来组成。同一个组件在不同的页面上重用时，组件内部的元素肯定都是一样的，一些逻辑也基本一致。所以ComponentObject里可以包含这个组件的所有元素以及一些公共的测试用例。考虑到Component在重用时，一般父级元素是不一样的，所以在ComponentObject的构造函数中可以传入一个parentElement的参数用来将组件内的选择器都限定在这个父选择器之内。来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// phone form component object</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFormComp</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (parentElement) &#123;</div><div class="line">        <span class="keyword">const</span> $form = parentElement.$(<span class="string">'.phone-form-view'</span>);</div><div class="line">        <span class="keyword">this</span>.ele = &#123;</div><div class="line">            <span class="attr">saveBtn</span>: $form.$(<span class="string">'.btn-save'</span>),</div><div class="line">            <span class="attr">cancelBtn</span>: $form.$(<span class="string">'.btn-cancel'</span>)</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    assertFormFieldError (field, isError, message) &#123;&#125;</div><div class="line">    assertPhoneDetail (phone) &#123;&#125;</div><div class="line">    assertEditPhoneDetail (phone) &#123;&#125;</div><div class="line">    assertEditingForm (phone, isNew) &#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> PhoneFormComp;</div></pre></td></tr></table></figure>
<p>可以看到在这个Form组件的定义中，组件内所有元素都是定义在传入的父元素的基础上的，这样即便一个页面内有多个同样的组件也不会重复，使用的时候只要传入不同的父级元素即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> PhoneFormComp <span class="keyword">from</span> <span class="string">'./phone-form.comp'</span>;</div><div class="line"></div><div class="line"><span class="comment">// phone add page object</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneAddPage</span> <span class="keyword">extends</span> <span class="title">browser</span>.<span class="title">_BasePageObject</span> </span>&#123;</div><div class="line">    _getAllElements () &#123;</div><div class="line">        <span class="keyword">const</span> $page = $(<span class="string">'.phone-add-view'</span>);</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">form</span>: <span class="keyword">new</span> PhoneFormComp($page)</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="善用helper函数和自定义matcher"><a href="#善用helper函数和自定义matcher" class="headerlink" title="善用helper函数和自定义matcher"></a>善用helper函数和自定义matcher</h3><p>在写E2E测试的时候，我们可能会用到很多工具函数，比如说操作一个select框啊，操作一个DatePicker啊等等，这些操作可能在多个测试用例里都会用到，那么我们可以直接定义一个<code>E2EHelper</code>的class用来存放这些helper函数。在protractor的配置文件中，我们在onPrepare里引入这个class，并将其定义在<code>browser._</code>上，因为browser是所有的spec里默认都可以访问到的，所以很多全局变量都可以考虑挂在它上面。这样在spec文件的测试里就可以方便的使用<code>browser._.xxx</code>来调用这些函数了。</p>
<p>除了helper函数，有的时候我们可能还需要一些自定义的Matcher来扩展jasmine中没有的功能，比如最常用的判断一个元素是否含有某个class样式，与其每次都在测试用例里手写<code>expect(ele.getAttribute(&#39;class&#39;)).toContain(xxx)</code>，不如直接扩展jasmine定义自己的Matcher，语义上更容易理解。Matcher的定义也非常的简单，下面就是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> customMatchers = &#123;</div><div class="line">    <span class="attr">toHaveClass</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">compare</span>: <span class="function">(<span class="params">actual, expected</span>) =&gt;</span> &#123;</div><div class="line">                <span class="keyword">return</span> &#123;</div><div class="line">                    <span class="attr">pass</span>: actual.getAttribute(<span class="string">'class'</span>).then(<span class="function">(<span class="params">classes</span>) =&gt;</span> &#123;</div><div class="line">                        <span class="keyword">return</span> classes.split(<span class="string">' '</span>).indexOf(expected) !== <span class="number">-1</span>;</div><div class="line">                    &#125;)</div><div class="line">                &#125;;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>有了这个定义以后，我们在测试中就可以直接写<code>expect(ele).toHaveClass(xxx)</code>了。网上还有很多成熟的库，包含很多常用的Matcher，感兴趣的可以索索“protractor custom matcher”。自定义的Matcher也需要在onPrepare中初始化，我们在里面定义一个beforeEach函数，把自定义的Matcher加入到jasmine中去。看下面的例子，onPrepare中包含helper函数，上一节提到的BasePageObject，以及自定义的Matcher。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">onPrepare: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> helper = <span class="built_in">require</span>(<span class="string">'./source/test/e2e/helper'</span>);</div><div class="line">    browser._BasePageObject = helper.BasePageObject;</div><div class="line">    browser._ = <span class="keyword">new</span> helper.E2EHelper();</div><div class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="comment">// add custom matchers</span></div><div class="line">        jasmine.addMatchers(helper.customMatchers);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="protractor的大部分函数都返回promise"><a href="#protractor的大部分函数都返回promise" class="headerlink" title="protractor的大部分函数都返回promise"></a>protractor的大部分函数都返回promise</h3><p>这一点可能平时没有注意，其实protractor官方的文档里专门有<a href="http://www.protractortest.org/#/control-flow" target="_blank" rel="external">讲这个</a>。也就是说，平时我们使用的<code>.getText()</code>，<code>.isDisplayed()</code>，<code>.getAttribute()</code>等等返回的都是promise，之所以我们可以直接那么用，是因为jasmine的<code>expect()</code>函数真正expect的是promise resolve后的值。相信平时使用这些函数的时候倒不会犯什么错，最容易犯错的是，定义一些自己的函数时，比如下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ele.isDisplayed()) &#123;</div><div class="line">    <span class="comment">// do something</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// do others</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码的原意是如果元素显示的话，我们做一些事情，不显示的话我们做别的。但事实是这个if判断永远为true，因为里面是一个promise！所以正确的写法应该是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ele.isDisplayed().then(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (val) &#123;</div><div class="line">        <span class="comment">// do something</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// do others</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>要时刻记住protractor里绝大部分的函数返回的都是promise，如果我们自定义的逻辑用到这些函数，就应该以处理promise的方式来处理它们。</p>
<h3 id="其它小tip"><a href="#其它小tip" class="headerlink" title="其它小tip"></a>其它小tip</h3><p>最后说一些让protractor更加好用的小tip。</p>
<h4 id="让测试report更好看"><a href="#让测试report更好看" class="headerlink" title="让测试report更好看"></a>让测试report更好看</h4><p>protractor默认的测试report就是在命令行里输出<code>...F..F..</code>，这么丑的report能忍吗？叔能忍婶不能忍啊！在karma中我们有reporter这个选项，让我们可以配置友好的测试输出，但protractor似乎没有这个配置啊。别急，其实早有人解决了这个难题，试试<a href="https://www.npmjs.com/package/jasmine-spec-reporter" target="_blank" rel="external">jasmine-spec-reporter</a>吧。你要做的很简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 禁用默认的输出</span></div><div class="line">jasmineNodeOpts: &#123;</div><div class="line">    <span class="attr">print</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 添加新的reporter</span></div><div class="line">onPrepare: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> SpecReporter = <span class="built_in">require</span>(<span class="string">'jasmine-spec-reporter'</span>);</div><div class="line">    jasmine.getEnv().addReporter(<span class="keyword">new</span> SpecReporter(&#123;</div><div class="line">        <span class="attr">displayStacktrace</span>: <span class="string">'all'</span>,</div><div class="line">        <span class="attr">displayFailuresSummary</span>: <span class="literal">false</span></div><div class="line">    &#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再跑一下测试看看，结果是不是好看多了？</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/e2e-testing-in-angular-2.png" class="center-img" title="图2">
<p>除了这两个选项外，它还支持很多有意思的配置，具体可以探索它的<a href="https://www.npmjs.com/package/jasmine-spec-reporter" target="_blank" rel="external">文档</a>。</p>
<h4 id="失败时自动截图"><a href="#失败时自动截图" class="headerlink" title="失败时自动截图"></a>失败时自动截图</h4><p>由于测试都是自动化的，一旦跑失败我们除了看log找原因以外，如果有截图就更好了。其实截图也属于reporter的一种，借助插件<a href="https://www.npmjs.com/package/protractor-jasmine2-screenshot-reporter" target="_blank" rel="external">protractor-jasmine2-screenshot-reporter</a>我们就可以实现在E2E测试失败的时候自动保存当前网页的截图到指定文件夹。它的配置也很简单，与上面的reporter类似，也是直接往onPrepare里面添加代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> HtmlScreenshotReporter = <span class="built_in">require</span>(<span class="string">'protractor-jasmine2-screenshot-reporter'</span>);</div><div class="line">jasmine.getEnv().addReporter(<span class="keyword">new</span> HtmlScreenshotReporter(&#123;</div><div class="line">    <span class="attr">dest</span>: <span class="string">`<span class="subst">$&#123;e2eBaseFolder&#125;</span>/screenshots`</span>,</div><div class="line">    <span class="attr">filename</span>: <span class="string">'e2e-report.html'</span>,</div><div class="line">    <span class="attr">captureOnlyFailedSpecs</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">reportOnlyFailedSpecs</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">pathBuilder</span>: <span class="function">(<span class="params">currentSpec</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> currentSpec.description.replace(<span class="regexp">/[ :]/g</span>, <span class="string">'-'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>除了截图，它还支持输出HTML格式的report（第4行），利用pathBuilder函数我们还可以指定截图文件的名称，上例中我们直接将失败的spec的description作为文件名保存。</p>
<h4 id="ES6的报错行号"><a href="#ES6的报错行号" class="headerlink" title="ES6的报错行号"></a>ES6的报错行号</h4><p>protractor 2.x需要手动引入babel来支持使用ES6来书写spec文件，至于配置文件本身，只要你的node版本够高（4.x）或使用<code>--harmony</code>也是可以用ES6来写的。但如果你在protractor的配置文件一开头就引入babel<code>require(&#39;babel-core/register&#39;);</code>就会发现，一旦spec报错，log里给出的报错行号是不对的，在protractor的issues里有人给出了<a href="https://github.com/angular/protractor/issues/2049#issuecomment-146357769" target="_blank" rel="external">解决方案</a>，其实只要在onPrepare里再引入babel即可。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/AngularJS/" rel="tag"># AngularJS</a>
          
            <a href="/tags/promise/" rel="tag"># promise</a>
          
            <a href="/tags/ES6/" rel="tag"># ES6</a>
          
            <a href="/tags/angular1-webpack-starter/" rel="tag"># angular1-webpack-starter</a>
          
            <a href="/tags/集成测试/" rel="tag"># 集成测试</a>
          
            <a href="/tags/protractor/" rel="tag"># protractor</a>
          
            <a href="/tags/PageObject/" rel="tag"># PageObject</a>
          
            <a href="/tags/ComponentObject/" rel="tag"># ComponentObject</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/02/20/separation-of-concerns-in-unit-test/" rel="next" title="谈谈单元测试中的关注分离">
                <i class="fa fa-chevron-left"></i> 谈谈单元测试中的关注分离
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/02/27/continuous-integration-with-travis-ci/" rel="prev" title="用TravisCI来做持续集成">
                用TravisCI来做持续集成 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://pinkyjie-blog.qiniudn.com/images/avatar.jpg"
               alt="马斯特" />
          <p class="site-author-name" itemprop="name">马斯特</p>
           
              <p class="site-description motion-element" itemprop="description">前端 | 溜冰 | Mac</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">55</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">186</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用mock-API和非真实后台"><span class="nav-number">1.</span> <span class="nav-text">使用mock API和非真实后台</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PageObject应该包含啥"><span class="nav-number">2.</span> <span class="nav-text">PageObject应该包含啥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PageObject里的元素该咋定义"><span class="nav-number">3.</span> <span class="nav-text">PageObject里的元素该咋定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用ComponentObject"><span class="nav-number">4.</span> <span class="nav-text">使用ComponentObject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#善用helper函数和自定义matcher"><span class="nav-number">5.</span> <span class="nav-text">善用helper函数和自定义matcher</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protractor的大部分函数都返回promise"><span class="nav-number">6.</span> <span class="nav-text">protractor的大部分函数都返回promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其它小tip"><span class="nav-number">7.</span> <span class="nav-text">其它小tip</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#让测试report更好看"><span class="nav-number">7.1.</span> <span class="nav-text">让测试report更好看</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#失败时自动截图"><span class="nav-number">7.2.</span> <span class="nav-text">失败时自动截图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6的报错行号"><span class="nav-number">7.3.</span> <span class="nav-text">ES6的报错行号</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2010 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马斯特</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "97c12f7d7900436ca445becffbe0dc1a",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
