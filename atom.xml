<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>进击的马斯特</title>
  <subtitle>CODING MY LIFE</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pinkyjie.com/"/>
  <updated>2017-02-22T07:58:16.000Z</updated>
  <id>http://pinkyjie.com/</id>
  
  <author>
    <name>马斯特</name>
    <email>pilixiaoxuanfeng@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最近的海外面试（前端）经历</title>
    <link href="http://pinkyjie.com/2017/02/21/recent-overseas-interview-experiences/"/>
    <id>http://pinkyjie.com/2017/02/21/recent-overseas-interview-experiences/</id>
    <published>2017-02-21T05:55:47.000Z</published>
    <updated>2017-02-22T07:58:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>从去年10月开始投简历到今年1月为止，这三个多月的时间我断断续续面了五六家海外的公司，主要集中在欧洲和澳洲，面的都是前端开发的职位。这里就介绍下整个面试经历，希望对有同样想法的同学有所帮助。</p>
<a id="more"></a>
<h3 id="做简历和写求职信"><a href="#做简历和写求职信" class="headerlink" title="做简历和写求职信"></a>做简历和写求职信</h3><p>简历大家自然都有，这里我要说的是如果要找海外的工作，最好在<a href="https://www.linkedin.com/" target="_blank" rel="external">LinkedIn</a>上维护一份详细的英文简历，不管你是否打算在LinkedIn上投简历，这都是很有用的。</p>
<ul>
<li><p>首先，很多公司在投简历的时候不要你发送的PDF简历，而是要求你在它自己的网站上填写一堆信息（想想国内的一些国企就知道了），包括教育经历、工作经历、项目经验等等，每次都填不得闹心死。而LinkedIn的好处就是，作为全球最主流的社交求职网站，绝大部分让你手填简历的网站都是支持从LinkedIn导入的，所以，维护好LinkedIn可以让你一次填写多处使用。</p>
</li>
<li><p>另外，还是有很多猎头或公司HR在LinkedIn上搜候选人的，比如我面Facebook的机会就是HR主动邮件联系我说在LinkedIn上看到的。</p>
</li>
</ul>
<p>LinkedIn上的简历可以要多详细写多详细，同时我觉得自己制作的PDF简历应该言简意赅，这点相信大家都有共识。我也做过简历筛选，就我自己来讲，我非常希望能有几个关键词或几个bullet就让我看明白候选人的优势。这一点同样适用于项目经历，我比较喜欢看到项目经历下面直接列几个bullet，告诉我“这是个什么项目”，“你在里面贡献了啥”，“有什么重大的改进”等等。</p>
<blockquote>
<p>这里安利下我的一个<a href="https://github.com/PinkyJie/resume" target="_blank" rel="external">简历生成项目</a>，只需要维护一份中英文的JSON文件，即可生成在线的web简历和PDF简历。</p>
</blockquote>
<p>除了简历之外，国外很多职位在投递的时候会强制要求你写求职信（其实国内很多外企也有类似要求）。求职信（cover letter）一般就是介绍下“我对这个职位很感兴趣啊”，“我有很多经历啊”，“我的优势很适合这个职位啊”等等。与简历类似，我认为求职信也要言简意赅。比如说，第一段可以写写从哪看到这个职位，如何感兴趣，一两句话就行。最后一段可以写写希望能给面试机会好好聊聊，也是一两句话。最重要的中间一段我一般直接用bullet这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Highlights of my career:</div><div class="line">* 5+ years&apos; experiences in Internet industry</div><div class="line">* 3 years&apos; experiences on Front end development, experienced in Angular.js, React</div><div class="line">* Experienced in building a web app from scratch and doing unit/e2e testing</div><div class="line">* Passionated on using CI to automate building/testing/deployment</div><div class="line">* Specific focus on architectural improvement and workflow automation</div><div class="line">* Love open source, check my github on https://github.com/PinkyJie</div></pre></td></tr></table></figure>
<p>当然，内容要根据职位的JD做相应修改，反正就是在不撒谎的前提下把你的经历往JD的要求上尽量靠呗。</p>
<h3 id="去哪投简历"><a href="#去哪投简历" class="headerlink" title="去哪投简历"></a>去哪投简历</h3><p>准备好了简历和求职信，那么就开始搜职位投简历吧。我前前后后也试了很多求职网站，包括一些全球有名的求职网站如<a href="https://www.monster.com" target="_blank" rel="external">Monster</a>，以及一些地域性的求职网站：</p>
<ul>
<li>爱尔兰：<a href="http://www.irishjobs.ie/" target="_blank" rel="external">IrishJob</a></li>
<li>澳大利亚和新西兰：<a href="https://www.seek.com.au/" target="_blank" rel="external">SEEK</a></li>
</ul>
<p>说实话效果都不是很好，感觉里面更多的面向本地人，你无法分辨这个职位到底想不想招外国人。一个偶然的机会我看到了<a href="http://stackoverflow.com/jobs" target="_blank" rel="external">StackOverflow Jobs</a>，没错，就是那个大家常去的问答网站，它居然有一个Jobs版块，并且这个版块有非常适合找国外工作的筛选机制。直接上图吧：</p>
<ul>
<li>访问<a href="http://stackoverflow.com/jobs" target="_blank" rel="external">StackOverflow Jobs</a>，点击如下的删选按钮。</li>
</ul>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/recent-overseas-interview-experiences-1.png" class="center-img" title="图1">
<ul>
<li><p>出来筛选界面以后，点击其中的<code>Perks</code>选项卡，勾上其中的两项”Visa Sponser”和”Offers relocation”，这两项是最适合我这种海外求职者的，它们的意思是：</p>
<ul>
<li>Visa Sponser: 是说公司会协助你办理签证，有的是全权帮你办理，有的是协助办理。当然，工作签证没有公司协助一般是不行的。但这句话表明这个职位是愿意招非本国公民的。</li>
<li>Offers relocation: 是说公司会给你报销从别的国家搬到公司所在地所产生的一些费用，有的还会协助你租房、融入当地生活等等。</li>
</ul>
</li>
</ul>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/recent-overseas-interview-experiences-2.png" class="center-img" title="图2">
<p>这两项就是为我们这种海外求职者量身准备的。</p>
<ul>
<li>除此之外，StackOverflow还支持很多别的筛选，也很实用。比如下面的<code>Tech</code>选项卡里可以选择感兴趣的技术标签和不感兴趣的技术标签，这比直接搜职位名称要高效准确很多，可以准确匹配你想要搜的技术、库。另外几个选项卡有兴趣也可以自行探索，<code>Compensation</code>可以设置工资范围，<code>Background</code>可以设置工作年限，<code>Compnay</code>可以直接设置想搜索的公司名称。</li>
</ul>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/recent-overseas-interview-experiences-3.png" class="center-img" title="图3">
<p>个人经验，StackOverflow上的回复率非常高，我拿到的面试机会基本全部都是StackOverflow上投的。另外，有一种错觉就是会在StackOverflow上招聘的公司起码技术氛围还行吧。如果公司有大牛的话，在StackOverflow的公司介绍页面还可以看到他们的StackOverflow账号，“你将与下面这些人共事”。就地理位置上来说，StackOverflow上的前端职位德国和荷兰比较多，这也印证了“柏林”和“阿姆斯特丹”是欧洲的IT中心之说。至于公司类型，可以说大公司小公司创业公司都有的，比如<a href="http://stackoverflow.com/jobs/122287/senior-software-developer-tooling-autonomous-bmw-group?a=gGajTffTgMVKBIQw" target="_blank" rel="external">宝马总部慕尼黑在招自动驾驶算法工程师</a>哦！</p>
<blockquote>
<p>除了”Visa Sponser”和”Offers relocation”以外，有时还会看到”Provides Equity”，乍一看这是“提供公平机会”的意思，其实它的意思是这个职位有机会可以拿到公司的股票。另外有很多职位的名称上会包含<code>(m/f)</code>的字眼，这个意思是这个职位男女均可，很多德国的职位都会带这个。之所以如此奇怪是因为德语中很多职位名词男女是不一样的，比如“男秘书”和“女秘书”两个词是不同的，一般职位上只会写一个词，加上<code>(m/f)</code>（德语里是<code>(m/w)</code>）就代表这个职位男女都招。回头专门写一篇吐槽德语的文章吧。。。</p>
</blockquote>
<h3 id="面试前的准备"><a href="#面试前的准备" class="headerlink" title="面试前的准备"></a>面试前的准备</h3><p>投了简历后就等吧，被拒是很正常的，我就收到差不多二十封拒信，但一旦有面试机会来可要好好抓住。那如何准备面试呢？先来看看一般的面试流程吧，就我个人经验，一般的面试都会有三四轮甚至更多：</p>
<ol>
<li>做算法题：一般是一些在线平台如<a href="https://codility.com" target="_blank" rel="external">Codility</a>和<a href="https://www.hackerrank.com" target="_blank" rel="external">HackerRank</a>等，限时让你解题，在线提交代码。</li>
<li>HR面：跟国内差不多，问问简单的经历，然后来点behavioral interview等，但有的也会涉及简单的技术问题，国外的很多HR的title都是 Technical Recruiter。</li>
<li>技术面：一般长达两三个小时，会有不同的人轮流面，包括“共享屏幕敲代码”以及和简历项目相关的问题等等，基本跟国内差不多。</li>
</ol>
<p>下面就从这三个方面说说如何准备面试。</p>
<p>首先来说说算法题，就前端来说我目前碰到的稍微复杂一点的算法题大部分都是考递归。当然，去刷一些复杂的算法题肯定是有好处的，但我觉得一个好的js基础加理解递归似乎更重要一点。这里我推荐两个GitHub上的库，可以做做看看。</p>
<ul>
<li><a href="https://github.com/vasanthk/js-bits" target="_blank" rel="external">js-bits</a>: 详细讲解了js基础里的方方面面，建议可以配合示例代码好好理解。</li>
<li><a href="https://github.com/kolodny/exercises" target="_blank" rel="external">exercises</a>: 列举了一些常见的js面试题，有些简单有些复杂，可以自己写写试试。项目的设计很有意思，clone以后，需要在每个文件夹里写<code>index.js</code>实现要求的函数，然后每个文件夹下有测试，测试跑通就过了。</li>
</ul>
<p>当然HackerRank站点上本身有很多很多的题目可以做，可以自己注册个账号练练。除了多做题练习之外，还有几点也很重要。</p>
<ul>
<li>时间观念。目前我碰到的算法题在线测试环节都是限时的，一旦点击开始就没法停止，一般都是一两个小时左右的，所以一定要找自己能空出大把时间的时候来做。所有考试都一样，不要在一道题上花费大量时间，不会做先跳过就是了。</li>
<li>熟悉界面操作。每个算法题网站有自己的编辑器，一般都是左边题目右边编辑器。第一次进入都会有一个教程指引你如何操作，一定要认真看（看教程是不计时的）。我的习惯一般是本地开一个sublime，编辑好了本地用node跑跑，没问题了再复制代码上去。</li>
<li>考虑边界情况。这些在线测试给你的示例测试数据一般都很简单，没有什么边界情况，但你提交代码后它会把你的算法在一堆数据上跑，<strong>这些数据你是看不到的</strong>，全跑过了才算通过。这就需要写代码时自己考虑各种边界情况。</li>
<li><strong>很多网站一道题只能提交一次。</strong>这点非常重要，一旦提交，你将没法再次修改代码，一定要谨慎提交。很多网站会有一个<code>run</code>和一个<code>submit</code>按钮，<code>run</code>就是用示例数据或自己添加的数据跑你的代码，可以多次，<code>submit</code>就是直接提交去跑看不到的数据。看指引的时候一定要看清楚是否允许提交多次。</li>
</ul>
<p>下面来说说HR面，跟国内其实差不多，主要看自己的口语表达了。有几个问题是一定问会的，比如“介绍下自己的工作经历”，再比如motivation，即“你为什么想要找一份海外工作？为什么对我们公司感兴趣？”，再比如“你理想的工作环境是怎么样的？”，可以好好准备准备。感觉介绍自己的工作经历这块挺重要的，我刚开始总觉得没啥介绍的，一二十秒就完事了，后来我总结了下，其实这个问题可以变成“每段工作经历中有什么特别难忘的事？”，这样自己可以多说说，对方也可以听得更有意思一点，更可以把自己的优势穿插其中，事半功倍啊。除了上面说到的问题，每家都有自己的其他问题，咋准备呢？这里推荐一个超级牛逼的网站：<strong><a href="https://www.glassdoor.com/index.htm" target="_blank" rel="external">GlassDoor</a></strong>，一句话，这个网站就是公司界的大众点评，上面有各种Review：公司评价、面试评价、薪水评价等等。这里说说前两个，面试评价自不用说，很多人会写到“问了哪些问题”，都可以作为提前准备的参考。另外一个公司评价也很有用，里面会写公司的Pros和Cons，有的条目甚至CEO会亲自回复。这里不仅可以用来感知这个公司到底是否靠谱，更重要的是可以用里面的Cons来“反击”HR。因为HR面的结尾一般会问你是否有啥问题要问，人家都这么问了，你不问几个问题岂不是显得不尊重哈哈！这时可以说“看到公司有一些负面评价，请问你如何看待？”，虽然对方的解释可能很主旋律很官方，但我觉得这问题可以让对方觉得：你是有做功课的。</p>
<p>最后来说说技术面，这块就跟国内差不多了，一般是好几个人由浅入深的问。有的会涉及前面算法题环节你的代码及犯的错误，有的会针对你的背景问一些具体的库的使用一类的。关于这块的准备，我认为首先还是基础，可以以这个库<a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions" target="_blank" rel="external">Front-end-Developer-Interview-Questions</a>里的问题为提纲自查下自己的基础是否牢靠，除此之外自己以前做过的一些项目代码可以拿出来看看，以免被问到一些细节。同样的，技术面的最后也会问你是否有问题要问，这个时候我最喜欢的问题就是“介绍下作为开发者在公司的一天是怎样的？”，这是一个很有意思的问题，你基本可以从中了解到公司的项目如何进行、开发流程、文化等等。我觉得歪果仁还是很喜欢发问的孩子的，而且面试时间就那么长，你多问几个问题，他们就可以少问你几个问题，是不是^_^</p>
<blockquote>
<p>除此之外，还有一个问题不能忽视：时差！好多个国家不仅有时差，还有夏令时冬令时什么的，非常烦。这里推荐一个牛逼的网站：<a href="http://www.worldtimebuddy.com/" target="_blank" rel="external">World Time Buddy</a>，一目了然。</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/recent-overseas-interview-experiences-4.png" class="center-img" title="图4">
<p>不管是HR面还是技术面，一般都是事先邮件约好时间的，要么电话要么Skype，建议事先把自己的Skype放过去让对方事先添加好，以防输错SkypdId查找不到的问题，可以告知对方查不到请直接打电话。</p>
</blockquote>
<h3 id="各个公司的面试经历"><a href="#各个公司的面试经历" class="headerlink" title="各个公司的面试经历"></a>各个公司的面试经历</h3><p>前面啰嗦了那么多，下面就详细说说我目前参与过的各个公司的面试经历吧，流水账式介绍。</p>
<h4 id="Booking-com"><a href="#Booking-com" class="headerlink" title="Booking.com"></a><a href="https://www.booking.com" target="_blank" rel="external">Booking.com</a></h4><p>Booking.com是全球旅游住宿最大的网站了吧，总部在荷兰阿姆斯特丹，一直在海外招人。这个职位我是在<a href="https://jobs.github.com/" target="_blank" rel="external">Github Jobs</a>上投的，后来发现StackOverflow上也有的。投了以后很快就给回信了，面试的流程是：<br>线上做题、HR面、技术面、onsite技术面（就是说最后一轮给你报销路费住宿去阿姆斯特丹面去吧）。由于自己准备非常不充分，只面了两轮就挂了。</p>
<p>第一轮的做题区别于前面说的算法题，他们完全考HTML/CSS/JS/jQuery基础，全是选择题，20分钟做完。难度还是比较低的，基本是一些“inline和block区别啊”，闭包，原型链一类的基础题。提交了答案第二天就约下一轮了。第二轮对方直接打电话过来的，问了下一些以前的工作经历，完事后玩命问A/B测试的问题，比如“怎么做A/B测试啊？测试结果如何评判啊？”等等，虽然不是特别难，但奈何很多东西我不知道如何用英文表示，当时已经被问懵逼的我连最简单的“转化率”这个词都不知道怎么用英文表达。。。果不其然，第二天就收到邮件说挂了。</p>
<p>总结下来，还是得好好看JD啊，虽然JD上确实写了要懂A/B测试，但我毫无准备加上我从来没做过A/B测试，所以最后懵逼了。所以说JD不是随便写的，准备面试时一定要对里面强调的东西引起足够重视啊。</p>
<h4 id="mycs"><a href="#mycs" class="headerlink" title="mycs"></a><a href="https://de.mycs.com/" target="_blank" rel="external">mycs</a></h4><p>mycs是一家德国柏林的家具公司，其站点上有很多家具可视化的展示以及定制操作，感觉像是一家规模不大的创业公司。这家公司是我唯一面完所有流程而挂掉的公司（其他一般都是第二轮挂了），所以还是有很多东西可说的。</p>
<p>首先是他们的流程，没有HR面，就是两轮技术面+做一个小项目。这家公司是唯一问我类似“井盖为啥是圆的”这种开放式问题的公司，他们的问题是“你住上海是吧，上海有多少个公交车站，你能估算一下吗？”。由于口音问题，”bus stop”这个词我听了几遍没听懂，幸好我俩共享了屏幕，他就直接打出来了。听到这问题当时我就懵逼了，还带这样事的，当时我给的方案是：假设上海有200条公交线路，70%在市区，30%在郊区，市区平均有15个站，郊区平均20个站，市区比较繁华，不同线路公用30%的公交站，郊区公用10%。就这么算出了一个数字给他，当然里面的假设全是我瞎扯的。后来对方查了下维基百科还是啥的，发现我算的数字不对（那肯定了。。。），然后俩人讨论了下没算对的原因，里面的各种假设需要怎么调整等等，整个过程还是挺有意思的。接下来就是共享屏幕敲代码做题了，我俩用的jsfiddle，我记得做了两道题：</p>
<ol>
<li>两个数组，元素是单个字母，如<code>[a, b, c]</code>和<code>[e, f, t]</code>，列举出两数组各取一个元素组合出的所有字符串的集合，并剔除重复项。</li>
<li>for循环里放一个setTimeout，怎么把循环变量传到setTimeout的callback里去。</li>
</ol>
<p>题目不难，做完后围绕第一题聊了下performance问题，如何减少循环次数，如何去重快一点等等。我当时只想到可以每个数组自己先去重再进行合并。。。后面又问了一些angular的问题本轮面试就结束了，马上就约了第二轮的面试。第二轮面试是个法国人，dev manager，第一次体会到法国人的懒散，约好的面试时间迟到了将近20分钟。。。第二轮感觉涉及前端的比较少，问了下什么情况下选用什么框架的问题，问了下以前的一个项目的前后端整体架构结构，然后问了些排序以及复杂度，比如“如何理解快排的复杂度”，最后问了一些后端的东西，具体的问题我也没啥印象了，只记得答得不太好。第二轮由于对方迟到面的时间不长，对方说下一轮是做题了，会给6到8小时做一个项目。约好了周末发给我做，结果这法国哥们太懒散，两周后才发给我，说是忘记了，而且还不是周末发的。。。这个项目也挺有意思的，对方直接在Github上把我加到一个私有项目里，这个项目是一个Tic-Tac-Toe的游戏（就是小时候玩的画个井字，一人画叉，一人画圈，谁先连成3个谁获胜），项目里只带了一个基于express的API定义以及一个单元测试，目标是让你完成API里调用的开局、下棋逻辑，保证测试通过并完善测试提高覆盖率，然后实现一个前端页面调用这个API保证游戏可以玩。这个考察的东西就很多了，我觉得是一个非常有意思的面试题，典型的TDD啊。做完以后发个pull request，对方直接给review意见，然后再根据review修改提交。整个项目我唯一没完成的是电脑逻辑如何决定下一步棋画在哪个格子里，当时时间原因直接写了个简单逻辑：画在第一个空格子里。项目做完以后过了几天就收到反馈：被拒，原因是感觉我前端挺好的，但这个职位需要的后端知识没有其他几个候选人强。不过我最后也释然了：反正所有打着前端工程师的幌子招全栈工程师的都是耍流氓！</p>
<h4 id="Zalando"><a href="#Zalando" class="headerlink" title="Zalando"></a><a href="http://www.zalando.com/" target="_blank" rel="external">Zalando</a></h4><p>Zalando是总部位于德国柏林的一家时尚电商，在欧洲十几个国家都有业务，感觉像欧洲的唯品会。这家的面试流程中规中矩：算法题、HR面、技术面。算法题有三道，有两个多小时，时间非常充裕。有一道我记不清了，其他两道是：</p>
<ul>
<li>一道是计算停车场收费，涉及简单的时间计算和分段计价。没啥难度，边界条件考虑好，细心就好。</li>
<li>另一道比较有意思，给一个HTML页面，里面可能有嵌套列表，如ul包含ul/ol，或ol包含ul/ol。题目就是给定一个HTML页面，计算出最大的嵌套深度。递归即可搞定。</li>
</ul>
<p>这家的算法题网站比较不同的就是“提交后立即显示结果”，所以做完后我就发现有一题我边界条件没考虑好，没拿满分。提交后过了几天就收到约第二轮面试，不过约了两周后我也是醉了。。。</p>
<p>第二轮就是HR面了，除了常见的问题以外，这家的behavioral interview类的问题问了特别多，我记得有：</p>
<ul>
<li>遇到过什么挑战，如何解决？</li>
<li>同事们最喜欢你哪些地方？</li>
<li>同事们觉得你有哪些不好的地方？你是如何解决的？</li>
<li>同事的哪些行为最让你不爽？你是怎么应对的？</li>
<li>如果你需要指出同事的缺点，你一般会怎么做？</li>
</ul>
<p>当然，behavioral interview的问题有一些技巧，但我觉得还是以自己的经历出发实事求是，针对每个问题能举一些自己身上的例子比较好。没什么答案是绝对的好与不好的，关键看自己咋表达了吧。最后HR还跟我聊到了亚洲人性格偏腼腆，不会直接表达等等。。。完事以后就约了下一轮面试了，也是终面：三个小时三个人技术面。</p>
<p>这家的技术面我觉得是最到位的，三个人分工不同，很有层次感。第一个人主要是聊了下前面算法题我做错的那道，我俩直接共享屏幕敲代码，对方把我错的代码复制过来，让我重新做。由于前面已经知道自己没考虑边界，一下就做出来了。针对这个题的代码，我们又聊了编码习惯，一个是我的变量命名不太直观，另一个因为我习惯字符串转数字用<code>+</code>号搞定。对方谈到写代码还是以可读性为主，我也举了几个例子表示赞同。后来对方又贴了一道题让我现在做，主要就是用原生js模拟jQeury的一些函数及链式调用，难度不大。休息了几分钟后第二轮就来了，感觉偏前后端整体架构。对方说了一个场景，需要开发一个留言审核系统，让我尽可能详尽的说说如何设计开发，包括前端页面布局、API设计、DB表设计，如何避免多人操作同一个留言等等。期间我还主动聊起来自动化测试的话题，说自己喜欢TravisCI，然后共同语言来了，噼里啪啦浪费了几分钟面试时间。又休息了几分钟第三轮就来了，看我的简历用过两年angular，玩命问angular的问题，比如“双向邦定如何实现的”，“ng-if和ng-hide区别”，“如何优化长列表的渲染”，“track by为何能加快渲染速度”等等，完了以后也聊了一会测试及自动化部署的问题。比较有意思的是，还剩十分钟的时候对方问我“你有问题吗？没有的话我再问你几个问题。。。”，我当然立马回答“有”啦！^_^ 最终又过了两周HR通知拿到offer了。</p>
<h4 id="Atlassian"><a href="#Atlassian" class="headerlink" title="Atlassian"></a><a href="https://www.atlassian.com/" target="_blank" rel="external">Atlassian</a></h4><p>Atlassian是总部位于澳大利亚悉尼的软件公司，可能很多人听名字比较生，但他家的产品是个程序都用过：JIRA, Confluence, SourceTree, Bitbucket，可以说是一家程序员非常向往的公司。这家的流程也是：算法题、HR面、技术面，我只走到了HR面，说实话我至今没搞明白这家为啥拒了我。</p>
<p>这家的算法题是我面过这么多家里最难的，90分钟做5道题，分值不同难度也不同，不需要全部做完。时间关系我只做了4道，做完第4道时已经只剩5分钟了，我看了下第5题的题目确定自己半小时也做不完就直接放弃了。5道题我已经记不大清了，只说说我有印象的：</p>
<ul>
<li>有一道题，是自己定义了一种进制算法，让把一些输入的字符串按规则进行进制转换。参考二进制计算规则即可。</li>
<li>还有一道题，控制一个吊车扔方块到一个棋盘里，车上有方块，定义了一堆命令如移动、下落等等，然后给定一串命令，打印出该串命令控制吊车后在棋盘拼出的图案代表的十六进制（？，记不清了，不确定）</li>
<li>最后一道题，文本处理，给了一堆联系人信息，按指定规则提取。</li>
</ul>
<p>没想到我虽然只对了4道题，对方依然给了HR面的机会。HR面就让介绍了下以往经历，我就记得我吧嗒吧嗒说一堆，然后HR一直”it’s awesome”，谁知道过了一周直接一封拒信，我回信问原因也没理我。。。后来想想，可能跟我司以前招人理念差不多吧：这孩子还不错，就是没啥亮点。。。</p>
<h4 id="GetYourGuide"><a href="#GetYourGuide" class="headerlink" title="GetYourGuide"></a><a href="https://www.getyourguide.com/" target="_blank" rel="external">GetYourGuide</a></h4><p>GetYourGuide是一家总部位于德国柏林的旅游预定网站。这家公司我本来非常感兴趣的，看公司的技术博客感觉氛围相当好，很喜欢组织技术分享，是柏林当地多个技术型meetup的组织方，但面下来这家给我的体验非常不好。先是约了面试时间留了Skype，对方给了一个网站输入自己的availablity（可以面试的时间），我选了一个时间提交后对方一直没反应，直到这个时间过了一天以后对方回邮件说我选的时间不在9AM-6PM之间。。。我当时就有点无语，没关系那我再选一个时间吧，我就告诉他我每天的某个时间段都是OK的。这次对方回了个邮件，安排了面试，但面试时间压根不在我给的时间区间里。。。我又回邮件说那个时间段我不行，重新安排吧，对方答应了我的新时间。氮素！我在约定时间等了10几分钟没人加我Skype，然后就给对方发邮件问咋回事，一直到一个多小时后对方才回邮件说没法联系到我，关键是这一个小时我Skype一直在线啊。。。最后只好又约了下周新面试时间。万万没想到，过几天我收到一封邮件，里面堂而皇之的说“我们的技术人员和你聊过了，很高兴你花时间介绍你的经历，但我们觉得你不太合适这个职位”，尼玛，从头到尾没人面试过我啊。。。我当时真火了，立马回邮件骂了回去“我困惑了，没人面过我，你们的面试流程太不专业，太有问题了，这不公平”。对方答应了重新安排面试，经过这一番周旋，可算得到了面试机会。</p>
<p>第一轮是HR面，是个英国人，随便聊了下经历，聊得还挺开心的，介绍了下后面的流程：做项目、技术面、CEO/CTO面。对方给的项目也很有意思，GetYourGuide有一个公共API，随机返回当前某个用户正在其网站浏览的旅游景点信息，包括用户名、景点名、经纬度信息，要求是做一个页面，将这些信息反映在地图上。一个不是很复杂的项目，我直接用了谷歌地图的SDK，setInterval请求API拿到信息，将这些信息以卡片加锚点的形式显示在地图上。代码提交以后，好几天没啥反应，后面偶然登了下Skype，发现HR在Skype上给我留言：拒了，原因是技术觉得我做的项目用户体验不好，卡片弹出太频繁。。。当时我就有点不爽，首先，拒掉候选人不发邮件居然用Skype。。。另外，卡片弹出太频繁这种不算是这个项目的重点吧，当然也可能是人家要求太高了。。。反正这家整个流程下来让我感觉不爽。</p>
<h4 id="IRESS"><a href="#IRESS" class="headerlink" title="IRESS"></a><a href="https://www.iress.com/global" target="_blank" rel="external">IRESS</a></h4><p>IRESS是一家总部位于澳大利亚墨尔本的财务咨询公司，我面的是悉尼的职位。流程同样是：算法题、两轮技术面、HR面。算法题的题目我已经完全没印象了，只记得是120分钟3道题，时间很充裕，难度也适中。对方的反馈非常快，提交了代码没过几天就安排下轮面试，两个技术人员电话面，问了些JS的一些基础问题、ES6、angular和react的渲染机制等等，结束后就立马安排了下一轮，说下一轮可能会涉及算法相关。第二轮同样是这两个人面，上来就问了一个问题：</p>
<blockquote>
<p>你走进一个房间，里面有一堆螺丝和螺母，大小不一，怎样迅速让螺丝和螺母一一配对？</p>
</blockquote>
<p>我本来还以为又是一个开放问题，想了半天也没找到方案，只能答说最笨的方法就是随便挑一个螺丝，然后一个一个螺母找呗。结果对方说如果从编程的角度来考虑有什么办法呢？我突然想到了二分查找法，随便找一个螺母，拿螺丝一个个试，比这个螺母小的螺丝放一堆，大的放另一堆，直到找到匹配的为止。这是第一轮循环，第二轮再随便找一个螺母，和第一轮的对比，比第一轮大就从大的一堆里找，小的话则从小堆里找。确定了堆以后，继续使用这种方法继续分堆，如此反复继续找下去。对方说，那就分析下这样的复杂度吗？我一听明白了，这有点类似“二叉搜索树”啊，用二叉树就能分析它的时间复杂度。于是就跟着这个讨论讲下去，分析最好与最差的情况。期间也饶了一些弯子，对方也会给一些提示，就这么磕磕巴巴的下来了。后来对方还问了一些关于前端安全的问题，XSS、CSRF等等，我直接举了一些例子讲了讲就算过去了。由于澳洲比国内块三小时，面试都是早上进行的，中午HR就打电话过来，说技术面反馈很positive，又随便问了一些HR问题，当天下午就给offer了。</p>
<h4 id="Facebook"><a href="#Facebook" class="headerlink" title="Facebook"></a><a href="https://www.facebook.com/" target="_blank" rel="external">Facebook</a></h4><p>Facebook不用介绍了，我面的是伦敦的职位。有意思的我虽然投过Facebook但一直没反馈，HR说是在LinkedIn上看到我的。。。面试流程跟Booking很像：HR面、一到两轮技术面、onsite技术面。大厂果然都是这风范，最后一轮都是旅游面。第一轮面试都是随便聊聊经历，花了很长时间给我介绍了伦敦主要负责的广告业务，让我问了几个问题。最后问了一些js的基础问题：如apply/call区别，如何模拟堆和栈的操作，介绍下数组和对象等等，都是比较简单的问题。我心说这大厂HR都懂这些啊，上LinkedIn一查这个recruiter，尼玛UC伯克利毕业。。。第一轮结束当场就约了下一轮面试，电话技术面，需要共享屏幕做题。第二轮是个做安卓的面的，我也感到很神奇。。。对方先是让做了一个简单的HTML/CSS设计：一张图片上放一个按钮，鼠标移上去就显示按钮，移走就隐藏。我就直接写CSS代码给他，然后他又加限制条件让做一些简单变化。完事以后就是js问题了：拍平一个嵌套数组，也是非常常见的递归，我直接写代码完成了。完事以后就围绕这个递归开始讨论，有什么性能瓶颈等等。我就在那一直讲整体的复杂度跟嵌套深度、数组长度有关等等，感觉没扯清楚，最后对方直接说，递归会导致call stack太深，导致性能问题。然后又加了限制说，不用递归怎么解。。。我想了半天没方案，最后对方给了点提示，试试一直调用concat看看，在他的提示下我也磨磨唧唧的写了出来答案。不过当时就感觉对方不太满意，随后让我问几个问题，我就问了下我常问的“开发者的一天”啊，“平时是否重视单元测试和集成测试”等等，第二轮就这么结束了。</p>
<p>虽然是伦敦的职位，但面试都是美国那边进行的，而技术面只能在10AM以后进行，也就是国内时间半夜两点，所以美国的时差跟我们还是很尴尬的，要么半夜面，要么早上七八点面，作为夜猫子的我选了半夜。。。第二轮面完后也就三点多了，一觉醒来就收到邮件说拒了。想想可能对方觉得“这种问题还需要提示，磕磕巴巴做半天，这孩子还是算了吧”。。。</p>
<h3 id="面试小tip"><a href="#面试小tip" class="headerlink" title="面试小tip"></a>面试小tip</h3><p>这里讲讲我自己总结的面试流程里要注意的其他一些点。</p>
<ul>
<li>“共享屏幕敲代码”注意点啥？很多HR在约面试的时候就会在邮件里提醒你，我这里也总结几个点：<ul>
<li><code>think out loud</code>。这句意思就是说，拿到题以后别坐那一直想，啥话也不说。有想法就立刻说出来，即便想到解决方法也不要一上去就写代码，先把自己打算的解决方案和对方讲一讲。一是保持交流对方不至于干坐着，另一个是有时候很可能由于紧张，虽然知道怎么解决但代码没写好，这个时候由于你先前就讲过解决方案，面试官也会沿着你的思路给你相应提示。</li>
<li>从<code>brute force</code>开始。brute force意思是暴力方案，比如说一道题我想不到更好方案，只会玩命循环，性能很差。没关系，先写出来，然后以这个为基础继续迭代，实在无法进行下去就寻求面试官提示。因为很多时候对方看中的是你一步一步分析问题寻求解答的过程。</li>
<li>注意边界条件，这个算法题部分也提到过。</li>
</ul>
</li>
<li>做项目注意点啥？就我自己来说，我做的两个项目都没有使用类MVC框架，因为考虑到时间限制的问题。当然，时间允许的话用angular/react也是OK的，但是类似的框架都需要花费一些时间在项目配置上。我基本都是jQuery直接做的，虽然可能很多人看不上，但我觉得如果能用jQuery把项目结构、分层搞得很清晰的话，也会是一个亮点啊。这里安利一篇我好久以前写的文章：<a href="/2013/12/18/rock-your-web-page-in-bakcbone-way/">用Backbone的思想写web页面
</a>，我都是用文章里介绍的结构来做项目的。</li>
<li>面试时听不懂咋整？这个问题应该很常见吧，我本人来说，英音基本无力，欧洲其他各地的口音我也不是全能catch住。这个问题的解决很简单：听不懂就问！讲讲我的几个真实例子。<ul>
<li>跟柏林HR面的时候问我“工作中最让你frustrated（沮丧）的事是啥？”，奈何这个词我死活没听懂。我就直接问“frustrate”这个词啥意思，对方很友好的跟我说“upset, not happy”的意思。还是同一个人，有次挂电话时说“it was nice talking to you”，不知道语调问题还是咋的，我sorry了三遍，对方说到第四遍我才懂，尴尬的回了句“me too”。</li>
<li>有的时候觉得尴尬，可以说“Your voice is breaking up. The network is not stable. I didn’t hear you.”来打幌子，反正都是电话或网络，信号本来就不好，就说没听清让对方重复下呗。</li>
<li>还可以用这种方法，如果听不懂就把自己听到的意思整理一下，向对方确认“did you mean that xxx”，如果对方发现你理解的不对，自然会换种说法重新表达。</li>
</ul>
</li>
<li>对方问工资应该怎么谈？这个问题确实比较复杂，一个陌生地方，消费水平和工资水平都无法得知。这里我推荐几个有用的网站：<ul>
<li><a href="http://www.payscale.com/" target="_blank" rel="external">PayScale</a>：有各个地区的各个职业的工资水平，可以限定年限、工种甚至公司，非常全，可以参考。</li>
<li><a href="https://www.glassdoor.com/index.htm" target="_blank" rel="external">GlassDoor</a>：前面提到的GlassDoor是有工资评价的，都是各个公司的职位工资，参考价值比较大。</li>
<li><a href="https://www.numbeo.com/cost-of-living/" target="_blank" rel="external">NUMBEO</a>：这个网站有各个城市的消费水平统计，每个城市有一个1-100的指数，以纽约为参考（即纽约全球消费水平最高，为100），通过这个指数你可以对这个城市的消费有一个基本的认识。另外，网站含有大量统计数据，小到牛奶蔬菜价格，大到租房买房价格都有，非常具有参考性。这个网站还有对比功能，选两个城市，会告诉你各种价格对比，然后会估算一个值：比如在上海拿到xxx工资的话，在柏林拿到多少工资才能保证生活质量不下降。这个值非常有用！</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之，整个流程下来，我觉得找海外工作并没有想象中那么难，当然也可能是大公司我都没走到后面的流程。。。但我想说的是，有想法就行动，光想着出国什么也不干，那啥用也没有。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从去年10月开始投简历到今年1月为止，这三个多月的时间我断断续续面了五六家海外的公司，主要集中在欧洲和澳洲，面的都是前端开发的职位。这里就介绍下整个面试经历，希望对有同样想法的同学有所帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="移民" scheme="http://pinkyjie.com/categories/%E7%A7%BB%E6%B0%91/"/>
    
    
      <category term="海外面试" scheme="http://pinkyjie.com/tags/%E6%B5%B7%E5%A4%96%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>webpack使用小记</title>
    <link href="http://pinkyjie.com/2016/03/05/webpack-tips/"/>
    <id>http://pinkyjie.com/2016/03/05/webpack-tips/</id>
    <published>2016-03-05T07:29:17.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果前两年大家还在讨论grunt和gulp等构建工具的话，现在无疑是<a href="https://webpack.github.io/" target="_blank" rel="external">webapck</a>的时代。严格来讲，webpack其实和grunt/gulp根本不是一种东西，它不是一个构建工具，而是<code>module bundler</code>。简单来说，webpack将JS、CSS、HTML（包含各种预处理器）以及图片等等都视为“资源”，每个资源文件都是一个module文件，而module文件之间存在依赖，webpack就是根据module文件间的依赖将所有module打包（bundle）起来。而回忆我们用grunt/gulp构建项目时，做的很大一部分工作也无非是将JS、CSS、HTML编译合并压缩等等，所以从这个层面上讲用webpack和grunt/gulp得到的结果是一样的。但webpack好就好在使用loader的概念让配置更加容易，再也不用和一堆文件路径打交道了。这篇文章就讲一下自己在使用webpack时的一些实践。</p>
<a id="more"></a>
<h3 id="使用npm管理所有依赖"><a href="#使用npm管理所有依赖" class="headerlink" title="使用npm管理所有依赖"></a>使用npm管理所有依赖</h3><p>说到前端的依赖管理，可能很多人脑海里第一印象还是<a href="http://bower.io/" target="_blank" rel="external">bower</a>，其实bower更像是一个依赖下载工具，你还是需要手动将这些下载好的文件用script标签引用到页面中去（尽管有<a href="https://github.com/tanodeptapship/wiredep" target="_blank" rel="external">wiredep</a>帮我们自动化），所以它其实并不能真正的做到“依赖管理”。另外，bower据说已经要停止开发了，与此同时，越来越多的前端项目都开始支持npm，支持使用node的CommonJS机制来发行它们的前端库。这样在前端项目的package.json中不仅需要<code>devDependencies</code>，长期受冷落的<code>dependencies</code>也要用起来了。前者用来声明一些build过程中需要用的到一些构建工具，而后者用来声明开发使用到的前端库。webpack虽然支持多种包管理机制，但CommonJS应该还是最推荐的吧。用npm将要使用的库安装好后，直接在js文件中require即可。当然，使用ES6的话（需配合Babel），import它也是支持的哦。这样一来，第三方库的管理，项目中文件间的依赖管理再也不是问题了，可以像写node以及其他后端语言那样畅快的引用来引用去了。</p>
<p>说到依赖管理，还有个问题不得不提。package.json文件中采用node的SemVer来管理版本号，默认的<code>^</code>符号会匹配最新的minor版本。简单的说，你安装的时候可能是<code>^1.4.3</code>，但是一旦1.5.0发布，你运行npm install就会装1.5.0，也就是说它只会保留第一个数字。所以有需要的话可以把<code>^</code>改为<code>~</code>，它的限制更严格一些，<code>~1.4.3</code>最多只会安装到1.4.9，可以最大程度的减少升级带来的兼容性问题。有人会想，有没有类似python的<code>pip freeze</code>功能把依赖锁死在指定的版本上呢？当然！试试<code>npm shrinkwrap</code>吧，它会将当前安装在node_modules下的依赖版本写死在生成的node-shrinkwrap.json文件中，将这个文件加到git里，别人使用npm install安装依赖包时就可以保证装到和你一模一样的版本了。</p>
<h3 id="善用yargs，避免多个配置文件"><a href="#善用yargs，避免多个配置文件" class="headerlink" title="善用yargs，避免多个配置文件"></a>善用yargs，避免多个配置文件</h3><p>很多github上的webpack starter项目都提供了多个webpack.config.js：如<code>webpack.prod.config.js</code>和<code>webpack.dev.config.js</code>，目的就是为了适配不同的环境。其实开发和发布的配置大部分是相同的，所以里面会有很多重复的配置。还有的项目看到了这一点，来了一个<code>webpack.make.config.js</code>提供默认的大部分配置，然后在其他的配置文件里require这个文件，做相应的更改。反正都是提供多个webpack配置文件，然后不同的环境用不同的。有必要这么复杂吗？在前面的文章中我反复提到一个概念，虽然<code>xxx.config.js</code>是配置文件，但是里面可以包含任何的node逻辑，所以为什么不试试只维护一个配置文件，针对不同的环境传不同的参数呢？像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"start"</span>: <span class="string">"webpack-dev-server --mock"</span>,</div><div class="line">    <span class="string">"build"</span>: <span class="string">"rm -rf ./build &amp;&amp; webpack --progress --mock --prod"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认会查找名为<code>webpack.config.js</code>的配置文件，然后在这个文件中我们去处理自定义的参数即可。这里又要安利<a href="https://www.npmjs.com/package/yargs" target="_blank" rel="external">yargs</a>了，一个非常便捷的命令行参数处理工具。具体可以参考<a href="/2016/02/27/continuous-integration-with-travis-ci/#识别Travis的环境">前面文章</a>的讲解和它的文档，这里不再赘述。</p>
<h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><p>webpack的配置可以说就是<code>module</code>和<code>plugins</code>的配置，<code>module</code>里主要就是配置各种loaders，没啥可说的，你要require什么类型的文件就去搜相应的loader就好，这一节主要说后面的这个：<code>plugins</code>的配置。webpack支持非常多的插件，详见<a href="http://webpack.github.io/docs/list-of-plugins.html" target="_blank" rel="external">插件列表</a>，下面就讲一些常用的场景会用到的插件。</p>
<h4 id="将jQuery全局暴露"><a href="#将jQuery全局暴露" class="headerlink" title="将jQuery全局暴露"></a>将jQuery全局暴露</h4><p>虽然很多人已经不提倡再使用jQuery，但很多第三方的库依然依赖jQuery，如果我们要使用这些第三方的库，那么我们还是没法摆脱jQuery。那么正常情况下我们只要保证jQuery的script标签在第三方库前面即可，因为jQuery中会暴露<code>$</code>给全局（<code>window.$</code>）使用。但使用了webpack后情况就稍显复杂了，作为module bundler，默认是不会有任何module暴露给全局的。这样，如果第三方库的代码中出现<code>$.xxx</code>或<code>jQuery.xxx</code>或<code>window.jQuery</code>或<code>window.$</code>则会直接报错。要达到类似的效果，则需要使用webpack内置的ProvidePlugin插件，配置很简单，只需要：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</div><div class="line">    <span class="attr">$</span>: <span class="string">"jquery"</span>,</div><div class="line">    <span class="attr">jQuery</span>: <span class="string">"jquery"</span>,</div><div class="line">    <span class="string">"window.jQuery"</span>: <span class="string">"jquery"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这样，当webpack碰到require的第三方库中出现全局的<code>$</code>、<code>jQeury</code>和<code>window.jQuery</code>时，就会使用node_module下jquery包export出来的东西了。</p>
<h4 id="给JS定义全局flag"><a href="#给JS定义全局flag" class="headerlink" title="给JS定义全局flag"></a>给JS定义全局flag</h4><p>在JS代码中我们常常需要一些静态的flag来标识是开发环境还是生产环境，一个简单的例子就是，开发环境你的log可能是直接console里打出来就好，而生产环境中就需要将log上传到统一的地方方便查询。也就是说，有些代码可能只是为了生产环境而存在的，而有些代码只为开发环境存在。我在为生产环境编译打包的时候就需要移除这些没用的代码，移除的操作<a href="https://github.com/mishoo/UglifyJS2" target="_blank" rel="external">UglifyJS</a>可以胜任，但前提是它只移除类似<code>if (false) {...}</code>的代码片段，所以我们要做的就是定义全局的布尔flag，在build的时候传入不同的参数来控制它是true还是false。这时就需要使用webpack内置的DefinePlugin插件了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// args = require('yargs').argv;</span></div><div class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">    <span class="attr">__PROD__</span>: args.prod，</div><div class="line">    __MOCK__: args.mock</div><div class="line">&#125;),</div></pre></td></tr></table></figure>
<p>上面我们同样使用了yargs，这样在build时传入<code>--prod</code>，则变量<code>__PROD__</code>即为true，传入<code>--mock</code>则<code>__MOCK__</code>为true。在JS代码中就可以使用类似的判断<code>if (__PROD__) {...}</code>了。</p>
<h4 id="第三方库输出单独的JS"><a href="#第三方库输出单独的JS" class="headerlink" title="第三方库输出单独的JS"></a>第三方库输出单独的JS</h4><p>一般我们为生产环境打包JS时，不管源文件有多少个，一般都是输出两个最终文件：<code>app.js</code>和<code>vendor.js</code>（LazyLoad的情况另说），前者是我们自己编写的代码合并压缩而成，后者是我们使用的第三方库合并压缩后的结果。使用webpack实现这个需要也很简单，使用webpack内置的CommonsChunkPlugin即可，我们要做的就是两步：</p>
<ul>
<li>在entry中定义app和vendor这两个模块：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">entry: &#123;</div><div class="line">    <span class="attr">app</span>: [</div><div class="line">        <span class="string">'source/app/index.js'</span></div><div class="line">    ],</div><div class="line">    <span class="attr">vendor</span>: [</div><div class="line">        <span class="string">'angular'</span>,</div><div class="line">        <span class="string">'angular-ui-router'</span>,</div><div class="line">        <span class="string">'angular-animate'</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在plugins里使用该插件：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">'vendor'</span>, isProd ? <span class="string">'vendor.[hash].js'</span> : <span class="string">'vendor.js'</span>)</div></pre></td></tr></table></figure>
<p>这样，所有模块中只要有require到vendor数组中定义的这些第三方模块，那么这些第三方模块都会被统一提取出来，放入<code>vendor.js</code>中去。在插件的配置中我们还进行了判断，如果是生产环境则给最终生成的文件名加hash。</p>
<h4 id="将CSS由style内嵌变成独立-css文件"><a href="#将CSS由style内嵌变成独立-css文件" class="headerlink" title="将CSS由style内嵌变成独立.css文件"></a>将CSS由style内嵌变成独立.css文件</h4><p>在处理CSS时webpack需要两个不同的loader：<code>css-loader</code>和<code>style-loader</code>，前者负责将CSS文件变成文本返回，并处理其中的url()和@import()，而后者将CSS以style标签的形式插入到页面中去。一般使用的时候这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</div><div class="line">    <span class="attr">loader</span>: <span class="string">'style!css?sourceMap!autoprefixer!stylus'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的loader配置中，我们处理所有的styl文件（stylus），先用stylus-loader将stylus变成CSS，然后使用autoprefixer-loader添加各种浏览器兼容性前缀，最后使用css-loader和style-loader。但这样的问题就是所有CSS文件都是直接以style标签的形式插入页面，不利于缓存，我们还是更习惯build之后能够输出单独的.css文件。这时就需要webpack的<a href="https://github.com/webpack/extract-text-webpack-plugin" target="_blank" rel="external">extract-text-webpack-plugin</a>插件了，注意它不是内置的，需要额外安装。它的使用也很简单，分两步：</p>
<ul>
<li>在loaders定义中指定：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</div><div class="line">    <span class="attr">loader</span>: ExtractTextPlugin.extract(<span class="string">'style'</span>, <span class="string">'css?sourceMap!autoprefixer!stylus'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在plugins中使用插件：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">"extract-text-webpack-plugin"</span>);</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">new</span> ExtractTextPlugin(isProd ? <span class="string">'[name].[hash].css'</span> : <span class="string">'[name].css'</span>)</div></pre></td></tr></table></figure>
<p>同样，这里我们在生产环境使用了hash命名。</p>
<h4 id="copy指定文件到指定路径"><a href="#copy指定文件到指定路径" class="headerlink" title="copy指定文件到指定路径"></a>copy指定文件到指定路径</h4><p>按理说用了webpack后所有的模块都通过require来管理了，用不着这样针对某个文件的copy了。这确实是一个不太常见的场景，比如说使用ES6的项目中，即便使用了Babel，但它并不会翻译类似<code>Symbol</code>这样的关键字，造成IE的兼容性问题：IE里会直接报“Symbol not defined”错误。这个时候我们就需要在页面中引入Babel里自带的shim文件了，<code>babel-core</code>中有一个browser-polyfill.min.js文件，是浏览器直接可以include的文件，并不需要使用webpack把它包一层。所以我们要做的其实是build的时候将这个文件copy到指定的目录，然后在index.html中包含这个文件即可。这个时候就需要<a href="https://www.npmjs.com/package/copy-webpack-plugin" target="_blank" rel="external">copy-webpack-plugin</a>这个插件了，配置起来也是非常的简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>);</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">new</span> CopyWebpackPlugin([</div><div class="line">    &#123; <span class="attr">from</span>: <span class="string">'node_modules/babel-core/browser-polyfill.min.js'</span>, <span class="attr">to</span>: <span class="string">'polyfill.js'</span>&#125;</div><div class="line">])</div></pre></td></tr></table></figure>
<p>这样文件就会被复制到webpack的output.path配置的路径下了。</p>
<h4 id="定义入口HTML文件"><a href="#定义入口HTML文件" class="headerlink" title="定义入口HTML文件"></a>定义入口HTML文件</h4><p>单页应用还是需要一个入口的index.html文件的，这个文件的功能就是include所有的JS、CSS文件，然后body里指定一个ng-view或ui-view即可。这么机械化有规律的动作当然有插件来帮我们做了，那就是<a href="https://github.com/ampedandwired/html-webpack-plugin" target="_blank" rel="external">html-webpack-plugin</a>。最简单的配置就是直接在plugins直接定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">new</span> HtmlWebpackPlugin()</div></pre></td></tr></table></figure>
<p>默认的配置会生成一个结构非常简单的index.html文件，HTML的title是“Webpack App”，然后entry中定义的bundle生成的JS会以script标签包在body里，CSS会以link标签包在head里。显然，默认的模板是没法满足我们的需求的，我们需要给插件传入参数进行配置：</p>
<ul>
<li>title和filename：控制生成页面的title和文件名。</li>
<li>inject：控制JS插入的位置，body或者head。</li>
<li>favicon：可以指定一个favicon.ico文件路径，作为网站的图标。</li>
<li>chunks和excludeChunks：一个数组，包含你需要引入或排除的bundle的名字（定义在entry中）。</li>
<li>template：自定义模板。</li>
</ul>
<p>这里我们重点来说一说template这个配置，因为Angular的场景是在body里需要一个ui-view的，所以我们必须要自定义模板。template不仅支持直接传入HTML文件的路径，也支持各种模板语言，来看看这个定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">    <span class="attr">template</span>: <span class="string">'jade!./source/app/index.jade'</span>,</div><div class="line">    <span class="attr">chunks</span>: [<span class="string">'app'</span>, <span class="string">'vendor'</span>],</div><div class="line">    <span class="attr">favicon</span>: <span class="string">'favicon.ico'</span>,</div><div class="line">    <span class="attr">appName</span>: appName</div><div class="line">&#125;),</div></pre></td></tr></table></figure>
<p>在template中我们指定了jade模板文件，然后配上jade-loader。这里注意的是，如果你想向jade文件中传参数，类似<code>jade?foo=bar!xxx.jade</code>，貌似是不支持的。那怎么实现这个需求呢？比如我想让build的时候动态决定index.html中的ng-app名字，怎么办呢？上面的<code>appName: appName</code>就是答案。在传给插件的配置中，除了它自身支持的配置，我们可以传入任意名称的键值对，然后在jade文件中可以这样访问到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">html(lang=&quot;en&quot;, ng-app= htmlWebpackPlugin.options.appName)</div></pre></td></tr></table></figure>
<p>除了<code>htmlWebpackPlugin</code>变量外，在自定义模板中，还可以访问<code>webpack</code>和<code>webpackConfig</code>，前者可以获取webpack的stats，如<code>webpack.hash</code>获取本次webpack编译得到的hash码，后者可以获取webpack的所有配置。这两个变量在一些场景下也是非常有用的。最后还是一点要说，html-webpack-plugin支持生成多个HTML文件，只要在plugins中定义多个<code>new htmlWebpackPlugin({...})</code>即可。</p>
<h4 id="p参数的坑"><a href="#p参数的坑" class="headerlink" title="-p参数的坑"></a><code>-p</code>参数的坑</h4><p><code>-p</code>参数是官方推荐的Production shortcut，意思就是为生产环境build时请使用<code>webpack -p</code>，那么<code>-p</code>指什么？文档里说了，代表<code>--optimize-minimize</code>和<code>--optimize-occurence-order</code>这两个命令行参数。先来说说第二个，在<a href="http://webpack.github.io/docs/list-of-plugins.html#occurrenceorderplugin" target="_blank" rel="external">文档</a>里解释了，webpack会把所有的chunk当做资源进行编号，这个插件可以保证出现次数多的资源编号小一些，短一点，这样有助于减小最终的文件大小。再来看看第一个<code>--optimize-minimize</code>，在webpack的<a href="http://webpack.github.io/docs/list-of-plugins.html" target="_blank" rel="external">插件列表文档</a>中没有找到。没关系，我们直接搜源码，可以发现，在<code>webpack/bin/convert-argv.js</code>（1.12.14版本）中有这么一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ifBooleanArg(<span class="string">"optimize-minimize"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ensureArray(options, <span class="string">"plugins"</span>);</div><div class="line">    <span class="keyword">var</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">"../lib/optimize/UglifyJsPlugin"</span>);</div><div class="line">    options.plugins.push(<span class="keyword">new</span> UglifyJsPlugin());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>也就是说，这个参数实际上会加载UglifyJsPlugin这个插件，而且是无参（默认参数）加载的。这里坑就来了！如果你的ES6代码中出现类似这样的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> MockData <span class="keyword">from</span> <span class="string">'./e2e.data'</span>;</div><div class="line">angular.module(<span class="string">'appTest'</span>, [])</div><div class="line">    .service(MockData.name, MockData)</div><div class="line"></div><div class="line"><span class="comment">// e2e.data.js</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockData</span> </span>&#123;...&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> MockData;</div></pre></td></tr></table></figure>
<p>也就是说，使用module的<code>.name</code>属性来决定一个service的名字，然后在别的地方使用依赖注入来引入这个service的话，这个时候一旦你使用<code>-p</code>参数，程序就会报错：找不到provider，<code>MockDataProvider &lt;- MockData</code>。因为在e2e.data.js文件中你export的class虽然叫MockData，但这个名字会被UglifyJsPlugin改掉。这是因为这个插件有一个<code>mangle</code>选项，会对所有函数名变量名进行混淆，在压缩的同时保证安全。这倒没什么，坑就坑在，webpack自己的文档中告诉大家这个mangle的option默认是flase的，也就是说不会混淆。但在UglifyJsPlugin插件的源码里明明写着<code>if(options.mangle !== false) {...}</code>，除非你传入一个flase，默认确实是会混淆的。你说这误导不误导，我在Github上提了个issue：<a href="https://github.com/webpack/docs/issues/49" target="_blank" rel="external">webpack/docs #49</a>，虽然官方没管，但最新的文档中貌似已经修复了这个错误。所以我的建议是：<strong>不要使用<code>-p</code>参数</strong>！想要什么自己定义就好：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (isProd) &#123;</div><div class="line">    plugins.push(</div><div class="line">        <span class="keyword">new</span> webpack.NoErrorsPlugin(),</div><div class="line">        <span class="keyword">new</span> webpack.optimize.DedupePlugin(),</div><div class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">            <span class="attr">compress</span>: &#123;</div><div class="line">                <span class="attr">warnings</span>: <span class="literal">false</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">mangle</span>: <span class="literal">false</span></div><div class="line">        &#125;),</div><div class="line">        <span class="keyword">new</span> webpack.optimize.OccurenceOrderPlugin()</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了上面的定义，在build的时候只要使用<code>webpack --prod</code>就好。还有一点值得一说，如果你使用了<code>-p</code>，即便你额外定义了一个自己的mangle=false的UglifyJsPlugin插件在webpack配置里，也是不起作用的。所以，还是那句话，不要使用<code>-p</code>参数。</p>
<h3 id="轻松实现LazyLoad"><a href="#轻松实现LazyLoad" class="headerlink" title="轻松实现LazyLoad"></a>轻松实现LazyLoad</h3><p>使用webpack的<a href="http://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">Code Splitting</a>可以非常方便的实现LazyLoad。对于大型的应用来说，一次性将所有文件全部下载进浏览器显得很不划算，因为有些功能可能不太常用，不需要一开始就加载。Code Splitting功能可以在代码中定义“分割点”，即代码执行到这些点时才会去加载所需的模块，这样就实现了按需加载的LazyLoad。下面就以Angular和ui-router为例来看看具体怎么LazyLoad。假设我们的网站有4个大页面（每个页面里可能有很多子页面），我们希望路由到某个页面时再去加载这个页面所需要的模块。要实现这个LazyLoad，我们要明确两点：</p>
<ol>
<li>“分割点”设在哪？</li>
<li>一个页面需要的模块包括HTML、CSS、JS，具体怎么去加载这三种类型？</li>
</ol>
<p>第一个问题很简单，由于我们的想法是在路由到某个页面时再去加载所需模块，所以很自然的，我们会想把“分割点”放在路由的定义中。放在路由中还可以帮我们解决第二个问题，因为路由中通常需要定义路由到这个页面时的template和controller，这恰恰是我们上面提到的HTML和JS部分。下面我们就来看看具体怎么操作吧。</p>
<h4 id="通过templateProvider动态加载模板"><a href="#通过templateProvider动态加载模板" class="headerlink" title="通过templateProvider动态加载模板"></a>通过templateProvider动态加载模板</h4><p>我们可以在定义路由的时候在template中去动态加载所需的模板，但是template参数是个string，显然不满足我们的要求（templateUrl显然也不适合我们的场景）。这里就需要ui-router的<a href="http://angular-ui.github.io/ui-router/site/#/api/ui.router.state.$stateProvider#methods_state" target="_blank" rel="external">templateProvider参数</a>了，它的值可以是一个函数，然后在这个函数中支持返回一个promise，由这个promise最终来返回HTML字符串。来看看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'root.layout.phone'</span>, &#123;</div><div class="line">    <span class="attr">views</span>: &#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/phone'</span>,</div><div class="line">        <span class="string">'main@root'</span>: &#123;</div><div class="line">            <span class="attr">templateProvider</span>: [<span class="string">'$q'</span>, ($q) =&gt; &#123;</div><div class="line">                <span class="keyword">return</span> $q(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">                    <span class="built_in">require</span>.ensure([], () =&gt; &#123;</div><div class="line">                        resolve(<span class="built_in">require</span>(<span class="string">'./phone.jade'</span>));</div><div class="line">                    &#125;, <span class="string">'phone'</span>);</div><div class="line">                &#125;);</div><div class="line">            &#125;],</div><div class="line">            <span class="attr">controller</span>: <span class="string">'PhoneController as vm'</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的例子中，我们想要在访问<code>/phone</code>这个路由时再去加载<code>phone.jade</code>这个template。来看看templateProvider的配置，首先它的函数返回一个promise（第6行），这个promise我们直接使用<code>$q</code>的构造函数，这个构造函数接受两个参数：<code>resolve</code>和<code>reject</code>，分别用来resolve和reject这个promise。然后在这个promise中我们要resolve的就是<code>phone.jade</code>这个template的字符串内容，使用jade-loader配置后，<code>require(&#39;./phone.jade&#39;)</code>返回的就是jade编译后的HTML字符串了（第8行）。那么什么时候去resolve呢？这里我们重点来看看第7行：webpack的<code>require.ensure</code>函数，我们就是使用这个函数来实现“Code Splitting”的，它有三个参数：</p>
<ol>
<li>依赖的模块数组：模块名组成的数组，webpack会先加载这些模块再执行后面的回调函数。</li>
<li>回调函数：在模块数组加载完以后才会执行这个。</li>
<li>chunk的名字：从这个“分割点”分割出去的模块会放入额外的模块，这个参数指定模块的名字。这个参数主要用于存在多个<code>require.ensure</code>的情况，我们可以将多个“分割点”分割出去的代码放入同一个模块。</li>
</ol>
<p>为什么我们在第7行使用一个空数组呢？其实我们可以写<code>require.ensure([&#39;./phone.jade&#39;], () =&gt; {resolve(require(&#39;./phone.jade&#39;));}, &#39;phone&#39;)</code>，但因为我们在回调里立马又require了这个jade，所以外面不写是无所谓的。</p>
<h4 id="使用resolve来动态加载所需JS"><a href="#使用resolve来动态加载所需JS" class="headerlink" title="使用resolve来动态加载所需JS"></a>使用resolve来动态加载所需JS</h4><p>说完了templateProvider，我们再来看看下面的controller参数，controller参数与平常的写法并没有什么区别（第12行），因为没有一个叫controllerProvider的参数来让我们做类似的事情。那controller的JS模块在哪里动态加载呢？别忘了我们有resolve啊，每个路由定义都可以有一个resolve，只有这个resolve的promise被resolve了（有点绕了。。。）才会真正进入到那个路由中去，所以这正是我们加载controller和phone模块依赖的其它模块的好时机。来看看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">    <span class="attr">loadModule</span>: [<span class="string">'$q'</span>, <span class="string">'$ocLazyLoad'</span>, ($q, $ocLazyLoad) =&gt; &#123;</div><div class="line">        <span class="keyword">return</span> $q(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">            <span class="built_in">require</span>.ensure([], () =&gt; &#123;</div><div class="line">                $ocLazyLoad.load(&#123;<span class="attr">name</span>: <span class="built_in">require</span>(<span class="string">'./index'</span>).name&#125;);</div><div class="line">                resolve();</div><div class="line">            &#125;, <span class="string">'phone'</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们为这个resolve取名loadModule，因为它的作用就是加载phone模块自身的所有JS文件以及它所依赖的其它模块，并不需要我们真正的去return什么，所以第6行我们直接resolve了空值。另外注意第7行我们同样使用了phone作为chunk名，这保证了这个“分割点”分割出去的代码和上面分割出去的template是在一起的。那么JS依赖具体是怎么加载进来的呢？全靠第5行的<code>./index.js</code>文件了，来看看看这个<code>./index.js</code>的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> angular <span class="keyword">from</span> <span class="string">'angular'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> PhoneController <span class="keyword">from</span> <span class="string">'./phone.controller'</span>;</div><div class="line"><span class="keyword">import</span> PhoneAddController <span class="keyword">from</span> <span class="string">'./add/phone-add.controller'</span>;</div><div class="line"><span class="keyword">import</span> PhoneDetailController <span class="keyword">from</span> <span class="string">'./detail/phone-detail.controller'</span>;</div><div class="line"><span class="keyword">import</span> PhoneService <span class="keyword">from</span> <span class="string">'./phone.service'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> phoneForm <span class="keyword">from</span> <span class="string">'../../components/phone-form'</span>;</div><div class="line"><span class="keyword">import</span> phoneTable <span class="keyword">from</span> <span class="string">'../../components/phone-table'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> angular.module(<span class="string">'app.pages.phone'</span>, [</div><div class="line">    phoneForm.name,</div><div class="line">    phoneTable.name</div><div class="line">])</div><div class="line">    .controller(PhoneController.name, PhoneController)</div><div class="line">    .controller(PhoneAddController.name, PhoneAddController)</div><div class="line">    .controller(PhoneDetailController.name, PhoneDetailController)</div><div class="line">    .service(<span class="string">'PhoneAPI'</span>, PhoneService);</div></pre></td></tr></table></figure>
<p>可以看到，这个文件除了将phone模块自身的一些controller/service引入进来，还引入了它所依赖的component模块：phoneForm和phoneTable，所以只要require了它就可以保证phone的所有依赖都引进来了。最后，你肯定奇怪第5行的写法了，这里为什么需要<code>$ocLazyLoad</code>呢？<a href="https://github.com/ocombe/ocLazyLoad" target="_blank" rel="external">ocLazyLoad</a>是一个适用于Angular的Lazyload的库，其实我们只用它就可以实现Angular的LazyLoad，但这里我们用它的作用并不是动态加载文件，而是<strong>使webpack动态加载进来的文件中的Angular的module名<code>app.pages.phone</code>生效</strong>。因为Angular是不允许动态去声明一个module的，我们需要使用这种方法来使动态加载进来的文件中包含的Angular的module生效。</p>
<p>讲完了HTML和JS，那CSS怎么办呢？其实有了css-loader我们完全可以把它放在JS中或HTML中通过<code>require(xxx.css)</code>加载进来，因为通常CSS是与某个页面或某个模块绑定的（公用的样式除外），所以放在某个HTML中或某个JS模块中来require它也是合情合理的。</p>
<p>这样一来，phoen模块依赖的所有HTML、JS、CSS都动态加载进来了，在真正build的时候，会生成一个名为<code>phone.js</code>的文件（可以使用webpack的output.chunkFilename来配置生成的chunk文件的名称规则）来包含这些东西，而这个文件只有你第一次访问<code>/phone</code>的时候才会动态加载进来，这一点可以访问<a href="http://pinkyjie.com/angular1-webpack-starter/#/">http://pinkyjie.com/angular1-webpack-starter/#/</a> 并打开console来验证。</p>
<h4 id="style-loader的坑"><a href="#style-loader的坑" class="headerlink" title="style-loader的坑"></a>style-loader的坑</h4><p>这样设置了以后，所有动态加载的HTML、CSS和JS都会放在最终生成的<code>phone.js</code>中，也就是说，webpack目前是不支持为chunk生成单独<br>的CSS文件的，我提了个issue：<a href="https://github.com/webpack/webpack/issues/1758" target="_blank" rel="external">webpack/webpack #1758</a>，但目前还没回应。这会产生什么问题呢？如果你要动态加载的CSS中含有图片路径，比如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">background</span> url(<span class="string">"../../components/_layout/logo.png"</span>) top center no-repeat</div></pre></td></tr></table></figure>
<p>那么最终得到的CSS中路径虽然是正确的：<code>url(assets/images/logo.46e065707257b2930a699c7cdacd7e86.png) top center no-repeat</code>（具体路径与你的file-loader配置有关），但Chrome会将这个路径解析为：<code>chrome-devtools://devtools/bundled/assets/images/logo.46e065707257b2930a699c7cdacd7e86.png</code>，因为CSS文件是以动态bundle的形式加载进来的，所以图片资源的相对路径是以bundle为准的，这将导致图片无法正常的显示。已经有人在style-loader的项目里提了bug：<a href="https://github.com/webpack/style-loader/issues/93" target="_blank" rel="external">webpack/style-loader #93</a>，但目前style-loader还没有修复。好消息是Vue的作者fork了一份style-loader并<a href="https://github.com/vuejs/vue-style-loader/commit/70b9f6ac2a2c1f2525c7e8945173d34957510ef6" target="_blank" rel="external">修复了这个问题</a>，所以暂时大家可以使用<a href="https://github.com/vuejs/vue-style-loader" target="_blank" rel="external">vue-style-loader</a>代替style-loader来解决这个问题。</p>
<p>最后，完整的实现可以看我Github上的<a href="https://github.com/PinkyJie/angular1-webpack-starter" target="_blank" rel="external">angular1-webpack-starter</a>项目。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果前两年大家还在讨论grunt和gulp等构建工具的话，现在无疑是&lt;a href=&quot;https://webpack.github.io/&quot;&gt;webapck&lt;/a&gt;的时代。严格来讲，webpack其实和grunt/gulp根本不是一种东西，它不是一个构建工具，而是&lt;code&gt;module bundler&lt;/code&gt;。简单来说，webpack将JS、CSS、HTML（包含各种预处理器）以及图片等等都视为“资源”，每个资源文件都是一个module文件，而module文件之间存在依赖，webpack就是根据module文件间的依赖将所有module打包（bundle）起来。而回忆我们用grunt/gulp构建项目时，做的很大一部分工作也无非是将JS、CSS、HTML编译合并压缩等等，所以从这个层面上讲用webpack和grunt/gulp得到的结果是一样的。但webpack好就好在使用loader的概念让配置更加容易，再也不用和一堆文件路径打交道了。这篇文章就讲一下自己在使用webpack时的一些实践。&lt;/p&gt;
    
    </summary>
    
      <category term="工具相关" scheme="http://pinkyjie.com/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="AngularJS" scheme="http://pinkyjie.com/tags/AngularJS/"/>
    
      <category term="ui-router" scheme="http://pinkyjie.com/tags/ui-router/"/>
    
      <category term="angular1-webpack-starter" scheme="http://pinkyjie.com/tags/angular1-webpack-starter/"/>
    
      <category term="webpack" scheme="http://pinkyjie.com/tags/webpack/"/>
    
      <category term="LazyLoad" scheme="http://pinkyjie.com/tags/LazyLoad/"/>
    
      <category term="ocLazyLoad" scheme="http://pinkyjie.com/tags/ocLazyLoad/"/>
    
  </entry>
  
  <entry>
    <title>用TravisCI来做持续集成</title>
    <link href="http://pinkyjie.com/2016/02/27/continuous-integration-with-travis-ci/"/>
    <id>http://pinkyjie.com/2016/02/27/continuous-integration-with-travis-ci/</id>
    <published>2016-02-27T06:35:57.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>持续集成的好处自不用说，一个是省了手动build部署的繁琐，二是每一个提交都有自动跑测试保证质量。平时在公司Jenkins用的比较多，开源世界里同样也有能和Jenkins比肩的好工具：<a href="https://travis-ci.org/" target="_blank" rel="external">TravisCI</a>。TravisCI可以和Github无缝集成，每次push都可以触发相应的操作，跑测试、自动部署都不在话下。这篇文章就记录一下我在<a href="https://github.com/PinkyJie/angular1-webpack-starter" target="_blank" rel="external">angular1-webpack-starter</a>项目上使用TravisCI的经验，最终实现的效果就是：提交一个commit后，自动跑单元测试，然后build项目，然后将测试覆盖率报告和站点部署到Github Pages上去，最后跑E2E测试。</p>
<a id="more"></a>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>TravisCI的上手非常简单，只需三步：</p>
<ol>
<li>用Github账号登录TravisCI，你的所有Repo都会列出来，选择激活你想要build的Repo。</li>
<li>在Github的Repo里添加<code>.travis.yml</code>配置文件。</li>
<li>Push代码到Github，触发自动build。</li>
</ol>
<p>这里要说的就是<code>.travis.yml</code>这个配置文件了（有人可能要吐槽了：哦NO，又一个配置文件，前端的配置文件实在太多了！没办法啊！(*@ο@*)），<code>.travis.yml</code>的基本格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="attr">branches:</span></div><div class="line"><span class="attr">  only:</span></div><div class="line"><span class="bullet">    -</span> master</div><div class="line"><span class="attr">language:</span> node_js</div><div class="line"><span class="attr">node_js:</span></div><div class="line"><span class="bullet">  -</span> stable</div><div class="line"><span class="attr">script:</span></div><div class="line"><span class="bullet">  -</span> xxx</div><div class="line"><span class="attr">after_success:</span></div><div class="line"><span class="bullet">  -</span> xxx</div><div class="line"><span class="attr">env:</span></div><div class="line"><span class="attr">  global:</span></div><div class="line"><span class="attr">  - xxx:</span> xxx</div></pre></td></tr></table></figure>
<p>基本上不需要解释就可以明白大致的意思，来自Python家族的yml格式可以说是配置文件中格式最简单，最易读的了。</p>
<ul>
<li><code>branches</code>：指定要build的是哪个分支，支持build多个分支。</li>
<li><code>language</code>：指定使用的语言，前端项目的build过程基本都是node啦。</li>
<li><code>node_js</code>：指定要使用的node版本，可以同时指定多个版本，触发多个build。</li>
<li><code>script</code>：系统自动运行完<code>npm install</code>后会执行这里指定的命令，简单的功能可以直接写一个npm run script，复杂的逻辑也可以指定执行一个bash脚本。</li>
<li><code>after_success</code>：这里是<code>script</code>部分跑成功以后才会执行的命令，这里的命令成功与失败不会影响整个Travis任务。</li>
<li><code>env</code>：这个字段用来定义环境变量，一些需要加密的信息也可以放在这里。</li>
</ul>
<p>当然除此之外，Travis还支持很多的配置，可以查看<a href="https://docs.travis-ci.com/user/customizing-the-build/#The-Build-Lifecycle" target="_blank" rel="external">它的文档</a>来认识下build过程的整个生命周期。</p>
<h3 id="跑单元测试并上传覆盖率报告"><a href="#跑单元测试并上传覆盖率报告" class="headerlink" title="跑单元测试并上传覆盖率报告"></a>跑单元测试并上传覆盖率报告</h3><p>跑测试是自动化部署的第一步，如果单元测试都跑不过的话也不用build项目了。跑单元测试的方法不用多说，配好了karma以后，运行一个<code>npm test</code>就好。这里简单讲讲其中的两个问题：</p>
<ol>
<li>识别Travis的环境。</li>
<li>生成覆盖率报告并上传。</li>
</ol>
<h4 id="识别Travis的环境"><a href="#识别Travis的环境" class="headerlink" title="识别Travis的环境"></a>识别Travis的环境</h4><p>为什么需要专门识别Travis的环境呢？由于测试是在Travis的云主机上跑的，本地跑测试一般都是直接启一个Chrome浏览器，但Travis上显然没有Chrome浏览器（据说有Firefox），所以我们需要headless的浏览器PhantomJS来跑测试。虽然Travis自己有环境变量可以帮助我们得知脚本是否运行在Travis上，但我推荐的方法还是直接给npm script传参数比较好，这样方便以后我们移植到其它CI平台。我们要达到的最终目的是：运行<code>npm test</code>则用Chrome来跑，运行<code>npm test -- --ci</code>则用PhantomJS来跑。注意这里中间的<code>--</code>，根据<a href="https://docs.npmjs.com/cli/run-script" target="_blank" rel="external">官方文档</a>的解释，npm需要这个标记来获知npm自己的options已经结束，npm会把中间的<code>--</code>之后的部分都传给你自己的脚本。我们的<code>npm test</code>在package.json中是这样配置的：<code>karma start ./karma.config.js</code>，所以我们需要在karma.config.js中处理传入的<code>--ci</code>参数。不要看karma.config.js只是一个配置文件，其实里面可以随便放任何的nodejs逻辑，只要保证这个文件最后export出一个函数即可：<code>moudule.exports = (config) =&gt; {config.set({...})}</code>。说到处理参数，nodejs中有非常好用的工具：<a href="https://www.npmjs.com/package/yargs" target="_blank" rel="external">yargs</a>，它支持多种处理命令行参数的方式，使用非常简单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> args = <span class="built_in">require</span>(<span class="string">'yargs'</span>).argv;</div><div class="line"><span class="keyword">const</span> browser = (args.watch || args.ci) ? <span class="string">'PhantomJS'</span> : <span class="string">'Chrome'</span>;</div><div class="line"><span class="keyword">const</span> files = browser === <span class="string">'PhantomJS'</span> ? [</div><div class="line">    <span class="string">'node_modules/babel-core/browser-polyfill.js'</span>,</div><div class="line">    unitTestEntry</div><div class="line">] : [</div><div class="line">    unitTestEntry</div><div class="line">];</div><div class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</div><div class="line">    config.set(&#123;</div><div class="line">        files,</div><div class="line">        <span class="attr">browsers</span>: [</div><div class="line">            browser</div><div class="line">        ],</div><div class="line">        <span class="comment">// ....</span></div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，只要将这个包require进来，处理参数起来真是得心应手。第2行中我们指定如果带有<code>--watch</code>或<code>--ci</code>参数，则使用Chrome浏览器（这里的watch模式用于：在开发时代码一更新就自动跑测试，由于需要频繁跑测试，用PhantomJS的话跑的更快一些）。另外，我们采用了ES6，那么在使用PhantomJS的时候就需要额外包含Babel的polyfill（第4行）。</p>
<h4 id="生成报告并上传"><a href="#生成报告并上传" class="headerlink" title="生成报告并上传"></a>生成报告并上传</h4><p>生成覆盖率测试报告自然是要用karma-coverage了，只需要在karma的配置中配置<code>coverageReproter</code>即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">reporters: [<span class="string">'mocha'</span>, <span class="string">'coverage'</span>],</div><div class="line"><span class="attr">coverageReporter</span>: &#123;</div><div class="line">    <span class="attr">dir</span>: <span class="string">'source/test/unit/results/coverage'</span>,</div><div class="line">    <span class="attr">reporters</span>: [</div><div class="line">        &#123;<span class="attr">type</span>: <span class="string">'lcov'</span>, <span class="attr">subdir</span>: <span class="string">'.'</span>&#125;,</div><div class="line">        &#123;<span class="attr">type</span>: <span class="string">'text-summary'</span>&#125;</div><div class="line">    ]</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>上面的lcov就用来生成覆盖率报告，运行<code>npm test</code>以后，就会在指定的路径（dir配置）里生成覆盖率报告：以网页的形式展示所有文件的覆盖率。如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/continuous-integration-with-travis-ci-3.png" class="center-img" title="图3">
<p>这里要重点说的是上传这个报告，一方面需要将这个报告也部署到Github Pages上方便查看，另一方面还可以将报告上传到“特殊”的网站。前者我们将在下一节详细讲，这里主要说这个“特殊”的网站：<a href="https://codecov.io/" target="_blank" rel="external">CodeCov</a>。看名字就知道它是一个专门服务于代码覆盖率的工具，将报告上传后不仅可以在上面方便的查看，关键是可以得到下面这个东西：</p>
<p><a href="https://codecov.io/github/PinkyJie/angular1-webpack-starter" target="_blank" rel="external"><img src="https://img.shields.io/codecov/c/github/PinkyJie/angular1-webpack-starter.svg?style=flat-square" alt="Codecov"></a></p>
<p>哈哈，把它放在项目的readme里是不是特别有范（对类似的badge服务感兴趣的可以戳<a href="http://shields.io/" target="_blank" rel="external">Shields</a>，里面有各种各样包罗万象的badge）。上传也是非常的简单，首先安装CodeCov提供的<a href="https://www.npmjs.com/package/codecov.io" target="_blank" rel="external">node工具</a>，然后一条npm script搞定：<code>&quot;codecov&quot;: &quot;cat ./source/test/unit/results/coverage/lcov.info | codecov&quot;,</code>。这样在<code>.travis.yml</code>就可以直接调用<code>npm run codecov</code>来上传报告啦。</p>
<h3 id="部署到Github-Pages"><a href="#部署到Github-Pages" class="headerlink" title="部署到Github Pages"></a>部署到Github Pages</h3><p>Travis自身支持很多<a href="https://docs.travis-ci.com/user/deployment/" target="_blank" rel="external">deploy的服务</a>，但由于<a href="https://github.com/PinkyJie/angular1-webpack-starter" target="_blank" rel="external">我的项目</a>是一个纯前端的项目，并不需要后台，所以我选择直接把它部署到Github Pages上。Github Pages其实就相当于一个静态的server，其部署流程其实就是把build后的页面push到项目的<code>gh-pages</code>分支下即可。要上传我们也要搞定两个问题：</p>
<ol>
<li>项目中的路由使用HTML5模式，需配合webpack-dev-server的<a href="https://webpack.github.io/docs/webpack-dev-server.html#the-historyapifallback-option" target="_blank" rel="external">historyApiFallback配置</a>，而Github Pages上是纯静态server，我们需要使用<code>/#</code>这种路由模式。</li>
<li><code>git push</code>到Github是需要权限的，你不可能把自己的私钥上传到Travis上去。</li>
</ol>
<h4 id="build前更改代码"><a href="#build前更改代码" class="headerlink" title="build前更改代码"></a>build前更改代码</h4><p>先来看第一个问题，解决这个问题的关键就是，在Travis开始build之前，我们需要更改代码里的<code>this.$locationProvider.html5Mode(true);</code>这一句，将true改为false即可。那怎么优雅的做这个更改呢？答案是使用git的patch功能！我们可以先在本地做这个更改，然后运行<code>git diff &gt; gh-pages-patch.diff</code>这样，就会得到这样内容的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">diff --git a/<span class="built_in">source</span>/app/components/_common/services/router-helper.provider.js b/<span class="built_in">source</span>/app/components/_common/services/router-helper.provider.js</div><div class="line">index 426cf72..5319d32 100644</div><div class="line">--- a/<span class="built_in">source</span>/app/components/_common/services/router-helper.provider.js</div><div class="line">+++ b/<span class="built_in">source</span>/app/components/_common/services/router-helper.provider.js</div><div class="line">@@ -101,7 +101,7 @@ class RouterHelperProvider &#123;</div><div class="line">             mainTitle: <span class="string">''</span>,</div><div class="line">             resolveAlways: &#123;&#125;</div><div class="line">         &#125;;</div><div class="line">-        this.<span class="variable">$locationProvider</span>.html5Mode(<span class="literal">true</span>);</div><div class="line">+        this.<span class="variable">$locationProvider</span>.html5Mode(<span class="literal">false</span>);</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>其实就是将diff的内容保存到一个文件，然后这个patch文件我们就可以在需要的时候将它应用回去。在Travis上build之前，我们可以直接运行<code>git apply ./gh-pages-patch.diff</code>，这样这行代码的变动就可以应用到Travis拿到的代码上，然后再开始build就可以保证得到的最终网页是正确的了。</p>
<h4 id="Github的权限问题"><a href="#Github的权限问题" class="headerlink" title="Github的权限问题"></a>Github的权限问题</h4><p>关于Github的权限问题，其实除了使用私钥外，Github也是允许使用Access Token来push代码的，我们就是需要利用这一点来将build后的代码push回gh-pages分支。首先访问Github设置里的<a href="https://github.com/settings/tokens" target="_blank" rel="external">Personal access tokens</a>，选择“Generate new token”来生成新的token，给token起一个名字然后只选择repo权限即可，添加成功后会看到类似下面的页面：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/continuous-integration-with-travis-ci-1.png" class="center-img" title="图1">
<p>这里必须将token保存到你本地，因为token只会显示一次，一旦你离开这个页面，再也看不到这个token了。有了这个token，我们就可以使用下面的命令来push代码了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push <span class="string">"https://xxx@github.com/PinkyJie/angular1-webpack-starter.git"</span> master:gh-pages</div></pre></td></tr></table></figure>
<p>其中的xxx就是你的token，而后面是Github项目的地址。当然，因为<code>.travis.yml</code>文件是公开的，我们不可能就直接把这个token明文写在里面，别人有了token就相当于有了你Github所有Repo的push权限（这也是为什么token在生成后只显示一次）。贴心的Travis早就想到了这一点，它提供<a href="https://docs.travis-ci.com/user/encryption-keys/#Usage" target="_blank" rel="external">对“键值对”进行加密的功能</a>。首先我们需要安装Travis提供的加密工具：<code>gem install travis</code>，然后在你的项目目录下（其他目录需要手动指定<code>-r owner/project</code>）运行<code>travis encrypt GITHUB_TOKEN=xxx</code>就会得到类似<code>secure: &quot;...&quot;</code>的输出，将这段输出放在<code>.travis.yml</code>中的环境变量块下面即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">env:</span></div><div class="line"><span class="attr">  global:</span></div><div class="line"><span class="attr">  - GitHub_REF:</span> github.com/PinkyJie/angular1-webpack-starter.git</div><div class="line"><span class="attr">  - secure:</span> <span class="string">"..."</span></div></pre></td></tr></table></figure>
<p>注意，这里的加密是把key和value都加密了，<code>.travis.yml</code>里允许出现多个secure的定义，它们都将作为环境变量供你的脚本调用，在脚本中可以使用<code>${GitHub_TOKEN}</code>和<code>${GitHub_REF}</code>引用上面定义的变量。最后我们还可以给Travis的push提供一个假的身份，这样在Github上我们一看到某个commit就知道这是Travis里push上来的，最终的脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> build</div><div class="line">git init</div><div class="line">git config user.name <span class="string">"Travis CI"</span></div><div class="line">git config user.email <span class="string">"travis@pinkyjie.com"</span></div><div class="line">git add .</div><div class="line">git commit -m <span class="string">"Deploy at `date +"</span>%Y-%m-%d %H:%M<span class="string">"`"</span></div><div class="line">git push --force --quiet <span class="string">"https://<span class="variable">$&#123;GitHub_TOKEN&#125;</span>@<span class="variable">$&#123;GitHub_REF&#125;</span>"</span> master:gh-pages &gt; /dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>可以看到第3-4行，我们给Travis配了一个名字和假的Email，第6行我们给commit配了一个包含时间戳的message，这样就很容易从Github上知道这次部署发生在几点了。</p>
<p>除了上传build后的代码，我们还可以将前面提到的单元测试覆盖率报告也上传到Github Pages上去，只需要在build完成后将生成的coverage目录复制到build目录即可。有一点值得注意的就是Github Pages有一个设置就是：下划线<code>_</code>开头的文件夹名在web上无法访问。如果你的代码结构中有下划线命名的文件夹，则单元测试报告里也会有同名的文件夹，我们可以将其重命名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mv ./build/coverage/app/components/_common ./build/coverage/app/components/common</div><div class="line">sed -i <span class="string">'s/href=\"app\/components\/_common/href=\"app\/components\/common/g'</span> ./build/coverage/index.html</div></pre></td></tr></table></figure>
<p>这里先对文件夹进行重命名，再对文件内容里涉及到的相应超链接进行更新。</p>
<h3 id="用Sauce-Labs跑E2E测试"><a href="#用Sauce-Labs跑E2E测试" class="headerlink" title="用Sauce Labs跑E2E测试"></a>用Sauce Labs跑E2E测试</h3><p>部署好了自然是要在部署的站点上来一个E2E测试了，这也是为什么我们要把E2E测试放在<code>after_success</code>这个阶段，因为需要等<code>script</code>阶段的部署完成才可以。前端的一个重要的问题就是浏览器兼容性问题，所以我们当然希望E2E测试能够覆盖越多的浏览器越好，比如IE、Chrome、Safari，甚至iOS和Android上的浏览器。这个时候就需要<a href="https://saucelabs.com/" target="_blank" rel="external">Sauce Labs</a>出场了，它就相当于一个云端的浏览器仓库，包含各种设备各种系统上的不同浏览器，可以通过配置文件让你的测试跑在它上面。这么好的服务自然不是免费的，好消息是：对于开源项目，它是完全免费的，虽然只允许同时运行5个浏览器实例，但对于我们来说已经足够了。protractor的配置文件本身就是支持Sauce Labs的，只需要在配置文件中添加<code>sauceUser</code>和<code>sauceKey</code>即可，分别是你注册Sauce Labs时的用户名以及自动生成的Access Key。跟karma的配置文件类似，我们也需要在protractor的配置文件中处理传入参数。看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (args.ci) &#123;</div><div class="line">    <span class="comment">// run by sauce lab</span></div><div class="line">    config.baseUrl = <span class="string">'http://pinkyjie.com/angular1-webpack-starter/#'</span>;</div><div class="line">    config.sauceUser = <span class="string">'xxx'</span>;</div><div class="line">    config.sauceKey = <span class="string">'xxx'</span>;</div><div class="line">    config.multiCapabilities = [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">`Chrome (build-<span class="subst">$&#123;args.buildId&#125;</span>)`</span>,</div><div class="line">            <span class="attr">build</span>: <span class="string">`<span class="subst">$&#123;args.buildId&#125;</span>`</span>,</div><div class="line">            <span class="attr">browserName</span>: <span class="string">'chrome'</span>,</div><div class="line">            <span class="attr">platform</span>: <span class="string">'Windows 7'</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">`Safari (build-<span class="subst">$&#123;args.buildId&#125;</span>)`</span>,</div><div class="line">            <span class="attr">build</span>: <span class="string">`<span class="subst">$&#123;args.buildId&#125;</span>`</span>,</div><div class="line">            <span class="attr">browserName</span>: <span class="string">'safari'</span>,</div><div class="line">            <span class="attr">platform</span>: <span class="string">'OS X 10.11'</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">`IE (build-<span class="subst">$&#123;args.buildId&#125;</span>)`</span>,</div><div class="line">            <span class="attr">build</span>: <span class="string">`<span class="subst">$&#123;args.buildId&#125;</span>`</span>,</div><div class="line">            <span class="attr">browserName</span>: <span class="string">'internet explorer'</span>,</div><div class="line">            <span class="attr">platform</span>: <span class="string">'Windows 7'</span>,</div><div class="line">            <span class="attr">version</span>: <span class="string">'11.0'</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">`iOS (build-<span class="subst">$&#123;args.buildId&#125;</span>)`</span>,</div><div class="line">            <span class="attr">build</span>: <span class="string">`<span class="subst">$&#123;args.buildId&#125;</span>`</span>,</div><div class="line">            <span class="attr">browserName</span>: <span class="string">'Safari'</span>,</div><div class="line">            <span class="attr">appiumVersion</span>: <span class="string">'1.4.16'</span>,</div><div class="line">            <span class="attr">deviceName</span>: <span class="string">'iPhone 5s'</span>,</div><div class="line">            <span class="attr">deviceOrientation</span>: <span class="string">'portrait'</span>,</div><div class="line">            <span class="attr">platformVersion</span>: <span class="string">'9.1'</span>,</div><div class="line">            <span class="attr">platformName</span>: <span class="string">'iOS'</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">`Android (build-<span class="subst">$&#123;args.buildId&#125;</span>)`</span>,</div><div class="line">            <span class="attr">build</span>: <span class="string">`<span class="subst">$&#123;args.buildId&#125;</span>`</span>,</div><div class="line">            <span class="attr">browserName</span>: <span class="string">'Browser'</span>,</div><div class="line">            <span class="attr">appiumVersion</span>: <span class="string">'1.4.16'</span>,</div><div class="line">            <span class="attr">deviceName</span>: <span class="string">'Android Emulator'</span>,</div><div class="line">            <span class="attr">deviceOrientation</span>: <span class="string">'portrait'</span>,</div><div class="line">            <span class="attr">platformVersion</span>: <span class="string">'4.4'</span>,</div><div class="line">            <span class="attr">platformName</span>: <span class="string">'Android'</span></div><div class="line">        &#125;</div><div class="line">    ];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// local run</span></div><div class="line">    config.baseUrl = <span class="string">'http://localhost:8080'</span>;</div><div class="line">    config.multiCapabilities = [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">browserName</span>: <span class="string">'chrome'</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">browserName</span>: <span class="string">'chrome'</span>,</div><div class="line">            <span class="attr">chromeOptions</span>: &#123;</div><div class="line">                <span class="attr">args</span>: [<span class="string">'--window-size=375,627'</span>]</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在配置文件中，我们判断如果传入了<code>--ci</code>则添加<code>sauceUser</code>和<code>sauceKey</code>，否则就不加。另外，有ci的时候我们需要传入不同的<code>baseUrl</code>，没ci则认为是在本地跑测试。两者都使用了<code>multiCapabilities</code>，ci上跑的时候指定了我们要测试的5个浏览器，本地则是开了两个Chrome，一个全屏一个模拟手机分辨率来测试。我们重点来看看使用Sauce Labs时的5个浏览器配置，它们分别是Chrome、Safari、IE、Android浏览器，和iOS上的Safari（Android和iOS的测试使用了<a href="http://appium.io/" target="_blank" rel="external">Appium</a>），当然Sauce Labs还支持很多的浏览器，可以通过<a href="https://wiki.saucelabs.com/display/DOCS/Platform+Configurator#/" target="_blank" rel="external">其文档</a>来生成指定浏览器的配置。上面的例子中除了浏览器的系统、名字和版本外，我们还指定了<code>name</code>和<code>build</code>，这也是Sauce Labs特有的配置，这两个配置可以让Sauce Labs更好的显示和组织属于同一个build的测试，如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/continuous-integration-with-travis-ci-2.png" class="center-img" title="图2">
<p>属于同一个build的所有E2E测试被组织到了一起。这里传入的buildId则是Travis每次build自动生成的ID，我们可以通过环境变量获取：<code>npm run e2e -- --ci --build-id=$TRAVIS_BUILD_NUMBER</code>。</p>
<h4 id="本地的站点也能测"><a href="#本地的站点也能测" class="headerlink" title="本地的站点也能测"></a>本地的站点也能测</h4><p>有这样一种场景，如果你的网站架在本地的话（比如localhost），外网是无法访问的，这样在Sauce Labs上的云主机也就无法访问你的网站，自然也无法跑测试的。为了解决这个需求，Sauce Labs还提供了一个有用的功能：<a href="https://wiki.saucelabs.com/display/DOCS/Using+Sauce+Connect+for+Testing+Behind+the+Firewall+or+on+Localhost" target="_blank" rel="external">Sauce Connect</a>。它会在本地开启一个tunnel，用来接收protractor的命令，然后传给Sauce Labs云主机上的浏览器。幸运的是Travis也支持这个功能，只需要在<code>.travis.yml</code>中添加指定的配置即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="attr">addons:</span></div><div class="line"><span class="attr">  sauce_connect:</span></div><div class="line"><span class="attr">    username:</span> <span class="string">"xxx"</span></div><div class="line"><span class="attr">    access_key:</span> <span class="string">"xxx"</span></div><div class="line"><span class="attr">  apt:</span></div><div class="line"><span class="attr">    sources:</span></div><div class="line"><span class="bullet">    -</span> ubuntu-toolchain-r-test</div><div class="line"><span class="attr">    packages:</span></div><div class="line"><span class="bullet">    -</span> gcc<span class="bullet">-4.8</span></div><div class="line"><span class="bullet">    -</span> g++<span class="bullet">-4.8</span></div></pre></td></tr></table></figure>
<p>然后在protractor的配置文件中，给每个浏览器的配置添加<code>&#39;tunnel-identifier&#39;: args.jobId</code>即可，而这个jobId也是Travis每次build自动生成的，也可以通过环境变量获取：<code>npm run e2e -- --ci --build-id=$TRAVIS_BUILD_NUMBER --job-id=$TRAVIS_JOB_NUMBER</code>。这样，你就可以在Travis的机器上启一个本地的网站，然后通过Sauce Connect来测试它了。</p>
<h4 id="Timeout的问题"><a href="#Timeout的问题" class="headerlink" title="Timeout的问题"></a>Timeout的问题</h4><p>这是我自己碰到的一个问题，E2E测试在本地跑的好好的，但放在Sauce Labs上总是提示超时。protractor的文档专门<a href="http://www.protractortest.org/#/timeouts" target="_blank" rel="external">有一个章节</a>来讲超时的问题。简单的说，如果出现超时，可以从两方面入手，一个是增加jasmine的默认超时时间，即在protractor的配置中加入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jasmineNodeOpts: &#123;</div><div class="line">    <span class="attr">defaultTimeoutInterval</span>: <span class="number">600</span> * <span class="number">1000</span> <span class="comment">// 毫秒</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一方面，Sauce Labs也有3个参数来控制超时，可以在protractor的配置文件中给每个浏览器的配置中加入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 秒</span></div><div class="line">maxDuration: <span class="number">3600</span>,</div><div class="line"><span class="attr">commandTimeout</span>: <span class="number">600</span>,</div><div class="line"><span class="attr">idleTimeout</span>: <span class="number">1000</span></div></pre></td></tr></table></figure>
<blockquote>
<p>就我个人的经验，目前项目的E2E测试在本地跑完全没问题，在Sauce Labs上仍然会报错，目前仍在研究中（<a href="https://github.com/PinkyJie/angular1-webpack-starter/issues/9" target="_blank" rel="external">issue 9</a>）</p>
</blockquote>
<p>最后，完整的实现可以戳这里：</p>
<ul>
<li><a href="https://github.com/PinkyJie/angular1-webpack-starter/blob/master/.travis.yml" target="_blank" rel="external">.travis.yml</a></li>
<li><a href="https://github.com/PinkyJie/angular1-webpack-starter/blob/master/publish-to-gh-pages.sh" target="_blank" rel="external">script部分的脚本</a></li>
<li><a href="https://github.com/PinkyJie/angular1-webpack-starter/blob/master/karma.config.js" target="_blank" rel="external">karma.config.js</a></li>
<li><a href="https://github.com/PinkyJie/angular1-webpack-starter/blob/master/protractor.config.js" target="_blank" rel="external">protractor.config.js</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续集成的好处自不用说，一个是省了手动build部署的繁琐，二是每一个提交都有自动跑测试保证质量。平时在公司Jenkins用的比较多，开源世界里同样也有能和Jenkins比肩的好工具：&lt;a href=&quot;https://travis-ci.org/&quot;&gt;TravisCI&lt;/a&gt;。TravisCI可以和Github无缝集成，每次push都可以触发相应的操作，跑测试、自动部署都不在话下。这篇文章就记录一下我在&lt;a href=&quot;https://github.com/PinkyJie/angular1-webpack-starter&quot;&gt;angular1-webpack-starter&lt;/a&gt;项目上使用TravisCI的经验，最终实现的效果就是：提交一个commit后，自动跑单元测试，然后build项目，然后将测试覆盖率报告和站点部署到Github Pages上去，最后跑E2E测试。&lt;/p&gt;
    
    </summary>
    
      <category term="工具相关" scheme="http://pinkyjie.com/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="angular1-webpack-starter" scheme="http://pinkyjie.com/tags/angular1-webpack-starter/"/>
    
      <category term="持续集成" scheme="http://pinkyjie.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="TravisCI" scheme="http://pinkyjie.com/tags/TravisCI/"/>
    
      <category term="SauceLabs" scheme="http://pinkyjie.com/tags/SauceLabs/"/>
    
      <category term="SauceConnect" scheme="http://pinkyjie.com/tags/SauceConnect/"/>
    
      <category term="yargs" scheme="http://pinkyjie.com/tags/yargs/"/>
    
  </entry>
  
  <entry>
    <title>Angular里的E2E测试</title>
    <link href="http://pinkyjie.com/2016/02/21/e2e-testing-in-angular/"/>
    <id>http://pinkyjie.com/2016/02/21/e2e-testing-in-angular/</id>
    <published>2016-02-21T14:39:13.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇聊完了<a href="/2016/02/20/separation-of-concerns-in-unit-test/">单元测试</a>，这一篇来说说E2E测试。单元测试着眼的是“关注分离”，测的是一些函数单元是不是工作正常，而E2E则是集成测试，从最终用户的角度来进行端到端（End To End）的测试，测一些用户场景是不是正常。这篇文章就来探讨一下写E2E测试的最佳实践，本文使用protractor 2.x和jasmine 2.x，但一些思路和想法同样适用于别的框架。</p>
<a id="more"></a>
<h3 id="使用mock-API和非真实后台"><a href="#使用mock-API和非真实后台" class="headerlink" title="使用mock API和非真实后台"></a>使用mock API和非真实后台</h3><p>这一点其实存在很大争议，很多人觉得E2E测试作为集成测试就应该使用纯真实的server环境，所有后台API都应该实打实。我个人认为E2E测试是更偏向于开发者的测试而不是QA的测试，QA的测试当然要“真枪实弹”，但开发者使用mock API我觉得更加方便。我认为好处主要有以下几点：</p>
<ul>
<li>mock的API不仅可以用于测试，还可以加速开发。现在的Web开发早已趋向彻底的前后分离，后端只提供API，其他的都归前端。前端在开发阶段就需要根据前后端商量好的contract来mock API，使得在后端API未完工的情况下可以方便的进行前端的开发。所以mock一次，开发和测试阶段都能用，划算啊！</li>
<li>迅速解决“前后端撕逼”问题。众所周知，<strong>所有的bug都是前端bug</strong>，因为QA测的是你的前端页面啊，不管bug是什么引起的，肯定都是报给前端啊。所以，前端每天要做的一件重要的事就是迅速分辨哪些bug是由后端API引起的。使用mock API跑E2E测试，就是要保证在后端API正常返回的情况下前端逻辑能正常工作。这样一旦E2E测试跑过了，就可以迅速撇清关系：对不起，请把这个bug assign给后台修！</li>
<li>节约测试成本。使用mock API使得E2E测试可以跑在自己的开发server上，不仅可以减轻测试 server的压力，更是避免了真实测试环境的一些资源消耗。</li>
<li>跑起来速度快！没了真实环境的束缚，API想几秒返回就几秒返回，测试跑起来自然非常快了。</li>
</ul>
<p>说完了好处，来说说问题。使用mock API带来的最大问题就是，你需要保证你mock的逻辑与后台的真实逻辑是相匹配的。比如说，后台有DB，你也要有一个类似数据库的地方存数据；后台可以根据不同的输入返回正确的值或错误代码，你的mock同样需要做到这一点。在谈具体的解决方案之前，让我们先从文件夹结构说起，下图是我在项目中常用的E2E文件夹结构：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/e2e-testing-in-angular-1.png" class="center-img" title="图1">
<p>e2e文件夹下分了mocks和specs两个目录，specs不多说，重点看看mocks目录。</p>
<ul>
<li>index.js：这个文件是“带mock API的app”的入口，来看一个简单的例子：</li>
</ul>
<figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'appTest'</span>, [</div><div class="line">    app.name,</div><div class="line">    <span class="string">'ngMockE2E'</span></div><div class="line">])</div><div class="line">    .service(MockData.name, MockData)</div><div class="line">    .config(appTestConfig)</div><div class="line">    .run(userServiceMock)</div><div class="line">    .run(phoneServiceMock);</div></pre></td></tr></table></figure>
<p>其中定义了新的module，它依赖原始的app的module，并在其上定义一些新的配置和service。</p>
<ul>
<li>e2e.config.js：这是“带mock API的app”的配置，就是上面代码第6行的<code>appTestConfig</code>，一般我们可以用它定义API的请求延迟。由于使用了mock API，HTTP请求是可以立即返回的，为了让其更逼真，我们可以使用interceptor来监听所有<code>/api</code>开头的请求，让其过几秒再返回，以此来模拟真实的环境。</li>
</ul>
<figure class="highlight javascript"><figcaption><span>e2e.config.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">appTestConfig.$inject = [<span class="string">'$httpProvider'</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">appTestConfig</span> (<span class="params">$httpProvider</span>) </span>&#123;</div><div class="line">    $httpProvider.interceptors.push(apiDelayInterceptor);</div><div class="line">    apiDelayInterceptor.$inject = [<span class="string">'$timeout'</span>, <span class="string">'$q'</span>];</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">apiDelayInterceptor</span> (<span class="params">$timeout, $q</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            response (response) &#123;</div><div class="line">                <span class="comment">// all API response will be delayed 1s to simulate real network</span></div><div class="line">                <span class="keyword">const</span> delay = <span class="number">1000</span>;</div><div class="line">                <span class="keyword">if</span> (response.config.url.match(<span class="regexp">/^api\//</span>)) &#123;</div><div class="line">                    <span class="keyword">const</span> d = $q.defer();</div><div class="line">                    $timeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">                        d.resolve(response);</div><div class="line">                    &#125;, delay);</div><div class="line">                    <span class="keyword">return</span> d.promise;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> response;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> appTestConfig;</div></pre></td></tr></table></figure>
<ul>
<li>e2e.data.js：这个文件定义了一个service（就是index里的<code>MockData</code>），它的作用就是我们前面提到的DB，它包含API要返回的各种数据。之所以将它定义为service，是利用service单例的特性，在E2E测试中，只要页面不刷新，前一个请求对数据的写操作就可以反映到后一个请求的读操作中，这样就跟真实环境的DB很类似了。</li>
<li>e2e.phone.js/e2e.user.js：这两个文件分别对应原始app中定义的service，针对每个service都要有这么一个文件，这个文件的作用就是mock原始service里的各种API请求。来看一个登录API的例子：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">userServiceMock.$inject = [<span class="string">'MockData'</span>, <span class="string">'$httpBackend'</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">userServiceMock</span> (<span class="params">MockData, $httpBackend</span>) </span>&#123;</div><div class="line">    $httpBackend.whenPOST(<span class="string">'api/user/login'</span>).respond(loginHandler);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loginHandler</span> (<span class="params">method, url, data</span>) </span>&#123;</div><div class="line">        <span class="keyword">const</span> req = <span class="built_in">JSON</span>.parse(data);</div><div class="line">        <span class="keyword">if</span> (req.email === <span class="string">'error@error.com'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> [<span class="number">200</span>, &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">message</span>: <span class="string">'LOGIN_WRONG_EMAIL_PASSWORD_PAIR'</span>,</div><div class="line">                <span class="attr">result</span>: <span class="literal">null</span></div><div class="line">            &#125;];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.email === <span class="string">'lock@lock.com'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> [<span class="number">200</span>, &#123;</div><div class="line">                <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">message</span>: <span class="string">'LOGIN_USER_IN_LOCK'</span>,</div><div class="line">                <span class="attr">result</span>: <span class="literal">null</span></div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">        MockData.loginStatus = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">return</span> [<span class="number">200</span>, &#123;</div><div class="line">            <span class="attr">code</span>: <span class="number">0</span>, <span class="attr">message</span>: <span class="literal">null</span>,</div><div class="line">            <span class="attr">result</span>: &#123;</div><div class="line">                <span class="attr">user</span>: MockData.userInfo</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> userServiceMock;</div></pre></td></tr></table></figure>
<p>可以看到，为了让其更逼真，我们可以根据请求发过来的不同数据来mock不同的响应，给出不同的错误代码，这样在E2E测试里我们就可以模拟更多的用户场景了。</p>
<h3 id="PageObject应该包含啥"><a href="#PageObject应该包含啥" class="headerlink" title="PageObject应该包含啥"></a>PageObject应该包含啥</h3><p>PageObject是protractor官方推荐的<a href="http://www.protractortest.org/#/page-objects#with-pageobjects" target="_blank" rel="external">最佳实践</a>，它最大的好处就是将页面元素的选择器与测试本身隔离开，这样一旦页面结构发生变化，只需要更新PageObject即可，测试部分的代码不用变动。在<a href="http://www.protractortest.org/#/page-objects#with-pageobjects" target="_blank" rel="external">官方的例子</a>中，PageObject除了包含元素的定义以外，还包含一个<code>get()</code>函数来加载这个页面，包含两个其他函数来对元素进行输入和获取文字的操作。对于这个例子我持有保留意见，我的看法是好的PageObject应该包含以下这些东西：</p>
<ul>
<li><code>load()</code>或<code>get()</code>函数，用来加载页面。</li>
<li>页面上所有测试需要用到的元素。</li>
<li>页面测试需要用到的数据，比如测试表单页面时需要填入的测试数据。</li>
<li>共享的测试用例，比如多个测试用例可能都需要用到公用的代码来assert特定的逻辑，那么这个公用逻辑可以作为函数提出来放入PageObject。</li>
<li>不要包含对元素的操作函数，像官方例子中的函数，只是简单的在元素上调用<code>.sendKey(xxx)</code>或<code>getText()</code>，我认为没必要将其封装成函数，直接写会更加直观，看测试代码的人也比较容易明白。</li>
<li>每个PageObject单独放一个文件，然后每个文件export这个class，这样一来，如果其他的PageObject依赖这个页面，可以方便的引入。</li>
</ul>
<p>另外，ES6让继承写起来更方便了，我们完全可以打开脑洞，给所用的PageObject来一个基类：<code>BasePageObject</code>，来看一个例子（完整的实现可以看<a href="https://github.com/PinkyJie/angular1-webpack-starter/blob/master/source/test/e2e/helper.js" target="_blank" rel="external">这里</a>）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePageObject</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (url) &#123;</div><div class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;url&#125;);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.ele = <span class="keyword">this</span>._getAllElements();</div><div class="line">        <span class="keyword">this</span>.mainTitle = <span class="string">'Aio Angular App'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    load () &#123;</div><div class="line">        browser.get(<span class="string">`<span class="subst">$&#123;browser.baseUrl&#125;</span>/<span class="subst">$&#123;<span class="keyword">this</span>.url&#125;</span>`</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getHeader () &#123;...&#125;</div><div class="line">    getFooter () &#123;...&#125;</div><div class="line">    getSidebar () &#123;...&#125;</div><div class="line">    getBreadcrumb () &#123;...&#125;</div><div class="line">    getModal () &#123;...&#125;</div><div class="line"></div><div class="line">    <span class="comment">// shared test case</span></div><div class="line">    assertCorrectLayout (config) &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BasePageObject包含所有PageObject都会使用到的公用函数，它的构造函数接收一个url作用参数，这个url被<code>load()</code>函数使用来加载页面，它是子类继承后在子类构造函数中通过<code>super(xxx)</code>来传入的。另外它调用了一个<code>_getAllElements()</code>的函数获得所有元素的定义并将其挂在<code>this.ele</code>对象上方便使用，而这个<code>_getAllElements</code>也是要靠子类自己来实现的。除此之外，我们看到第13-17行定义了四个函数用来获取一些公共的布局组件，因为基本各个页面都包含这些组件，放在基类中子类就可以直接用了。最后基类还包含了公共的测试用例函数<code>assertCorrectLayout()</code>，它接受一个config。从函数名字就可以大致猜到它的作用：每个页面可能都要测试一些公共的布局，比如页面的URL、标题是不是正确啊，header和footer显示是否正常，sidebar和breadcrumb导航是不是能正常工作等等。这些测试每个页面都做，所以把它放在基类中，子类只需要传入一个配置对象即可。来看一个子类PageObject的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> LoginPage <span class="keyword">from</span> <span class="string">'./login.page'</span>;</div><div class="line"><span class="comment">// phone page object</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhonePage</span> <span class="keyword">extends</span> <span class="title">browser</span>.<span class="title">_BasePageObject</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> () &#123;</div><div class="line">        <span class="keyword">super</span>(<span class="string">'phone'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _getAllElements () &#123;</div><div class="line">        <span class="keyword">const</span> $page = $(<span class="string">'.phone-main-view'</span>);</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">addNewBtn</span>: $page.$(<span class="string">'.btn-add-new'</span>),</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// overrite load function to support login</span></div><div class="line">    load () &#123;</div><div class="line">        <span class="keyword">super</span>.load();</div><div class="line">        <span class="keyword">const</span> loginPage = <span class="keyword">new</span> LoginPage();</div><div class="line">        browser._.expectUrlToMatch(loginPage.url);</div><div class="line">        loginPage.loginWithCredential(<span class="string">'f@f'</span>, <span class="string">'f'</span>);</div><div class="line">        browser._.expectUrlToMatch(<span class="keyword">this</span>.url);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，继承了父类后，子类的PageObject要做的就是：</p>
<ul>
<li>子类构造函数中调用父类的构造函数并传入自己的URL。</li>
<li>实现<code>_getAllElements</code>函数，定义自己的页面元素。</li>
<li>根绝需要覆盖父类的<code>load()</code>函数。在这个例子中，假设phone页面需要登录后才能查看，那么直接访问<code>/phone</code>就会被重定向到login页面，那我们就需要依赖LoginPageObject的一些定义和函数，如这里的登录逻辑，成功登录后才能看到自己的页面。所以对于需要登录的页面，我们都要覆盖父类的load函数。</li>
</ul>
<blockquote>
<p>load函数里调用了一些<code>browser._</code>上的函数，这是我们自己定义的helper函数，后面会讲到。</p>
</blockquote>
<h3 id="PageObject里的元素该咋定义"><a href="#PageObject里的元素该咋定义" class="headerlink" title="PageObject里的元素该咋定义"></a>PageObject里的元素该咋定义</h3><p>看到这个标题有人会问：这算问题吗？那我换个方式问，挂在<code>this.ele</code>上的（也就是<code>_getAllElements()</code>函数返回的）应该是选择器本身<code>.xxx</code>还是element包装过的对象<code>$(.xxx)</code>呢？从使用者的角度讲，当然是包装过的对象了，因为方便直接调用上面的一些函数啊。但有些情况下，你还是需要选择器的，举个例子：一个表格里四行三列，行选择器是<code>.row</code>，列选择器分别是<code>.col1/.col2/.col3</code>等。测试里可能需要验证每一个格子里的文字，我们不可能把12个元素都写死放在ele变量上，如何更方便的解决这种需求呢？我的方案是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_getAllElements () &#123;</div><div class="line">    <span class="keyword">const</span> $table = $(<span class="string">'.table'</span>);</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">row</span>: &#123;</div><div class="line">            <span class="attr">view</span>: $page.$$(<span class="string">'.row'</span>),</div><div class="line">            <span class="attr">col1</span>: <span class="string">'.col1'</span>,</div><div class="line">            <span class="attr">col2</span>: <span class="string">'.col2'</span>,</div><div class="line">            <span class="attr">col3</span>: <span class="string">'.col3'</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，我们只返回一个<code>row</code>的元素，它是一个对象，里面的view属性返回包装过的多个元素（<code>$$</code>等价于<code>element.all</code>），其他属性则是它的子元素选择器。简单的说，存在多个实例的父元素（如表格的行）我们使用包装过的对象，对于每行的格子我们使用纯选择器。然后具体的测试中我们就可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> rowList = page.ele.row;</div><div class="line">expect(rowList.view.count()).toBe(<span class="number">4</span>);</div><div class="line"><span class="comment">// first row</span></div><div class="line"><span class="keyword">const</span> first = rowList.view.get(<span class="number">0</span>);</div><div class="line">expect(first.$(rowList.col1).getText()).toBe(xxx);</div></pre></td></tr></table></figure>
<p>遇到存在多个父元素，而每个父元素里又存在很多不同子元素的情况下，可以尝试使用这种方式来定义元素。定义的时候不显得重复，使用的时候也没有很麻烦。</p>
<h3 id="使用ComponentObject"><a href="#使用ComponentObject" class="headerlink" title="使用ComponentObject"></a>使用ComponentObject</h3><p>在<a href="2016/01/31/component-based-development-with-angular-1x/">前面的文章</a>里我们讲过，在基于组件开发的实践中，页面其实是由各个组件搭成的。那么很自然的，PageObject也应该由ComponentObject来组成。同一个组件在不同的页面上重用时，组件内部的元素肯定都是一样的，一些逻辑也基本一致。所以ComponentObject里可以包含这个组件的所有元素以及一些公共的测试用例。考虑到Component在重用时，一般父级元素是不一样的，所以在ComponentObject的构造函数中可以传入一个parentElement的参数用来将组件内的选择器都限定在这个父选择器之内。来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// phone form component object</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFormComp</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (parentElement) &#123;</div><div class="line">        <span class="keyword">const</span> $form = parentElement.$(<span class="string">'.phone-form-view'</span>);</div><div class="line">        <span class="keyword">this</span>.ele = &#123;</div><div class="line">            <span class="attr">saveBtn</span>: $form.$(<span class="string">'.btn-save'</span>),</div><div class="line">            <span class="attr">cancelBtn</span>: $form.$(<span class="string">'.btn-cancel'</span>)</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    assertFormFieldError (field, isError, message) &#123;&#125;</div><div class="line">    assertPhoneDetail (phone) &#123;&#125;</div><div class="line">    assertEditPhoneDetail (phone) &#123;&#125;</div><div class="line">    assertEditingForm (phone, isNew) &#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> PhoneFormComp;</div></pre></td></tr></table></figure>
<p>可以看到在这个Form组件的定义中，组件内所有元素都是定义在传入的父元素的基础上的，这样即便一个页面内有多个同样的组件也不会重复，使用的时候只要传入不同的父级元素即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> PhoneFormComp <span class="keyword">from</span> <span class="string">'./phone-form.comp'</span>;</div><div class="line"></div><div class="line"><span class="comment">// phone add page object</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneAddPage</span> <span class="keyword">extends</span> <span class="title">browser</span>.<span class="title">_BasePageObject</span> </span>&#123;</div><div class="line">    _getAllElements () &#123;</div><div class="line">        <span class="keyword">const</span> $page = $(<span class="string">'.phone-add-view'</span>);</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">form</span>: <span class="keyword">new</span> PhoneFormComp($page)</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="善用helper函数和自定义matcher"><a href="#善用helper函数和自定义matcher" class="headerlink" title="善用helper函数和自定义matcher"></a>善用helper函数和自定义matcher</h3><p>在写E2E测试的时候，我们可能会用到很多工具函数，比如说操作一个select框啊，操作一个DatePicker啊等等，这些操作可能在多个测试用例里都会用到，那么我们可以直接定义一个<code>E2EHelper</code>的class用来存放这些helper函数。在protractor的配置文件中，我们在onPrepare里引入这个class，并将其定义在<code>browser._</code>上，因为browser是所有的spec里默认都可以访问到的，所以很多全局变量都可以考虑挂在它上面。这样在spec文件的测试里就可以方便的使用<code>browser._.xxx</code>来调用这些函数了。</p>
<p>除了helper函数，有的时候我们可能还需要一些自定义的Matcher来扩展jasmine中没有的功能，比如最常用的判断一个元素是否含有某个class样式，与其每次都在测试用例里手写<code>expect(ele.getAttribute(&#39;class&#39;)).toContain(xxx)</code>，不如直接扩展jasmine定义自己的Matcher，语义上更容易理解。Matcher的定义也非常的简单，下面就是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> customMatchers = &#123;</div><div class="line">    <span class="attr">toHaveClass</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">compare</span>: <span class="function">(<span class="params">actual, expected</span>) =&gt;</span> &#123;</div><div class="line">                <span class="keyword">return</span> &#123;</div><div class="line">                    <span class="attr">pass</span>: actual.getAttribute(<span class="string">'class'</span>).then(<span class="function">(<span class="params">classes</span>) =&gt;</span> &#123;</div><div class="line">                        <span class="keyword">return</span> classes.split(<span class="string">' '</span>).indexOf(expected) !== <span class="number">-1</span>;</div><div class="line">                    &#125;)</div><div class="line">                &#125;;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>有了这个定义以后，我们在测试中就可以直接写<code>expect(ele).toHaveClass(xxx)</code>了。网上还有很多成熟的库，包含很多常用的Matcher，感兴趣的可以索索“protractor custom matcher”。自定义的Matcher也需要在onPrepare中初始化，我们在里面定义一个beforeEach函数，把自定义的Matcher加入到jasmine中去。看下面的例子，onPrepare中包含helper函数，上一节提到的BasePageObject，以及自定义的Matcher。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">onPrepare: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> helper = <span class="built_in">require</span>(<span class="string">'./source/test/e2e/helper'</span>);</div><div class="line">    browser._BasePageObject = helper.BasePageObject;</div><div class="line">    browser._ = <span class="keyword">new</span> helper.E2EHelper();</div><div class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="comment">// add custom matchers</span></div><div class="line">        jasmine.addMatchers(helper.customMatchers);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="protractor的大部分函数都返回promise"><a href="#protractor的大部分函数都返回promise" class="headerlink" title="protractor的大部分函数都返回promise"></a>protractor的大部分函数都返回promise</h3><p>这一点可能平时没有注意，其实protractor官方的文档里专门有<a href="http://www.protractortest.org/#/control-flow" target="_blank" rel="external">讲这个</a>。也就是说，平时我们使用的<code>.getText()</code>，<code>.isDisplayed()</code>，<code>.getAttribute()</code>等等返回的都是promise，之所以我们可以直接那么用，是因为jasmine的<code>expect()</code>函数真正expect的是promise resolve后的值。相信平时使用这些函数的时候倒不会犯什么错，最容易犯错的是，定义一些自己的函数时，比如下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ele.isDisplayed()) &#123;</div><div class="line">    <span class="comment">// do something</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// do others</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码的原意是如果元素显示的话，我们做一些事情，不显示的话我们做别的。但事实是这个if判断永远为true，因为里面是一个promise！所以正确的写法应该是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ele.isDisplayed().then(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (val) &#123;</div><div class="line">        <span class="comment">// do something</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// do others</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>要时刻记住protractor里绝大部分的函数返回的都是promise，如果我们自定义的逻辑用到这些函数，就应该以处理promise的方式来处理它们。</p>
<h3 id="其它小tip"><a href="#其它小tip" class="headerlink" title="其它小tip"></a>其它小tip</h3><p>最后说一些让protractor更加好用的小tip。</p>
<h4 id="让测试report更好看"><a href="#让测试report更好看" class="headerlink" title="让测试report更好看"></a>让测试report更好看</h4><p>protractor默认的测试report就是在命令行里输出<code>...F..F..</code>，这么丑的report能忍吗？叔能忍婶不能忍啊！在karma中我们有reporter这个选项，让我们可以配置友好的测试输出，但protractor似乎没有这个配置啊。别急，其实早有人解决了这个难题，试试<a href="https://www.npmjs.com/package/jasmine-spec-reporter" target="_blank" rel="external">jasmine-spec-reporter</a>吧。你要做的很简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 禁用默认的输出</span></div><div class="line">jasmineNodeOpts: &#123;</div><div class="line">    <span class="attr">print</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 添加新的reporter</span></div><div class="line">onPrepare: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> SpecReporter = <span class="built_in">require</span>(<span class="string">'jasmine-spec-reporter'</span>);</div><div class="line">    jasmine.getEnv().addReporter(<span class="keyword">new</span> SpecReporter(&#123;</div><div class="line">        <span class="attr">displayStacktrace</span>: <span class="string">'all'</span>,</div><div class="line">        <span class="attr">displayFailuresSummary</span>: <span class="literal">false</span></div><div class="line">    &#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再跑一下测试看看，结果是不是好看多了？</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/e2e-testing-in-angular-2.png" class="center-img" title="图2">
<p>除了这两个选项外，它还支持很多有意思的配置，具体可以探索它的<a href="https://www.npmjs.com/package/jasmine-spec-reporter" target="_blank" rel="external">文档</a>。</p>
<h4 id="失败时自动截图"><a href="#失败时自动截图" class="headerlink" title="失败时自动截图"></a>失败时自动截图</h4><p>由于测试都是自动化的，一旦跑失败我们除了看log找原因以外，如果有截图就更好了。其实截图也属于reporter的一种，借助插件<a href="https://www.npmjs.com/package/protractor-jasmine2-screenshot-reporter" target="_blank" rel="external">protractor-jasmine2-screenshot-reporter</a>我们就可以实现在E2E测试失败的时候自动保存当前网页的截图到指定文件夹。它的配置也很简单，与上面的reporter类似，也是直接往onPrepare里面添加代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> HtmlScreenshotReporter = <span class="built_in">require</span>(<span class="string">'protractor-jasmine2-screenshot-reporter'</span>);</div><div class="line">jasmine.getEnv().addReporter(<span class="keyword">new</span> HtmlScreenshotReporter(&#123;</div><div class="line">    <span class="attr">dest</span>: <span class="string">`<span class="subst">$&#123;e2eBaseFolder&#125;</span>/screenshots`</span>,</div><div class="line">    <span class="attr">filename</span>: <span class="string">'e2e-report.html'</span>,</div><div class="line">    <span class="attr">captureOnlyFailedSpecs</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">reportOnlyFailedSpecs</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">pathBuilder</span>: <span class="function">(<span class="params">currentSpec</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> currentSpec.description.replace(<span class="regexp">/[ :]/g</span>, <span class="string">'-'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>除了截图，它还支持输出HTML格式的report（第4行），利用pathBuilder函数我们还可以指定截图文件的名称，上例中我们直接将失败的spec的description作为文件名保存。</p>
<h4 id="ES6的报错行号"><a href="#ES6的报错行号" class="headerlink" title="ES6的报错行号"></a>ES6的报错行号</h4><p>protractor 2.x需要手动引入babel来支持使用ES6来书写spec文件，至于配置文件本身，只要你的node版本够高（4.x）或使用<code>--harmony</code>也是可以用ES6来写的。但如果你在protractor的配置文件一开头就引入babel<code>require(&#39;babel-core/register&#39;);</code>就会发现，一旦spec报错，log里给出的报错行号是不对的，在protractor的issues里有人给出了<a href="https://github.com/angular/protractor/issues/2049#issuecomment-146357769" target="_blank" rel="external">解决方案</a>，其实只要在onPrepare里再引入babel即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇聊完了&lt;a href=&quot;/2016/02/20/separation-of-concerns-in-unit-test/&quot;&gt;单元测试&lt;/a&gt;，这一篇来说说E2E测试。单元测试着眼的是“关注分离”，测的是一些函数单元是不是工作正常，而E2E则是集成测试，从最终用户的角度来进行端到端（End To End）的测试，测一些用户场景是不是正常。这篇文章就来探讨一下写E2E测试的最佳实践，本文使用protractor 2.x和jasmine 2.x，但一些思路和想法同样适用于别的框架。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AngularJS" scheme="http://pinkyjie.com/tags/AngularJS/"/>
    
      <category term="promise" scheme="http://pinkyjie.com/tags/promise/"/>
    
      <category term="ES6" scheme="http://pinkyjie.com/tags/ES6/"/>
    
      <category term="angular1-webpack-starter" scheme="http://pinkyjie.com/tags/angular1-webpack-starter/"/>
    
      <category term="集成测试" scheme="http://pinkyjie.com/tags/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/"/>
    
      <category term="protractor" scheme="http://pinkyjie.com/tags/protractor/"/>
    
      <category term="PageObject" scheme="http://pinkyjie.com/tags/PageObject/"/>
    
      <category term="ComponentObject" scheme="http://pinkyjie.com/tags/ComponentObject/"/>
    
  </entry>
  
  <entry>
    <title>谈谈单元测试中的关注分离</title>
    <link href="http://pinkyjie.com/2016/02/20/separation-of-concerns-in-unit-test/"/>
    <id>http://pinkyjie.com/2016/02/20/separation-of-concerns-in-unit-test/</id>
    <published>2016-02-20T04:34:34.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端的单元测试越来越受到重视，网上也有很多讲解Angular中如何写好单元测试的文章，我自己在最近的<a href="https://github.com/PinkyJie/angular1-webpack-starter" target="_blank" rel="external">angular1-webpack-starter</a>项目中也写了很多单元测试。单元测试的一个核心理念就是对“单元”进行隔离，然后单独测试。可是网上的很多教程存在不少误区：比如在controller的测试中去使用$httpBackend，在引入第三方service的时候使用真实的service等等，说到底都是没有实现“关注分离”（Separation of Concerns），“单元”没有真正的被隔离。这篇文章就谈谈Angular的单元测试中如何更好的实现关注分离。</p>
<a id="more"></a>
<h3 id="文件结构上的隔离"><a href="#文件结构上的隔离" class="headerlink" title="文件结构上的隔离"></a>文件结构上的隔离</h3><p>好的实践应该是Angular中一个单独的controller/service/provider/directive对应一个单独的spec文件，这是“大单元”的隔离，而每个单元又是由很多“小单元”（函数）组成的，而“小单元”同样需要隔离，那么每个函数可以对应一个spec文件里的describe块。看下面这个service的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// user.service.js</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerivce</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> ($http, $q, $rootScope, Event, AjaxError) &#123;...&#125;</div><div class="line"></div><div class="line">    checkLoggedInStatus () &#123;...&#125;</div><div class="line"></div><div class="line">    login (email, password) &#123;...&#125;</div><div class="line"></div><div class="line">    logout () &#123;...&#125;</div><div class="line">&#125;</div><div class="line">UserSerivce.$inject = [<span class="string">'$http'</span>, <span class="string">'$q'</span>, <span class="string">'$rootScope'</span>, <span class="string">'Event'</span>, <span class="string">'AjaxErrorHandler'</span>];</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> UserSerivce;</div><div class="line"></div><div class="line"><span class="comment">// user.service.spec.js</span></div><div class="line"><span class="keyword">import</span> UserService <span class="keyword">from</span> <span class="string">'./user.service'</span>;</div><div class="line"></div><div class="line">describe(<span class="string">'User Service'</span>, () =&gt; &#123;</div><div class="line"></div><div class="line">    beforeEach(...);</div><div class="line"></div><div class="line">    describe(<span class="string">'constructor function'</span>, () =&gt; &#123;...&#125;);</div><div class="line"></div><div class="line">    describe(<span class="string">'checkLoggedInStatus function'</span>, () =&gt; &#123;...&#125;);</div><div class="line"></div><div class="line">    describe(<span class="string">'login function'</span>, () =&gt; &#123;...&#125;);</div><div class="line"></div><div class="line">    describe(<span class="string">'logout function'</span>, () =&gt; &#123;...&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到在测试的spec文件中，一个“大单元”对应顶层的describe，而“小单元”也有自己对应的子describe，这就从文件结构上保证了单元的隔离。当然这只是表面功夫，要做到更好的关注分离，我觉得要做到以下几点：</p>
<ul>
<li>让测试尽量脱离Angular框架本身。</li>
<li>能mock的依赖全mock，而且只mock需要直接依赖的部分。</li>
<li>对于外部依赖和内部依赖（比如controller的一个函数调用自己的另一个函数），直接spy。</li>
</ul>
<p>下面就以controller/service/provider的测试为例，来讲讲如何贯彻上面几点。需要说明的是，下面的代码都是基于jasmine和ES6的，但是一些思路和想法也同样适用于ES5。</p>
<h3 id="简单controller-service的测试可以脱离框架本身"><a href="#简单controller-service的测试可以脱离框架本身" class="headerlink" title="简单controller/service的测试可以脱离框架本身"></a>简单controller/service的测试可以脱离框架本身</h3><p>对于很多简单的controller和service，它不依赖Angular本身的特殊service（如<code>$rootScope</code>，<code>$http</code>等等），这个时候我们就可以甩开Angular测试里的<code>angular.mock.module</code>和<code>angular.mock.inject</code>这类框架特有的函数，直接在测试中mock它的构造函数的参数，然后new这个class进行测试即可。我们来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AjaxErrorHandlerService</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (Error, $q) &#123;</div><div class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;<span class="built_in">Error</span>, $q&#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// directly reject with the human readable error message</span></div><div class="line">    catcher (reason) &#123;</div><div class="line">        <span class="keyword">const</span> type = <span class="keyword">typeof</span> reason;</div><div class="line">        <span class="keyword">let</span> code = <span class="string">'$UNEXPECTED'</span>;</div><div class="line">        <span class="keyword">if</span> (reason) &#123;</div><div class="line">            <span class="keyword">if</span> (type === <span class="string">'object'</span>) &#123;</div><div class="line">                code = reason.message;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'string'</span>) &#123;</div><div class="line">                code = reason;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$q.reject(&#123;</div><div class="line">            code,</div><div class="line">            <span class="attr">text</span>: <span class="keyword">this</span>.Error.getErrorMessage(code)</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">AjaxErrorHandlerService.$inject = [<span class="string">'Error'</span>, <span class="string">'$q'</span>];</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> AjaxErrorHandlerService;</div></pre></td></tr></table></figure>
<p>可以看到这个<code>AjaxErrorHandlerService</code>提供了一个统一的函数用来处理所有Ajax请求失败的情况，它有两个依赖：定义在其他文件中的名叫<code>Error</code>的service，以及Angular自身的<code>$q</code>。按照传统的Angular单元测试流程，我们需要这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'AjaxErrorHandler Service'</span>, () =&gt; &#123;</div><div class="line">    <span class="keyword">let</span> ErrorService;</div><div class="line">    <span class="keyword">let</span> $q;</div><div class="line">    <span class="keyword">let</span> ajaxErrorHandler;</div><div class="line"></div><div class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        angular.mock.module(<span class="string">'theModuleContainsThisService'</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        angular.mock.inject(<span class="function">(<span class="params">_Error_, _$q_, _AjaxErrorHandler_</span>) =&gt;</span> &#123;</div><div class="line">            <span class="built_in">Error</span> = _Error_;</div><div class="line">            $q = _$q_;</div><div class="line">            ajaxErrorHandler = _AjaxErrorHandler_;</div><div class="line">            spyOn(<span class="built_in">Error</span>, <span class="string">'getErrorMessage'</span>);</div><div class="line">            spyOn($q, <span class="string">'reject'</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在上面的测试中，我们先使用angular-mock模块提供的module函数来加载service所在的module，然后使用inject来引入真实的<code>Error</code>和<code>$q</code>，spy其中的方法，最后再进行我们自己的测试。这里面的误区有两个：</p>
<ol>
<li>这个测试根本不需要使用Angular自身的module和inject</li>
<li>没必要引入真实的service依赖</li>
</ol>
<p>我们来看看修改后的测试(省略describe头)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> AjaxErrorHandlerService <span class="keyword">from</span> <span class="string">'./ajax-error-handler.service'</span>;</div><div class="line"><span class="comment">// describe ...</span></div><div class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    ErrorService = jasmine.createSpyObj(<span class="string">'Error'</span>, [<span class="string">'getErrorMessage'</span>]);</div><div class="line">    $q = jasmine.createSpyObj(<span class="string">'$q'</span>, [<span class="string">'reject'</span>]);</div><div class="line">    ajaxErrorHandler = <span class="keyword">new</span> AjaxErrorHandlerService(ErrorService, $q);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>修改后的测试看起来简洁多了。首先，ES6中service的定义已经是class了，我们可以自行初始化它，没必要使用框架的inject。其次，它的所有依赖我们都可以直接使用mock的object，jasmine的<code>createSpyObj</code>可以创建一个mock的object，并且数组里指定的函数都自动被spy了，这也是我们为什么可以直接省略<code>spyOn()</code>调用的原因。可以看到，这个测试脱离了Angular框架本身，其次它没有真的引入真实的依赖，而是mock了它们，并且只mock自己需要的那部分函数（中括号里的部分）。这样，单元被彻底的隔离开了：</p>
<ul>
<li>即便以后这段代码用于非Angular框架了，测试依然有效。</li>
<li>就算其它的service的实现有问题，也不会影响这个测试。</li>
</ul>
<p>那有人要问了，我就是想要测A的时候发现A的依赖B有问题，好吧，那就从根本上违背了单元测试的初衷，不叫单元测试！关于<code>AjaxErrorHandlerService</code>的完整测试可以看<a href="https://github.com/PinkyJie/angular1-webpack-starter/blob/master/source/app/components/_common/services/ajax-error-handler.service.spec.js" target="_blank" rel="external">这里</a>。</p>
<p>还有一个例子也很常见，那就是我们常常需要测试<code>$rootScope.$on(xxx, xxx)</code>，也就是需要测试Angular里的事件响应。看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    $rootScope.$on(<span class="string">'$stateChangeSuccess'</span>, (event, toState) =&gt; &#123; ... &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们要测试这个<code>foo</code>函数的时候，我们很自然的想到可以调用<code>$rootScope.$broadcast(&#39;$stateChangeSuccess&#39;);</code>，这样就可以fire一个事件，foo函数里定义的事件回调就可以触发了。这样一来，又出现了需要依赖Angular框架的情况。其实，这种情况下我们依然可以杜绝这种依赖。回到测试本身，其实我们需要测试的是后面的回调函数，因为<code>$on</code>这个机制是由框架本身保证的，我们不应该去测这个机制，我们只要保证回调里的逻辑就好了。那么我们可以这么测：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">it (<span class="string">'should work'</span>, () =&gt; &#123;</div><div class="line">    foo();</div><div class="line">    <span class="comment">// 假设前面已经mock一个假的$rootScope</span></div><div class="line">    expect($rootScope.$on).toHaveBeenCalled();</div><div class="line">    expect($rootScope.$on.calls.argsFor(<span class="number">0</span>)[<span class="number">0</span>]).toBe(<span class="string">'$stateChangeSuccess'</span>);</div><div class="line">    <span class="keyword">const</span> callback = $rootScope.$on.calls.argsFor(<span class="number">0</span>)[<span class="number">1</span>];</div><div class="line">    callback(&#123;...&#125;, &#123;...&#125;);</div><div class="line">    <span class="comment">// expect logic in callback</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的测试并没有引入真正的<code>$rootScope</code>，它只验证<code>$on</code>被调用过（第4行），并且第一个参数是<code>$stateChangeSuccess</code>（第5行），然后通过jasmine的<code>argsFor(0)[1]</code>拿到callback（第6行），意思就是第1次调用时的第2个参数，显然，第2个参数就是我们要测的回调函数本身。拿到了回调函数，我们只要给定参数执行它，然后在expect里面的一些逻辑即可。在这个例子里，我们再次做到了关注分离，我们的关注点只放在了自己实现的回调上，而框架本身的事件机制我们选择忽略。</p>
<p>当然，有些情况下我们无法脱离Angular框架，必须要引入真实的service，我总结了一下大概有以下几种情况：</p>
<ul>
<li>测试directive时需要<code>$compile</code>和<code>$rootScope</code>：<ul>
<li>用<code>$compile</code>来编译含有directive的HTML代码。</li>
<li>用<code>$rootScope.$new()</code>来生成directive的scope（用于link函数里）。</li>
</ul>
</li>
<li>测含有HTTP请求的service时需要使用<code>$httpBackend</code>：使用<code>$httpBackend.expectXXX(xxx)</code>来模拟HTTP请求的返回。</li>
<li>测promise的时候需要<code>$q</code>和<code>$rootScope</code>：（下一节会详细讲到）<ul>
<li>使用<code>const deferred = $q.defer()</code>来生成一个deferred的对象，然后在需要promise的地方使用<code>deferred.promise</code>代替。</li>
<li>使用<code>$rootScope.$digest()</code>来使promise的结果生效。</li>
</ul>
</li>
</ul>
<h3 id="controller的测试里不要出现-httpBackend，测service时才需要它"><a href="#controller的测试里不要出现-httpBackend，测service时才需要它" class="headerlink" title="controller的测试里不要出现$httpBackend，测service时才需要它"></a>controller的测试里不要出现$httpBackend，测service时才需要它</h3><p>这是我一开头就提到的问题，我们来看下面这个controller和service：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// user.service.js</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerivce</span> </span>&#123;</div><div class="line">    login (email, password) &#123;</div><div class="line">        <span class="keyword">const</span> self = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">const</span> req = &#123;</div><div class="line">            email,</div><div class="line">            password</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$http.post(<span class="string">'api/user/login'</span>, req)</div><div class="line">            .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</div><div class="line">                <span class="keyword">const</span> data = response.data;</div><div class="line">                <span class="keyword">if</span> (response.status === <span class="number">200</span> &amp;&amp; data.code === <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> data.result.user;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> self.$q.reject(data.message);</div><div class="line">            &#125;)</div><div class="line">            .catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</div><div class="line">                <span class="keyword">return</span> self.$q.reject(reason);</div><div class="line">            &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// login.controller.js</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</div><div class="line">    login (credential) &#123;</div><div class="line">        <span class="keyword">this</span>.User.login(credential.email, credential.password)</div><div class="line">            .then(...)</div><div class="line">            .catch(...);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在测试这个controller时，很多文章直接这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$httpBackend.expectPOST(<span class="string">'api/user/login'</span>).respond(&#123;<span class="attr">code</span>: <span class="number">0</span>, <span class="attr">result</span>: &#123;<span class="attr">user</span>: <span class="string">'user'</span>&#125;&#125;);</div><div class="line">controller.login(...);</div><div class="line">$httpBackend.flush();</div><div class="line">expect(...) <span class="comment">// check logic in controller then branch</span></div></pre></td></tr></table></figure>
<p>然后到了测试service时，还是这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$httpBackend.expectPOST(<span class="string">'api/user/login'</span>).respond(&#123;<span class="attr">code</span>: <span class="number">0</span>, <span class="attr">result</span>: &#123;<span class="attr">user</span>: <span class="string">'user'</span>&#125;&#125;);</div><div class="line">UserService.login(...);</div><div class="line">$httpBackend.flush();</div><div class="line">expect(...) <span class="comment">// check logic in service then branch</span></div></pre></td></tr></table></figure>
<p>请问有什么区别吗？service这么写无可厚非，因为它依赖<code>$http</code>，所以测试的时候拿<code>$httpBackend</code>去mock是合理的，可是controller的直接依赖是service而不是<code>$http</code>，为什么也要这么mock呢？这就有点越俎代庖的意思，你不mock你的直接依赖，而是去mock你的依赖的依赖。显然，这不是一种好的隔离。</p>
<p>那么回到controller来说，它的直接依赖是<code>User.login</code>这个函数，那么我们只需要去mock这个函数就好，那么这个函数返回的是什么呢？没错，是一个promise。那么测controller的时候我们只需要去mock这个promise就好了，看下面的代码（变量定义已省略，完整的代码见<a href="https://github.com/PinkyJie/angular1-webpack-starter/blob/master/source/app/components/login-form/login-form.controller.spec.js" target="_blank" rel="external">这里</a>）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    angular.mock.inject(<span class="function">(<span class="params">_$q_, _$rootScope_</span>) =&gt;</span> &#123;</div><div class="line">        $q = _$q_;</div><div class="line">        $rootScope = _$rootScope_;</div><div class="line">        UserAPI = jasmine.createSpyObj(<span class="string">'UserAPI'</span>, [<span class="string">'login'</span>]);</div><div class="line">        controller = <span class="keyword">new</span> LoginController(UserAPI);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">describe(<span class="string">'login function'</span>, () =&gt; &#123;</div><div class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        deferred = $q.defer();</div><div class="line">        UserAPI.login.and.returnValue(deferred.promise);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    it(<span class="string">'should success'</span>, () =&gt; &#123;</div><div class="line">        deferred.resolve(...);</div><div class="line">        controller.login(...);</div><div class="line">        $rootScope.$digest();</div><div class="line">        expect(...) <span class="comment">// check logic in then branch</span></div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的测试中引入了真实的<code>$q</code>和<code>$rootScope</code>，这就是我们上一小节提到的测试promise时需要的。第12、13行我们使用<code>$q</code>构造一个promise对象，让mock后的login函数返回这个promise，然后在后面的测试中，我们直接控制这个promise是resolve还是reject即可（第17行）。注意，第19行的<code>$rootScope.$digest()</code>是框架本身的要求，我们需要这行代码让promise的结果生效。这样一来，controller的测试就与它背后的HTTP请求隔离开了，因为它只关心promise的resolve或reject，只有service才需要去关注HTTP的返回。</p>
<p>这里顺带一提，测试service的时候需要让<code>$httpBackend</code>模拟返回3个结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">apiResponse.respond(&#123;<span class="attr">code</span>: <span class="number">0</span>, <span class="attr">result</span>: &#123;<span class="attr">user</span>: <span class="string">'user'</span>&#125;&#125;);</div><div class="line">apiResponse.respond(&#123;<span class="attr">code</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">'error'</span>&#125;);</div><div class="line">apiResponse.respond(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">return</span> [<span class="number">500</span>];&#125;);</div></pre></td></tr></table></figure>
<p>这是基于测试覆盖率的考量，因为可以看到service的实现逻辑中，2xx的返回会进入then分支，非2xx的返回进入catch分支，而在then分支中手动执行<code>$q.reject()</code>也会进入catch分支。而测试controller时，因为它关心的只是promise，所以只需要模拟resolve和reject两种结果即可。</p>
<h3 id="让module-inject引入我们mock过的provider-service"><a href="#让module-inject引入我们mock过的provider-service" class="headerlink" title="让module/inject引入我们mock过的provider/service"></a>让module/inject引入我们mock过的provider/service</h3><p>有些情况下，我们必须使用inject来引入一些provider和service，比如在测试provider的时候，因为provider的初始化并不像controller或service那样可以直接new，它是由框架本身来初始化的，并且<code>.provider(&#39;RouterHelper&#39;, RouterHelperProvider)</code>的定义会同时得到一个<code>RouterHelperProvider</code>的provider和一个<code>RouterHelper</code>的service。所以在测provider的时候我们只能通过module来实现，但即便这样我们依然可以让module/inject加载我们已经mock过的provider和service。我们来看下面这个provider的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterHelperProvider</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> ($locationProvider, $stateProvider, $urlRouterProvider) &#123;</div><div class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;$locationProvider, $stateProvider, $urlRouterProvider&#125;);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.config = &#123;</div><div class="line">            <span class="attr">mainTitle</span>: <span class="string">''</span>,</div><div class="line">            <span class="attr">resolveAlways</span>: &#123;&#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">this</span>.$locationProvider.html5Mode(<span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    configure (cfg) &#123;</div><div class="line">        angular.extend(<span class="keyword">this</span>.config, cfg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $get ($rootScope, $state, Logger, Resolve) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RouterHelper(</div><div class="line">            <span class="keyword">this</span>.config, <span class="keyword">this</span>.$stateProvider, <span class="keyword">this</span>.$urlRouterProvider,</div><div class="line">            $rootScope, $state, Logger, Resolve);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">RouterHelperProvider.prototype.$get.$inject = [</div><div class="line">    <span class="string">'$rootScope'</span>, <span class="string">'$state'</span>, <span class="string">'Logger'</span>, <span class="string">'Resolve'</span></div><div class="line">];</div><div class="line"></div><div class="line">RouterHelperProvider.$inject = [<span class="string">'$locationProvider'</span>, <span class="string">'$stateProvider'</span>, <span class="string">'$urlRouterProvider'</span>];</div></pre></td></tr></table></figure>
<p>对于RouterHelperProvider和RouterHelper的依赖我们都需要来mock，要实现这一点其实我们只要<strong>在运行<code>angular.mock.module(&#39;xxx&#39;)</code>之前进行provider的mock</strong>即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> RouterHelperProvider <span class="keyword">from</span> <span class="string">'./router-helper.provider'</span>;</div><div class="line"></div><div class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    angular.module(<span class="string">'test'</span>, [])</div><div class="line">        .provider(<span class="string">'RouterHelper'</span>, RouterHelperProvider);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// function passed to module() does not get called until inject() does it's thing</span></div><div class="line">    angular.mock.module(<span class="function">(<span class="params">$provide</span>) =&gt;</span> &#123;</div><div class="line">        <span class="comment">// provider needs to be mocked before module load</span></div><div class="line">        $provide.provider(<span class="string">'$location'</span>, jasmine.createSpyObj(<span class="string">'$locationProvider'</span>, [<span class="string">'html5Mode'</span>, <span class="string">'$get'</span>]));</div><div class="line">        $provide.provider(<span class="string">'$urlRouter'</span>, jasmine.createSpyObj(<span class="string">'$urlRouterProvider'</span>, [<span class="string">'otherwise'</span>, <span class="string">'$get'</span>]));</div><div class="line">        $provide.provider(<span class="string">'$state'</span>, jasmine.createSpyObj(<span class="string">'$stateProvider'</span>, [<span class="string">'state'</span>, <span class="string">'$get'</span>]));</div><div class="line">        $provide.value(<span class="string">'$rootScope'</span>, jasmine.createSpyObj(<span class="string">'$rootScope'</span>, [<span class="string">'$on'</span>]));</div><div class="line">        $provide.value(<span class="string">'Logger'</span>, jasmine.createSpyObj(<span class="string">'Logger'</span>, [<span class="string">'warning'</span>]));</div><div class="line">        $provide.value(<span class="string">'Resolve'</span>, jasmine.createSpyObj(<span class="string">'Resolve'</span>, [<span class="string">'login'</span>]));</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    angular.mock.module(<span class="string">'test'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    angular.mock.module((_$locationProvider_, _$stateProvider_,</div><div class="line">        _$urlRouterProvider_, _RouterHelperProvider_) =&gt; &#123;</div><div class="line">        $locationProvider = _$locationProvider_;</div><div class="line">        $stateProvider = _$stateProvider_;</div><div class="line">        $stateProvider.$get.and.returnValue(jasmine.createSpyObj(<span class="string">'$get'</span>, [<span class="string">'get'</span>, <span class="string">'go'</span>]));</div><div class="line">        $urlRouterProvider = _$urlRouterProvider_;</div><div class="line">        provider = _RouterHelperProvider_;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    angular.mock.inject(<span class="function">(<span class="params">_$rootScope_, _$state_, _Logger_, _Resolve_</span>) =&gt;</span> &#123;</div><div class="line">        $rootScope = _$rootScope_;</div><div class="line">        $state = _$state_;</div><div class="line">        Logger = _Logger_;</div><div class="line">        Resolve = _Resolve_;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的测试包含5块beforeEach，每一块都有自己的分工：</p>
<ol>
<li>定义我们自己的provider，我们把它定义在自己的<code>test</code>module上而不是真实的module上，这样可以更好的隔离。</li>
<li>mock需要的各种provider，我们知道provider是带有<code>$get</code>函数的特殊的class，所以我们只需要保证mock后的provider包含<code>$get</code>及我们要用的其他函数即可。</li>
<li>加载这个<code>test</code>的module。</li>
<li>引入我们mock过的provider依赖，注意第30行有些特殊。我们的目标是mock<code>$state</code>这个service里的<code>get</code>和<code>go</code>函数，但这个<code>$state</code>service是我们mock的<code>$stateProvider</code>这个provider的<code>$get</code>函数生成的，所以我们需要直接mock这个<code>$get</code>的返回值，让其继续返回一个可以spy的object。如果我们不这样做，而是直接在inject函数里尝试<code>spyOn($state, &#39;get&#39;)</code>的话就会报错，因为这里的<code>$state</code>是没有<code>get</code>这个函数的。</li>
<li>引入我们mock过的service依赖。</li>
</ol>
<p>这样，所有的依赖虽然都是通过module/inject引入进来的，但是它依然是我们mock过的。这里的顺序值得注意，对于provider的mock必须在调用<code>angular.mock.module(&#39;test&#39;);</code>（第3个beforeEach块）之前，否则得到的就不是你mock过的provider，而是框架自带的provider。如果是第3方的provider如<code>$stateProvider</code>，如果放在module加载之后再mock，加载module时就会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Error: [$injector:modulerr] Failed to instantiate module test due to:</div><div class="line">Error: [$injector:unpr] Unknown provider: $stateProvider</div></pre></td></tr></table></figure>
<p>这是因为其实<code>$stateProvider</code>根本就不在<code>test</code>这个module里，我们必须在加载module之前mock它，所以必须保证自定义provider的其它provider依赖都mock好了才能初始化这个module。但是service的mock就不需要这么做，我们把第15-17行移动到第3个beforeEach后面也是可行的。</p>
<h3 id="其它小tip"><a href="#其它小tip" class="headerlink" title="其它小tip"></a>其它小tip</h3><p>最后讲一些单元测试里其它的小tip。</p>
<h4 id="整合jquey插件的directive的测试流程"><a href="#整合jquey插件的directive的测试流程" class="headerlink" title="整合jquey插件的directive的测试流程"></a>整合jquey插件的directive的测试流程</h4><p>我们先来看一个简单的directive，它的link函数里只做一件事，调用jquery插件的dropdown函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DropdownInitDirective</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'A'</span>,</div><div class="line">        link</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">link</span> (<span class="params">scope, element</span>) </span>&#123;</div><div class="line">        element.dropdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">DropdownInitDirective.$inject = [];</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> DropdownInitDirective;</div></pre></td></tr></table></figure>
<p>再来看看如何测试它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> DropdownInitDirective <span class="keyword">from</span> <span class="string">'./dropdown-init.directive'</span>;</div><div class="line"></div><div class="line">describe(<span class="string">'DropdownInit Directive'</span>, () =&gt; &#123;</div><div class="line">    <span class="keyword">let</span> scope;</div><div class="line"></div><div class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        angular.module(<span class="string">'test'</span>, [])</div><div class="line">            .directive(<span class="string">'aioDropdownInit'</span>, DropdownInitDirective);</div><div class="line">        angular.mock.module(<span class="string">'test'</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        angular.mock.inject(<span class="function">(<span class="params">$rootScope, $compile</span>) =&gt;</span> &#123;</div><div class="line">            scope = $rootScope.$<span class="keyword">new</span>();</div><div class="line">            spyOn($.fn, <span class="string">'dropdown'</span>).and.callThrough();</div><div class="line">            $compile(<span class="string">'&lt;a aio-dropdown-init&gt;&lt;/a&gt;'</span>)(scope);</div><div class="line">            scope.$digest();</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    it(<span class="string">'should call dropdown function when initialization'</span>, () =&gt; &#123;</div><div class="line">        expect($.fn.dropdown).toHaveBeenCalled();</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>directive的一般测试流程是：</p>
<ol>
<li>使用$rootScope来生成新的scope作为directive的scope（第14行）</li>
<li>使用$compile来编译HTML代码并绑定scope（第16行）</li>
<li>执行<code>scope.$diget()</code>使绑定的scope生效</li>
</ol>
<p>这里有一点特殊的地方就是第15行，实现代码里是调用的<code>element.dropdown</code>，但我们spy的却是jquery的<code>$.fn.dropdown</code>，这是因为element元素是$compile后才能返回的（第16行），而一旦返回，它的link函数就已经被立即调用了。所以，在第16行后去执行<code>spyOn(element, &#39;dropdown&#39;)</code>已经来不及，而在第16行之前执行呢，这时element还没有dropdown这个函数。所以对<code>$.fn</code>进行spy是一个折衷的方法，因为所有的jquey插件最终都是定义在<code>$.fn</code>上的。但是这么一来有些违反单元测试的原则，目前我也没想到更好的方案。</p>
<h4 id="将重复的测试代码重构成函数"><a href="#将重复的测试代码重构成函数" class="headerlink" title="将重复的测试代码重构成函数"></a>将重复的测试代码重构成函数</h4><p>这一点不用所说，将重用的代码提取出来是编程中最常见的重构。单元测试中也存在很多这样的重复代码，一个最常见的例子就是在测试service的时候，2xx和非2xx的返回都有可能进入reject分支，所以在验证reject分支逻辑的时候就需要写两次，这时就可以把这些重复的代码提出来变成函数。看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'login function'</span>, () =&gt; &#123;</div><div class="line">    <span class="keyword">let</span> apiResponse;</div><div class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        spyOn(User, <span class="string">'_setUser'</span>);</div><div class="line">        spyOn(User, <span class="string">'_clearUser'</span>);</div><div class="line">        apiResponse = $httpBackend.expectPOST(<span class="string">'api/user/login'</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">assertError</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            expect(User._setUser).not.toHaveBeenCalled();</div><div class="line">            expect($rootScope.$broadcast).not.toHaveBeenCalled();</div><div class="line">            expect($q.reject).toHaveBeenCalledWith(error);</div><div class="line">            expect(User._clearUser).toHaveBeenCalled();</div><div class="line">            expect(AjaxErrorHandler.catcher).toHaveBeenCalledWith(error);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    it(<span class="string">'should not login user when API returns error result'</span>, () =&gt; &#123;</div><div class="line">        apiResponse.respond(&#123;<span class="attr">code</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">'error'</span>&#125;);</div><div class="line">        User.login(<span class="string">'a'</span>, <span class="string">'b'</span>).catch(assertError(<span class="string">'error'</span>));</div><div class="line">        $httpBackend.flush();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    it(<span class="string">'should not login user when API returns 500'</span>, () =&gt; &#123;</div><div class="line">        apiResponse.respond(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> [<span class="number">500</span>];</div><div class="line">        &#125;);</div><div class="line">        User.login(<span class="string">'a'</span>, <span class="string">'b'</span>).catch(assertError(<span class="literal">null</span>));</div><div class="line">        $httpBackend.flush();</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h4><p>一旦开始写测试就一定要加入测试覆盖率的统计，它不光是一个“看自己到底写了百分之多少的测试”的提醒，更重要的是它绝壁是写测试的最大动力。想想游戏里的成就系统，有时为了拿100%物品搜集成就即便通关了也要重来一遍。单元测试里的覆盖率统计也有同样的作用，有的时候不为别的，就想看那个数字跑到100%。ES5中我们有<a href="https://github.com/karma-runner/karma-coverage" target="_blank" rel="external">karma-coverage</a>配合<a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="external">istanbul</a>，ES6中karma-coverage依然有效，但是我们需要<a href="https://github.com/douglasduteil/isparta" target="_blank" rel="external">isparta</a>——一个针对ES6的代码覆盖工具。你需要做的就是把它配置到karma的配置文件中，具体可以参考angular1-webpack-starter项目的<a href="https://github.com/PinkyJie/angular1-webpack-starter/blob/master/karma.config.js" target="_blank" rel="external">karma.conf.js</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端的单元测试越来越受到重视，网上也有很多讲解Angular中如何写好单元测试的文章，我自己在最近的&lt;a href=&quot;https://github.com/PinkyJie/angular1-webpack-starter&quot;&gt;angular1-webpack-starter&lt;/a&gt;项目中也写了很多单元测试。单元测试的一个核心理念就是对“单元”进行隔离，然后单独测试。可是网上的很多教程存在不少误区：比如在controller的测试中去使用$httpBackend，在引入第三方service的时候使用真实的service等等，说到底都是没有实现“关注分离”（Separation of Concerns），“单元”没有真正的被隔离。这篇文章就谈谈Angular的单元测试中如何更好的实现关注分离。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AngularJS" scheme="http://pinkyjie.com/tags/AngularJS/"/>
    
      <category term="ES6" scheme="http://pinkyjie.com/tags/ES6/"/>
    
      <category term="angular1-webpack-starter" scheme="http://pinkyjie.com/tags/angular1-webpack-starter/"/>
    
      <category term="单元测试" scheme="http://pinkyjie.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="关注分离" scheme="http://pinkyjie.com/tags/%E5%85%B3%E6%B3%A8%E5%88%86%E7%A6%BB/"/>
    
      <category term="jasmine" scheme="http://pinkyjie.com/tags/jasmine/"/>
    
      <category term="karma-coverage" scheme="http://pinkyjie.com/tags/karma-coverage/"/>
    
      <category term="isparta" scheme="http://pinkyjie.com/tags/isparta/"/>
    
  </entry>
  
  <entry>
    <title>ES6与Angular 1.x</title>
    <link href="http://pinkyjie.com/2016/02/11/angular-1-x-with-es6/"/>
    <id>http://pinkyjie.com/2016/02/11/angular-1-x-with-es6/</id>
    <published>2016-02-11T13:17:20.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6出来也很长时间了，把ES6应用在Angular 1.x的文章也不少，有了<code>class</code>这个语法糖Angular里的很多东西都可以写的比较规范了，但很多文章非要把Angular里的所有概念都写成class，这我就觉得没啥必要了。这篇文章就谈谈我自己在ES6和Angular 1.x上的一些实践。</p>
<a id="more"></a>
<h3 id="Angular中的那些概念放在ES6中怎么写"><a href="#Angular中的那些概念放在ES6中怎么写" class="headerlink" title="Angular中的那些概念放在ES6中怎么写"></a>Angular中的那些概念放在ES6中怎么写</h3><h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><p>controller的作用是把一些变量和函数绑定在<code>$scope</code>上，但controllerAs的出现，改变了controller对<code>$scope</code>的强依赖（除非需要绑定事件），使得变量和函数可以绑定在<code>this</code>上了（如果对controllerAs不熟悉的可以看<a href="2015/02/09/controller-as-vs-scope/">这篇文章</a>），这使得我们可以轻易的将controller写成class。一个controller肯定少不了依赖其他的service，在ES6中这些依赖自然是通过controller的构造函数传进来了。来看一个简单的例子（完整实现看<a href="https://github.com/PinkyJie/angular1-webpack-starter/blob/master/source/app/components/login-form/login-form.controller.js" target="_blank" rel="external">这里</a>）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginFormController</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (UserAPI, $state) &#123;</div><div class="line">        <span class="keyword">this</span>.UserAPI = UserAPI;</div><div class="line">        <span class="keyword">this</span>.$state = $state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    login (credential) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.loginForm.$invalid) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.UserAPI.login(credential.email, credential.password)</div><div class="line">            .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;)</div><div class="line">            .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到controller的构造函数首先要做的就是把这些service依赖全部挂在<code>this</code>上（line 3-4 ），这样一来，在别的函数中才能够使用这些service（line 11）。另外，ES6中的箭头函数也可以让我们写起匿名函数来更加的方便，不用每次都敲function这个关键字了（line 12-13）。从上面看，controller的定义就是一个普通的class，与Angular框架本身分开了，需要这个controller时直接调用<code>.controller(LoginFormController.name, LoginFormController)</code>即可。这给单元测试带来了非常大的方便，不用再去费劲mock一堆Angular自身的东西，只要单独的去测这个class即可。</p>
<p>另外还有一个问题也值得一说：代码压缩后参数改名导致依赖注入失效的情况。尽管有很多插件可以在build的时候自动做这个事，但我还是比较喜欢自己手写的。ES5中常用这样的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.controller(<span class="string">'LoginFormController'</span>, [<span class="string">'UserAPI'</span>, <span class="string">'$state'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">UserAPI, $state</span>) </span>&#123;&#125;])</div></pre></td></tr></table></figure>
<p>这种称为“inline array annotation”的写法将controller的定义与实现绑在一起，直接套用在class定义上显得不太合适。我们需要将controller的依赖直接反映在controller的class定义上，这就需要<code>$inject</code>出马了。看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LoginFormController.$inject = [<span class="string">'UserAPI'</span>, <span class="string">'$state'</span>];</div></pre></td></tr></table></figure>
<p>我们可以直接把这句话写在class定义的下面，一目了然。关于<code>$inject</code>，可以看<a href="https://docs.angularjs.org/guide/di#-inject-property-annotation" target="_blank" rel="external">官方文档</a>里的讲解。</p>
<h4 id="service-factory"><a href="#service-factory" class="headerlink" title="service/factory"></a>service/factory</h4><p>service就是天生的class，在ES5中我们也是直接把它作为构造函数来进行类比的。service的写法与上面的controller是类似的，看这个例子（完整实现看<a href="https://github.com/PinkyJie/angular1-webpack-starter/blob/master/source/app/pages/phone/phone.service.js" target="_blank" rel="external">这里</a>）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneService</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> ($http, $q, AjaxError) &#123;</div><div class="line">        <span class="keyword">this</span>.$http = $http;</div><div class="line">        <span class="keyword">this</span>.$q = $q;</div><div class="line">        <span class="keyword">this</span>.AjaxError = AjaxError;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getPhones () &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getPhoneDetail (id) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addNewPhone (phone) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    updatePhone (id, phone) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    removePhone (id) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">PhoneService.$inject = [<span class="string">'$http'</span>, <span class="string">'$q'</span>, <span class="string">'AjaxErrorHandler'</span>];</div></pre></td></tr></table></figure>
<p>和controller的套路是完全一致的。说完了service来说说factory，我们知道factory和service的区别就是它的定义需要返回一个对象。如果拿构造函数来类比service的话，那么factory就是一个需要返回一个普通对象的函数，也就是说，在真正实例化的时候，内部是类似这样的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = factoryA();</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> serviceB()</div></pre></td></tr></table></figure>
<p>从这个意义上来讲，factory它本质上就不是一个类，虽然有很多文章用一些根本不直观的方法在ES6中把factory封装成class，我认为是根本没必要的。更进一步讲，我认为没必要使用factory，我没有觉得哪个场景是必须使用factory而不能使用service的，两者在除了定义时的方式不同，使用起来没有任何的区别。所以我个人的建议是在ES6中统统使用service。</p>
<h4 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h4><p>provider与service的区别是，它有一个<code>$get()</code>函数，这个函数会返回一个service的实例（即<code>new serviceB()</code>过后的实例）。除此之外，它还提供一些函数用来配置这个返回的service。显然，它也是一个class，一个必须带有<code>$get()</code>方法的class。我们来看一个provider的例子（完整实现看<a href="https://github.com/PinkyJie/angular1-webpack-starter/blob/master/source/app/components/_common/services/router-helper.provider.js" target="_blank" rel="external">这里</a>）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterHelperProvider</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> ($locationProvider, $stateProvider, $urlRouterProvider) &#123;</div><div class="line">        <span class="keyword">this</span>.$locationProvider = $locationProvider;</div><div class="line">        <span class="keyword">this</span>.$stateProvider = $stateProvider;</div><div class="line">        <span class="keyword">this</span>.$urlRouterProvider = $urlRouterProvider;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.config = &#123;</div><div class="line">            <span class="attr">mainTitle</span>: <span class="string">''</span>,</div><div class="line">            <span class="attr">resolveAlways</span>: &#123;&#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">this</span>.$locationProvider.html5Mode(<span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    configure (cfg) &#123;</div><div class="line">        angular.extend(<span class="keyword">this</span>.config, cfg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $get ($rootScope, $state, Logger, Resolve) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RouterHelper(</div><div class="line">            <span class="keyword">this</span>.config, <span class="keyword">this</span>.$stateProvider, <span class="keyword">this</span>.$urlRouterProvider,</div><div class="line">            $rootScope, $state, Logger, Resolve);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">RouterHelperProvider.prototype.$get.$inject = [</div><div class="line">    <span class="string">'$rootScope'</span>, <span class="string">'$state'</span>, <span class="string">'Logger'</span>, <span class="string">'Resolve'</span></div><div class="line">];</div><div class="line"></div><div class="line">RouterHelperProvider.$inject = [<span class="string">'$locationProvider'</span>, <span class="string">'$stateProvider'</span>, <span class="string">'$urlRouterProvider'</span>];</div></pre></td></tr></table></figure>
<p>这时一个典型的provider的实现：</p>
<ul>
<li>它依赖其他三个provider，通过构造函数传入。</li>
<li>它内部有一个<code>config</code>对象用来存储一些配置。</li>
<li>它有一个<code>configure()</code>函数暴露给外面，这样在app的config阶段可以传入object进行配置。</li>
<li>它有一个<code>$get()</code>函数，这个函数返回一个实例，这个实例是由另一个称为<code>RouterHelper</code>的class定义好的，并且在初始化这个实例的时候，将自己的config对象传入，这样config对象就可以应用在实例化后的结果上了。</li>
</ul>
<p>同样我们要使用<code>$inject</code>来处理依赖注入的问题，但这里有一点不一样的地方，对于<code>$get()</code>函数我们也要处理依赖注入，因为真正返回的service实例的依赖是通过这里传入的，而不是通过<code>RouterHelper</code>这个class定义时候注入的，所以在第25行我们需要使用<code>prototype.$get</code>去拿到这个函数，然后定义上面的<code>$inject</code>属性。然后在定义<code>RouterHelper</code>这个class时我们不需要进行依赖注入，因为它的构造函数里的参数都是<code>$get()</code>函数里传给它的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterHelper</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (config, $stateProvider, $urlRouterProvider,</div><div class="line">        $rootScope, $state, Logger, Resolve) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进一步，这个class根本没必要暴露给外面，因为Angular框架到时调用的是provider里的<code>$get()</code>来生成这个实例的，而不是直接调用这个class，我们只需要将provider的定义暴露给外面即可，最终在定义这个provider时只需要调用<code>.provider(&#39;RouterHelper&#39;, RouterHelperProvider)</code>。这样一句，我们便同时拥有了<code>RouterHelperProvider</code>这个provider和<code>RouterHelper</code>这个service，两者分别在config阶段和run阶段进行注入，这是由Angular框架自己来保证的。</p>
<h4 id="directive"><a href="#directive" class="headerlink" title="directive"></a>directive</h4><p>directive是返回一个键值对配置的函数，显然，它也不是一个class，同样没必要花心思把它封装成class。来看一个例子（完整实现看<a href="https://github.com/PinkyJie/angular1-webpack-starter/blob/master/source/app/components/phone-form/phone-form.directive.js" target="_blank" rel="external">这里</a>）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> PhoneFormController <span class="keyword">from</span> <span class="string">'./phone-form.controller'</span>;</div><div class="line"><span class="keyword">import</span> phoneFormHtml <span class="keyword">from</span> <span class="string">'./phone-form.jade'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PhoneFormDirective</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'AE'</span>,</div><div class="line">        <span class="attr">scope</span>: &#123;&#125;,</div><div class="line">        <span class="attr">controller</span>: PhoneFormController.name,</div><div class="line">        <span class="attr">controllerAs</span>: <span class="string">'form'</span>,</div><div class="line">        <span class="attr">bindToController</span>: &#123;</div><div class="line">            <span class="attr">phone</span>: <span class="string">'='</span>,</div><div class="line">            <span class="attr">state</span>: <span class="string">'@'</span>,</div><div class="line">            <span class="attr">submit</span>: <span class="string">'&amp;'</span>,</div><div class="line">            <span class="attr">cancel</span>: <span class="string">'&amp;'</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">template</span>: phoneFormHtml</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>directive里的逻辑可以放在它的controller里实现，可以看到它也是支持controllerAs语法的。注意这里的<code>bindToController</code>选项，它是1.3引入的用来解决<a href="http://blog.thoughtram.io/angularjs/2015/01/02/exploring-angular-1.3-bindToController.html" target="_blank" rel="external">传入<code>=</code>绑定时属性不更新的问题</a>。很多人对它的认识是传一个true即可，其实从1.4开始它是支持传入一个对象的，这个对象和传给<code>scope</code>配置的对象是一样的，用来指定directive的属性是什么绑定的。这样，<code>scope: {}</code>配置只需要传空就可以。这样的写法更加直观，因为这些属性本来就是绑定在controller的<code>this</code>上的，而不是<code>scope</code>上，这样写更有意义。</p>
<p>当然，如果使用link而不使用controller的话，可以看这个例子（完整实现看<a href="https://github.com/PinkyJie/angular1-webpack-starter/blob/master/source/app/components/_common/directives/datepicker-init.directive.js" target="_blank" rel="external">这里</a>）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DatepickerInitDirective</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">require</span>: <span class="string">'ngModel'</span>,</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'A'</span>,</div><div class="line">        link</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">link</span> (<span class="params">scope, element, attrs, ngModelCtrl</span>) </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">DatepickerInitDirective.$inject = [];</div></pre></td></tr></table></figure>
<p>注意这种情况下需要处理依赖注入，而使用controller的话，依赖注入在controller上解决即可。另外，这里的第5行使用的是ES6中的新语法，即如果对象的key和value名字一样的话，可以使用只写key的简写形式。</p>
<h3 id="ES6的小tip"><a href="#ES6的小tip" class="headerlink" title="ES6的小tip"></a>ES6的小tip</h3><p>最后讲一些写ES6时的tip，有些问题可能在ES5中不是问题，但ES6中反而成了闹心的问题了。</p>
<h4 id="闹心的构造函数参数赋值"><a href="#闹心的构造函数参数赋值" class="headerlink" title="闹心的构造函数参数赋值"></a>闹心的构造函数参数赋值</h4><p>可以看到，上面所有class定义的构造函数中，第一步都是要将传入的参数全部赋值到<code>this</code>上来。既然这是一种必需，那有没有简单的方法来处理这种繁琐的写法呢？答案是肯定有的哇！那就是ES6中新引入的<code>Object.assign</code>方法，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// method 1</span></div><div class="line"><span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;UserAPI, $state&#125;);</div><div class="line"><span class="comment">// method 2</span></div><div class="line"><span class="keyword">this</span>.UserAPI = UserAPI;</div><div class="line"><span class="keyword">this</span>.$state = $state;</div></pre></td></tr></table></figure>
<p>上面两种写法是等价的。<code>Object.assign</code>会把第二个参数传入的对象属性赋值在第一个参数上。另外，这里同样使用了上面提到的object简写方法，因为key和value是一样的。</p>
<h4 id="能用const就用const"><a href="#能用const就用const" class="headerlink" title="能用const就用const"></a>能用const就用const</h4><p>ES6中引入了<code>let</code>和<code>const</code>关键字来定义变量和常量，根据个人经验，90%以上的变量定义其实都是常量。这里的常量说的是变量本身，比如一个object是常量，你照样是可以修改这个object上面的属性的。</p>
<h4 id="this不是万能的"><a href="#this不是万能的" class="headerlink" title="this不是万能的"></a>this不是万能的</h4><p>箭头函数可以保持上下文this不变，这样可以让我们少写很多<code>const self = this;</code>这样的语句。但注意，只有箭头函数能达到这样的效果，在很多别的地方还是需要把this赋值留到后面待用的。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerivce</span> </span>&#123;</div><div class="line"></div><div class="line">    getProductSummary () &#123;</div><div class="line">        <span class="keyword">const</span> self = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$http.get(<span class="string">'api/user/products'</span>)</div><div class="line">            .then(_success)</div><div class="line">            .catch(<span class="keyword">this</span>.AjaxError.catcher.bind(<span class="keyword">this</span>.AjaxError));</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> _success (<span class="params">response</span>) </span>&#123;</div><div class="line">            <span class="keyword">const</span> data = response.data;</div><div class="line">            <span class="keyword">if</span> (response.status === <span class="number">200</span> &amp;&amp; data.code === <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> data.result.summary;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> self.$q.reject(data.message);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在class的一个方法中定义函数，这里的this是无法保持的。所以在方法中调用函数需要传入其他函数时，要么通过提前保存this这种做法，要么就要使用bind函数来手动的改变context。</p>
<h4 id="私有变量-函数的实现"><a href="#私有变量-函数的实现" class="headerlink" title="私有变量/函数的实现"></a>私有变量/函数的实现</h4><p>ES6的语法中并没有给出私有变量或函数的实现，没有了private关键字，class里不同方法需要共享变量就必须把变量绑定在this上，而一旦绑在this上，外部就可以访问，这还是有些不便的。一种很自然的想法是，把不想让外部访问的变量和函数写在class外：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _foo;</div><div class="line"><span class="function"><span class="keyword">function</span> _bar (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> ClassA;</div></pre></td></tr></table></figure>
<p>上面的变量<code>_foo</code>和函数<code>_bar()</code>只有本文件里的<code>ClassA</code>才能访问的到，由于export出去的只是<code>ClassA</code>，外部是没法访问到这两个东西的，这在一定程度上实现了私有。当然，这种实现显得有些强求，不太面向对象。</p>
<p>另一种方法就是借助ES6中的<code>Symbol()</code>函数，<code>Symbol()</code>函数会生成一个唯一的随机字符串，我们可以用这个随机字符串来当做私有变量和私有函数的名字。看这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [foo, bar] = [<span class="built_in">Symbol</span>(), <span class="built_in">Symbol</span>()];</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> () &#123;</div><div class="line">        <span class="keyword">this</span>[foo] = <span class="string">'aaa'</span>;</div><div class="line">        <span class="keyword">this</span>[bar] = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> ClassA;</div></pre></td></tr></table></figure>
<p>注意第一行使用了ES6中的“赋值展开”。可以看到，变量<code>foo</code>和<code>bar</code>虽然都定义在this上，但由于外部（本文件以外）都不知道这两个变量代表的字符串是什么，所以外部是无法访问的。这相当于，外部根本不知道私有变量和私有函数的变量名和函数名，自然无法访问的到了，这种实现方法更加面向对象一点。</p>
<h4 id="使用ESLint"><a href="#使用ESLint" class="headerlink" title="使用ESLint"></a>使用ESLint</h4><p>在ES5阶段我们有JSHint和JSCS来进行静态检查和规范代码风格，但两者对于ES6的支持都不是那么的完善。而<a href="http://eslint.org/" target="_blank" rel="external">ESLint</a>对ES6的支持非常完善，你甚至可以指定只用ES6的代码风格来写（比如只使用<code>let</code>和<code>const</code>而不使用<code>var</code>）。很多编辑器都有ESLint的<a href="http://eslint.org/docs/user-guide/integrations" target="_blank" rel="external">插件</a>，可以在书写的时候就进行检查和警告。ESLint有<a href="http://eslint.org/docs/rules/" target="_blank" rel="external">非常多的Rule</a>可供使用，基本可以涵盖JSHint和JSCS的所有规范。如果你觉得ESLint的Rule比较多，不知道每个都干啥用的，那么我有一个方法：把所有Rule都打开，按自己的风格写代码，一旦你的风格和Rule冲突就会报错，这个时候你再选择是否关掉这个Rule。ESLint可以帮助我们做很多静态检查，比如上面提到的const的问题，一旦ESLint发现你定义了一个<code>let</code>变量但没有改变其值，就会提示你将<code>let</code>改成<code>const</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6出来也很长时间了，把ES6应用在Angular 1.x的文章也不少，有了&lt;code&gt;class&lt;/code&gt;这个语法糖Angular里的很多东西都可以写的比较规范了，但很多文章非要把Angular里的所有概念都写成class，这我就觉得没啥必要了。这篇文章就谈谈我自己在ES6和Angular 1.x上的一些实践。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AngularJS" scheme="http://pinkyjie.com/tags/AngularJS/"/>
    
      <category term="ES6" scheme="http://pinkyjie.com/tags/ES6/"/>
    
      <category term="angular1-webpack-starter" scheme="http://pinkyjie.com/tags/angular1-webpack-starter/"/>
    
      <category term="ESLint" scheme="http://pinkyjie.com/tags/ESLint/"/>
    
  </entry>
  
  <entry>
    <title>用Angular 1.x做组件式开发</title>
    <link href="http://pinkyjie.com/2016/01/31/component-based-development-with-angular-1x/"/>
    <id>http://pinkyjie.com/2016/01/31/component-based-development-with-angular-1x/</id>
    <published>2016-01-31T07:51:58.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>自打去年参加了JSConf后一直断断续续看了很多React的资料，不得不承认React确实在很多方面给人耳目一新的感觉，尤其是组件化的思想给我留下了很深的印象。JSX的语法虽然一开始很难让人接受，但React将函数式编程的思维用在组件化上，确实值得借鉴。作为一个Angular死忠粉，自然很想把这种好的思维方式也用在Angular上了，于是就有了<a href="https://github.com/PinkyJie/angular1-webpack-starter" target="_blank" rel="external">angular1-webpack-starter</a>这个项目。这篇文章就来记录下用Angular来做纯组件式开发的一些尝试吧。</p>
<a id="more"></a>
<h3 id="文件夹结构"><a href="#文件夹结构" class="headerlink" title="文件夹结构"></a>文件夹结构</h3><p>文件夹结构怎么安排是每次新开一个项目必定要纠结的问题，社区在这个问题也有过很多思考，比如最初的按照文件类型划分，到后来按照feature来划分。</p>
<figure class="highlight bash"><figcaption><span>按文件类型区分文件夹</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">app/</div><div class="line">-- controllers/</div><div class="line">---- homeController.js</div><div class="line">---- loginController.js</div><div class="line">-- services/</div><div class="line">---- userService.js</div><div class="line">-- directives/</div><div class="line">---- inputDirective.js</div><div class="line">-- other/</div><div class="line">---- xxx.js</div><div class="line">-- app.js</div><div class="line">-- routes.js</div><div class="line">images/</div><div class="line">-- xxx.png</div><div class="line">-- ...</div><div class="line">styles/</div><div class="line">-- xxx.css</div><div class="line">-- ...</div><div class="line">views/</div><div class="line">-- index.html</div><div class="line">-- ...</div></pre></td></tr></table></figure>
<figure class="highlight bash"><figcaption><span>按feature区分文件夹</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">app/</div><div class="line">-- core/</div><div class="line">---- userService.js</div><div class="line">---- inputDirective.js</div><div class="line">-- home/</div><div class="line">---- homeController.js</div><div class="line">---- homeRoute.js</div><div class="line">---- home.html</div><div class="line">---- home.css</div><div class="line">-- login/</div><div class="line">---- loginController.js</div><div class="line">---- loginRoute.js</div><div class="line">---- login.html</div><div class="line">---- login.css</div><div class="line">-- app.js</div><div class="line">assets/</div><div class="line">---- images/</div></pre></td></tr></table></figure>
<p>为什么文件夹结构让人如此纠结？一个好的文件夹结构可以迅速让开发者明白项目的整体结构！更重要的是，在实际开发的过程中，好的文件夹结构可以迅速的让开发者将实际页面与页面对应的源文件对应起来，这可以极大的提高开发效率。从这个评判标准出发，我们可以发现最初的“按文件类型区分”显得稍显粗暴。项目小还好，一旦项目大起来，很难快速的找到与某个页面对应的相应源文件。并且，一个页面是由JS、CSS、HTML共同组成的，那么我要改一个页面，就需要从3个文件夹里找，稍显低效。一旦项目大了，参加项目的人一多，文件命名一乱，找起文件来非常繁琐。为了解决这个痛点，社区又提出了第二种方法：按feature来区分，将属于同一feature（一般是一个页面或一组页面）的JS、CSS、HTML放在一起，将公用的文件放在单独的文件夹里。这样一来，结构分明，而且找起文件来也相对轻松。所以，目前这种文件夹结构及类似的衍生成为社区的主流。但这种结构是否真的适合组件式开发呢？通常一个feature（页面）是由多个组件组成的，显然组件的粒度要比feature细的多。一种直接的想法就是我们将feature层级直接替换成组件，按组件区分文件夹，但这样一来，页面与组件的关系又很难从文件夹结构中反映出来。所以，我们需要这样一种新的文件夹组织方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">app/</div><div class="line">-- components/</div><div class="line">---- _core/</div><div class="line">---- _layout/</div><div class="line">---- home-hero/</div><div class="line">---- login-form/</div><div class="line">-- pages/</div><div class="line">---- home/</div><div class="line">---- login/</div><div class="line">index.html</div><div class="line">index.js</div></pre></td></tr></table></figure>
<p>整个结构分为pages和components，一目了然，属于一个组件的资源放在一起，而页面只是将这些组件“组合”起来。这个新的组织方式可以说就是为组件化而生，开发者一看就知道是怎么回事。关于这种文件夹结构的详细解释，可以参看<a href="https://github.com/fouber/blog/issues/10" target="_blank" rel="external">这篇文章</a>。</p>
<h3 id="用函数式思维实现组件"><a href="#用函数式思维实现组件" class="headerlink" title="用函数式思维实现组件"></a>用函数式思维实现组件</h3><p>有了文件夹结构，剩下的就是如何实现组件和页面了。React的一大思想就是将函数式编程的思维引入到组件开发上来：<code>UI = f(states)</code> 一个组件就是一个函数。函数有三个要素：输入参数，实现逻辑和返回值。对应到组件上来说，这三要素就变成：</p>
<ul>
<li>输入参数<code>states</code> =&gt; 将组件渲染到页面上需要的数据，使用这个组件（模仿函数的概念可以称之为“调用者”）需要将数据源传入组件。</li>
<li>实现逻辑<code>f()</code> =&gt; 组件内部的交互逻辑。</li>
<li>返回值<code>UI</code> =&gt; 组件渲染后的页面。</li>
</ul>
<p>具体到Angular框架上来讲，组件有其对应的概念——<code>directive</code>，那么我们就来看看这三个要素要怎么应用到directive上来。我们来思考一个具体的例子，比如我们有一个<code>phone-form</code>的表单组件，它允许用户查看、编辑、新增一款手机的型号、品牌、价格、系统等参数，如下图所示。</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/component-based-development-with-angular-1x-1.PNG" class="center-img" title="图1">
<p>为了让一个组件具备这三种功能，那么它的输入参数需要点什么呢？</p>
<ul>
<li><code>state</code>变量，指明当前表单处于什么状态：查看、编辑还是新增。</li>
<li><code>phone</code>变量，充当传入的model，在查看和编辑状态下需传入当前的phone，新增状态下传空。</li>
<li><code>cancel()</code>函数和<code>submit()</code>函数，作为组件本身它不知道这两个button需要干什么，需要外部调用者来告诉组件。</li>
</ul>
<p>关于参数的传入，directive上又有很多讲究了。首先，为了让我们的directive尽可能的通用和可重用，必须使用独立的scope（<a href="https://docs.angularjs.org/guide/directive#isolating-the-scope-of-a-directive" target="_blank" rel="external">isolate  scope</a>），也就是定义directive的时候使用<code>scope: {}</code>配置。独立scope可以让directive的scope脱离当前的父scope（这里称为父scope并不是说独立scope派生自它，而是说DOM树关系），防止不小心对父scope的数据进行更改。确立了使用独立scope，我们还需要思考使用哪种绑定方式来传值。Angular提供了<code>=</code>、<code>@</code>、<code>&amp;</code>三种方式，关于三者的区别可以参见StackOverflow上的<a href="http://stackoverflow.com/questions/14050195/angularjs-what-is-the-difference-between-and-in-directive-scope" target="_blank" rel="external">这个回答</a>，这里简单解释一下：</p>
<ul>
<li><code>=</code>: 双向绑定，建立起父scope和directive独立scope的双向联系，如果directive中需要更改传入的变量，并且这个更改要传回父scope，则使用这种绑定。</li>
<li><code>@</code>: 字符串绑定，它是将父scope的字符串传入独立scope，比如<code>aaa=&quot;bbb&quot;</code>则传入bbb这个字面字符串，`aaa={{bbb}}`则传入bbb变量在父scope上的值，总之它的结果是字符串。很多地方将其解释为单向绑定是不对的，因为它只能绑定字符串。</li>
<li><code>&amp;</code>: 表达式绑定，简单来说就是将传入的表达式在父scope上执行，一般用于传入函数表达式，它将一个函数绑定在独立scope上。也可以将<code>&amp;</code>用于单向绑定，如<code>aaa=bbb</code>则会将一个<code>aaa()</code>函数绑定在独立scope上，它的返回值是父scope上的bbb属性值（相当于一个getter函数），但aaa()函数返回的仅仅是初始化directive时计算得到的bbb的值，后续父scope对bbb的更改不会反应到独立scope上。</li>
</ul>
<p>具体到我们的例子上，<code>state</code>变量只是告诉当前组件应处于<code>view/edit/new</code>三种状态中的哪一种，完全可以使用<code>@</code>绑定。而<code>phone</code>变量仅需要将phone从父scope传入directive的scope，directive里对phone的更改不需要传回父scope，所以是单向绑定，可以使用<code>&amp;</code>。最后，两个函数自然是使用<code>&amp;</code>绑定了。从“输入参数”这个层面上来看，一旦要“调用”某个组件，你就必须负责提供这个组件需要的各种数据，这些数据有些可能必须通过异步请求才能拿到。所以在将组件组合成页面时，这些数据一般由页面的controller准备好然后传递给组件。</p>
<p>说完了“输入参数”，来说说后两项。“实现逻辑”自然是放在directive的controller里实现了（用于UI组件时建议不要使用link函数，使用controller在语义上更好），看似没啥可说的，但其实这一块也有很多讲究。函数式编程中一个重要的概念就是“纯函数”（<a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="external">pure function</a>）。简单的说，就是纯函数不会产生很多副作用，比如说它不能更改传入的参数本身，它不能依赖一些全局变量，不能有异步的HTTP请求或DB请求。举个例子，JS中操作数组的<code>slice</code>和<code>splice</code>，前者就是个纯函数，而后者不是，因为它会改变调用者本身。那么把这种理念用在组件开发上，就要求组件在自己的controller实现逻辑中，要注意一下几点：</p>
<ol>
<li>即便采用<code>=</code>绑定了也不能直接修改传入的值，否则就会影响父scope的值，函数不纯了，或者干脆永远不要使用<code>=</code>绑定。</li>
<li>不能有异步的HTTP调用，意味着组件不能调用service进行HTTP请求。</li>
<li>想要改变数据，只能fire事件。</li>
</ol>
<p>所以，组件里如果需要改变model的值就需要fire一个change事件，service里响应事件后更新model，然后fire一个update事件，父scope响应这个事件，再更新自己的model。这也正是<a href="https://facebook.github.io/flux/" target="_blank" rel="external">Flux架构</a>提出的原因，没有了副作用，整个程序的状态改变就变得可控，出现问题后也比较好追溯。当然，它也确实增加了编写程序的复杂度，是否需要全盘应用它还是视具体的项目而定了。</p>
<p>最后，“返回值”这项就不用说了，直接在HTML里“调用”这个组件即可，组件就可以渲染到最终的页面上去了。</p>
<blockquote>
<p>（整个组件的具体实现可以<a href="https://github.com/PinkyJie/angular1-webpack-starter/tree/master/source/app/components/phone-form" target="_blank" rel="external">参见Github</a>，值得一提的是，实际项目中<code>phone-form</code>组件上phone的绑定并没有使用<code>&amp;</code>，而是使用了<code>=</code>，因为父scope中的phone是异步service得到的，初始化directive时得到的phone是空值。）</p>
</blockquote>
<h3 id="将组件“组合”成页面"><a href="#将组件“组合”成页面" class="headerlink" title="将组件“组合”成页面"></a>将组件“组合”成页面</h3><p>采用上述的文件夹结构后，一个很自然的想法是：我们可以模拟node的commonJS模块那样，每个component文件夹有一个<code>index.js</code>来将这个组件的各个资源粘合在一起（需配合Webpack），然后将component这个模块暴露出去。来看看上面的<code>phone-form</code>这个组件的<code>index.js</code>的实现（采用ES6）：</p>
<figure class="highlight javascript"><figcaption><span>index.js for phone-form component</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> angular <span class="keyword">from</span> <span class="string">'angular'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> PhoneFormController <span class="keyword">from</span> <span class="string">'./phone-form.controller'</span>;</div><div class="line"><span class="keyword">import</span> PhoneFromDirective <span class="keyword">from</span> <span class="string">'./phone-form.directive'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> phoneForm = angular.module(<span class="string">'app.components.phoneForm'</span>, [])</div><div class="line">    .controller(PhoneFormController.name, PhoneFormController)</div><div class="line">    .directive(<span class="string">`aioPhoneForm`</span>, PhoneFromDirective);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> phoneForm;</div></pre></td></tr></table></figure>
<p>那么在phone-detail页面我们需要“调用”这个component时怎么写呢？同样，每个page文件夹里也有一个<code>index.js</code>来将这个页面需要的各个组件引用进来，然后将这个页面暴露出去给整个程序的入口<code>index.js</code>来引用。来看看<code>phone-detail</code>这个页面的<code>index.js</code>的实现（采用ES6）：</p>
<figure class="highlight javascript"><figcaption><span>index.js for phone-detail component</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> angular <span class="keyword">from</span> <span class="string">'angular'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> PhoneDetailController <span class="keyword">from</span> <span class="string">'./detail/phone-detail.controller'</span>;</div><div class="line"><span class="keyword">import</span> phoneForm <span class="keyword">from</span> <span class="string">'../../components/phone-form'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> angular.module(<span class="string">'app.pages.phone-detail'</span>, [</div><div class="line">    phoneForm.name</div><div class="line">])</div><div class="line">    .controller(PhoneDetailController.name, PhoneDetailController)</div></pre></td></tr></table></figure>
<p>可以看到，页面只需要将组件所在的Angular module声明为依赖就可以了。这样在页面的HTML中就可以直接使用这个组件了：</p>

undefined


<p>注意上面在传递<code>submit</code>的时候，参数<code>phone</code>有些奇怪，它没有挂在<code>vm</code>下，说明它不是父scope上的变量，那这个传递进去的phone是什么呢？要解决这个疑问，我们就要来分析分析组件间的通信了。</p>
<h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><p>说到组件间通信，我们可以简单的分为：</p>
<ul>
<li>外部向组件内传递数据（父scope =&gt; directive）</li>
<li>组件向外部传递数据（directive =&gt; 父scope）</li>
<li>组件与组件间传递数据（directive A &lt;=&gt; directive B）</li>
</ul>
<p>显然，我们还是可以像Angular中不同controller间的通信方法一样，使用service作为中间层来交换数据，或者使用事件来传递，这两种方法在此不再赘述。我们来看看其他两种方式。</p>
<h4 id="通过属性传参（即前面提到的“输入参数”）"><a href="#通过属性传参（即前面提到的“输入参数”）" class="headerlink" title="通过属性传参（即前面提到的“输入参数”）"></a>通过属性传参（即前面提到的“输入参数”）</h4><p>前面有讲到，父scope给directive的独立scope传参时有三种绑定方式，采用<code>=</code>绑定时可以在父scope和独立scope之间建立双向通信，<code>@</code>只是单向的向directive中传递字符串。<code>&amp;</code>就比较有意思了，一方面，前面讲过，它可以实现单向绑定，将一个getter函数绑定在directive的独立scope上，这相当于将父scope的变量单向传递给独立scope。另一方面，它允许directive调用外部定义好的函数，通过这个函数我们其实可以<strong>将directive的独立scope里的变量传递给父scope</strong>。我们回到上部分最后提到的问题，使用<code>submit=&quot;vm.updatePhone(phone)&quot;</code>传入函数时，这里的phone其实并不是父scope的变量（其实也没必要显式的传入父scope的变量，因为这个函数定义在父scope上，里面你是可以任意访问父scope的变量和其他函数的），它只是一个<strong>形参</strong>，而这个形参的具体值可以由directive中调用时来填充。有了这个形参，我们就可以在directive的controller中将独立scope上的变量传递给父scope的函数调用。但注意在directive中的controller调用submit方法时，也需要采取特殊的语法：<code>this.submit({phone: phoneData})</code>，我们需要传入一个object，key就是形参名，value就是我们要传入的真正值。通过这么两种<code>&amp;</code>的不同用法我们可以看到，<code>&amp;</code>是可以用来建立双向通信的，下面这个小demo能帮助你更好的理解这种双向通信：</p>
<p><a class="jsbin-embed" href="http://jsbin.com/xucexi/embed?html,js,console" target="_blank" rel="external">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.9"></script></p>
<p>上面的代码中，属性<code>getVar</code>和<code>func</code>采用的都是<code>&amp;</code>绑定，属性<code>getVar</code>将一个getter函数绑定到directive上，directive通过这个函数获得从父scope单向传递过来的变量，而属性<code>func</code>将另一个函数绑定到directive上，directive通过这个函数将自己的变量传递出去。</p>
<h4 id="通过directive的require配置"><a href="#通过directive的require配置" class="headerlink" title="通过directive的require配置"></a>通过directive的<code>require</code>配置</h4><p><code>require</code>配置相信大家都见到过，一般在使用directive进行自定义表单校验时，肯定会接触到<code>require: &#39;ngModel&#39;</code>：在带有<code>ng-modal</code>属性的input标签上定义directiveA，并且在在directiveA的配置中加上<code>require: &#39;ngModal&#39;</code>，那么在directiveA的link函数中就可以获得第4个参数，这个参数通常命名为<code>ngModelController</code>，也就是定义在<code>ng-model</code>这个框架自带的directive上的controller函数。这表明，通过<code>require</code>配置可以在directiveA的link函数中访问到另一个directiveB的controller函数，也就是说directiveA的实现依赖directiveB，这对于实现类似Tab这种container的UI组件非常有用。另外，require还支持很多前缀，可以指定要依赖的controller的搜索路径，可以参考<a href="https://demisx.github.io/angularjs/directives/2014/11/25/angular-directive-require-property-options.html" target="_blank" rel="external">这篇文章</a>。值得注意的是，一旦使用<code>require</code>，directiveA的定义只能使用link函数，directiveB只能使用controller函数，相当于directiveB通过controller函数将自己的API暴露出去了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到，Angular作为一个不是那么opinionated的框架，写法有很多，我们完全可以把React倡导的一些概念给融合进来取长补短。最后再安利一下<a href="https://github.com/PinkyJie/angular1-webpack-starter" target="_blank" rel="external">angular1-webpack-starter</a>这个项目，后面应该还会围绕这个项目的实践写一些其他文章吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自打去年参加了JSConf后一直断断续续看了很多React的资料，不得不承认React确实在很多方面给人耳目一新的感觉，尤其是组件化的思想给我留下了很深的印象。JSX的语法虽然一开始很难让人接受，但React将函数式编程的思维用在组件化上，确实值得借鉴。作为一个Angular死忠粉，自然很想把这种好的思维方式也用在Angular上了，于是就有了&lt;a href=&quot;https://github.com/PinkyJie/angular1-webpack-starter&quot;&gt;angular1-webpack-starter&lt;/a&gt;这个项目。这篇文章就来记录下用Angular来做纯组件式开发的一些尝试吧。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AngularJS" scheme="http://pinkyjie.com/tags/AngularJS/"/>
    
      <category term="ES6" scheme="http://pinkyjie.com/tags/ES6/"/>
    
      <category term="组件式开发" scheme="http://pinkyjie.com/tags/%E7%BB%84%E4%BB%B6%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="Webpack" scheme="http://pinkyjie.com/tags/Webpack/"/>
    
      <category term="directive" scheme="http://pinkyjie.com/tags/directive/"/>
    
      <category term="angular1-webpack-starter" scheme="http://pinkyjie.com/tags/angular1-webpack-starter/"/>
    
  </entry>
  
  <entry>
    <title>JSConf2015（ShenJS）深圳之行有感</title>
    <link href="http://pinkyjie.com/2015/08/26/thoughts-from-jsconf-2015-in-shenzhen/"/>
    <id>http://pinkyjie.com/2015/08/26/thoughts-from-jsconf-2015-in-shenzhen/</id>
    <published>2015-08-26T12:42:31.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>上个月11、12号飞深圳参加了今年的JS开发者大会，头一次参加这种大会还是挺兴奋的，见到了一些以前只知道名字的大牛，也开阔了视野。前段时间在公司分别给组内和全公司做了分享，PPT做的老累了，就拿劳动成果凑一篇博客吧。</p>
<a id="more"></a>
<h3 id="直接上PPT"><a href="#直接上PPT" class="headerlink" title="直接上PPT"></a>直接上PPT</h3><script async class="speakerdeck-embed" data-id="7b304d03016341fc9da77908a4b300b8" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

<p>PPT里大致讲了三部分：前端、后端、不知道什么端。其实大会的topic整体来说是比较偏后端（Node.js）的，涉及到前端的不多，对于纯前端的我来说其实很多东西是比较陌生的。所以在这个PPT里我其实把大会涉及到的一些前端话题做了延伸和展开，讲了一些自己的认识以及在项目中的实践。对于后端我基本上一笔带过了，因为确实接触不深。“不知道什么端”包含了一些利用JS做的非常有意思的应用，也包含大会期间的一些Lighting Talk。</p>
<h3 id="谈谈React"><a href="#谈谈React" class="headerlink" title="谈谈React"></a>谈谈React</h3><p>React可以说是今年前端最火的话题之一了，借用一位演讲者的话说：“现在不谈React都不好意思说自己是前端”。其实在去深圳参加大会之前，也在上海的很多Meetup上听过不少React的分享。最先听到的点就是：“React比Angular要快好多”，对于深受Angular效率之痛的我还是挺有吸引力的。可是深入了解了以后发现其实这种“快”也是要看场景的，特别是前几天看了<a href="http://www.zhihu.com/question/31809713/answer/53544875" target="_blank" rel="external">知乎的这个回答</a>后，体会更深。即便如此，不得不说React的很多想法很新颖，对于现在前端存在的不少问题也有自己独特的解决方案，这些特性（JSX，Virtual DOM）以及衍生的思想（Immutable Data，GraphQL）也是我在PPT里重点介绍的。说到底React其实只是View，与Angular这种大而全的framework不同，它只能算得上是library，要用React写应用还是得上Flux。Flux不是一种框架，它是一种与MVC同级的编程思想。</p>
<p>关于是否将React应用于公司的项目我也有一些想法，公司的项目现在是基于Angular的，全部用React重写短时间内不太现实，但React的很多思路可以用到Angular上来，比如Immutable Data，比如Flux提倡的单向数据流。Angular作为一个不那么opinionated的框架在这方便还是很开放的，我觉得完全可以将这些思想加进来，目前也已经看到有人在尝试这么做了，比如<a href="http://blog.mgechev.com/2015/03/02/immutability-in-angularjs-immutablejs/" target="_blank" rel="external">Boost the Performance of an AngularJS Application Using Immutable Data</a>，<a href="http://victorsavkin.com/post/99998937651/building-angular-apps-using-flux-architecture" target="_blank" rel="external">BUILDING ANGULAR APPS USING FLUX ARCHITECTURE</a>。有时间也想做些类似的尝试，毕竟这种渐进式的改进对于大的项目来说比较能接受。再者说了，相对于React，我内心其实还是更期待Angular 2，很多改进还是挺吸引人的，决定最近有时间好好看看ngConf 2015的视频。</p>
<h3 id="关于ES6"><a href="#关于ES6" class="headerlink" title="关于ES6"></a>关于ES6</h3><p>ES6无疑是另一个最火的话题。我在PPT里把ES6的特性总结为两点：1.修复自身的缺陷，2.把别的语言里经久考验的优秀特性偷过来。诸如类以及模块的一些支持还是很吸引人的，感觉JS原来越像一门“正统”的语言。想要对ES6有一个大致的认识，除了看PPT里的<a href="https://github.com/lukehoban/es6features" target="_blank" rel="external">那个repo</a>之外，还可以看看这两个系列：一个是阮一峰老师的<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6入门》</a>，另外是Mozilla出的<a href="https://hacks.mozilla.org/category/es6-in-depth/" target="_blank" rel="external">ES6 In Depth</a>系列。大会上有一个session讲的就是generator的使用，其实之前我想当然的认为ES6其实就是把别的语言里的generator概念偷过来嘛，貌似没什么神奇的，跟以前用过的Python里的generator没啥区别嘛。后来看了ES6入门书中的介绍后感觉有了新的认识，JS的generator函数中使用<code>yield</code>将值往调用者那里传，然后调用者使用<code>next(xxx)</code>将值往generator函数中传，这样其实打通了一个回路，而这个回路就是generator改变JS异步调用写法的关键。有兴趣的可以看看<a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="external">阮一峰书中关于异步调用的讲解</a>以及<a href="http://slides.com/eiriklv/taming-async-talk#/" target="_blank" rel="external">Slides网站上的这个PPT</a>。</p>
<h3 id="与大牛们合照"><a href="#与大牛们合照" class="headerlink" title="与大牛们合照"></a>与大牛们合照</h3><p>这次深圳之行一个挺大的收获就是终于见到真人大牛了，以前都只是网上看到过名字，这次终于看到活的了。不仅看到人了，还有幸与大牛们一起聚餐聊天，学到了一些新名词，也了解了他们所在公司的技术现状。</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/thoughts-from-jsconf-2015-1.JPG" class="center-img" title="图1">
<p>说到这张照片，还有一个段子，当时阴明开玩笑说：“如果这两桌的人都饿死了，中国的前端要倒退好几年”，哈哈！桌上见到了小鱼、尤小右，以及在上海的Meetup上就见到过的达峰和hax。小鱼我关注蛮久的，怎么也没法把网上的他跟广东人联系在一起，不过真人一看就知道是广东人。还有稀土的阴明，就是中午找他聊天才知道晚上这个聚餐的事，阴明说话超级逗，关键是真人跟头像真的一模一样，所以我才能在大会现场直接认出了他。</p>
<h3 id="吐槽深圳"><a href="#吐槽深圳" class="headerlink" title="吐槽深圳"></a>吐槽深圳</h3><p>说起深圳，我脑海里第一反应就是那句歌词，上签到图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/thoughts-from-jsconf-2015-2.PNG" class="center-img" title="图2">
<p>到了以后才发现，深圳跟我想象中完全不是一回事啊，我要开启吐槽模式了！</p>
<ul>
<li>关于定额发票：吃饭居然只能开定额发票！由于这次开会全程都是公司报销的，干啥都要开发票。10号晚上到了以后，在酒店附近找吃饭的地，走了两条街也没问到能开机打发票的店，当时我就震惊了，上海是个大点的店都能开机打发票啊，定额发票算怎么回事。。。在上海貌似只有交通卡充值发票是定额的吧。。。不过拿到定额发票看了看感觉也挺正规的，后来在机场吃了顿饭也是定额发票，猜想可能深圳的规定就是这样吧。</li>
<li>关于关内关外：刚出机场打车的时候就挺奇怪的，出租车分两种，一种只去周边的几个区，另一种去市区，当时我就迷茫了。后来听人介绍才知道，这都是历史遗留问题啊！当时划经济特区的圈，只划了一部分，圈中的部分靠近香港，是关内，其他部分是关外。关内关外经济发展差距可想而知，最令我震惊的时当时关内关外居然架设铁丝网强行分割，还设有检查站，进出关都要查验证件。。。同城不同命啊，这社会能稳定吗。。。铁丝网据说这几年才真正的撤掉，但关内外的经济差距一时半会是无法补平的。出租车的区分也是因为以前一些只跑关内，一些只跑关外的历史遗留问题。对这段感兴趣的可以自行搜索“深圳关内关外”。</li>
<li>关于粤语：虽然听不懂，但真的是一种TVB即视感啊，挺羡慕会粤语的孩子的，听/唱粤语歌都毫无障碍啊。</li>
<li>关于“破”：可能是魔都呆多了，觉得深圳好像有点破，可能所住的那块区域恰好发展一般吧，貌似附近都在搞开发。但有一点，<strong>空气确实比上海好</strong>！说到这里其实也挺遗憾的，由于会议日程安排太紧，这两天除了开会基本啥也没干，都没有在深圳好好逛逛。小时候就听说得“世界之窗”也来得及去瞧瞧，有机会再去吧。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上个月11、12号飞深圳参加了今年的JS开发者大会，头一次参加这种大会还是挺兴奋的，见到了一些以前只知道名字的大牛，也开阔了视野。前段时间在公司分别给组内和全公司做了分享，PPT做的老累了，就拿劳动成果凑一篇博客吧。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JS开发者大会" scheme="http://pinkyjie.com/tags/JS%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A/"/>
    
      <category term="JSConf" scheme="http://pinkyjie.com/tags/JSConf/"/>
    
      <category term="ShenJS" scheme="http://pinkyjie.com/tags/ShenJS/"/>
    
      <category term="React" scheme="http://pinkyjie.com/tags/React/"/>
    
      <category term="ES6" scheme="http://pinkyjie.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>常用gulp插件介绍(二)</title>
    <link href="http://pinkyjie.com/2015/08/12/commonly-used-gulp-plugins-part-2/"/>
    <id>http://pinkyjie.com/2015/08/12/commonly-used-gulp-plugins-part-2/</id>
    <published>2015-08-12T12:45:59.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>书接<a href="/2015/08/02/commonly-used-gulp-plugins-part-1/">上回</a>。</p>
<a id="more"></a>
<h3 id="Angular相关"><a href="#Angular相关" class="headerlink" title="Angular相关"></a>Angular相关</h3><p>这个部分介绍与Angular相关的一些插件。</p>
<h4 id="gulp-angular-templatecache"><a href="#gulp-angular-templatecache" class="headerlink" title="gulp-angular-templatecache"></a><a href="https://www.npmjs.com/package/gulp-angular-templatecache" target="_blank" rel="external">gulp-angular-templatecache</a></h4><p>Angular自带的<code>$templateCache</code>服务可以把Angular中用到的所有模板缓存下来，而这个插件的功能就是直接将指定的HTML模板文件以JS字符串的形式注册在<code>$tempalteCache</code>服务中，这样所有的模板就会随JS文件直接一次性下载下来。这个插件使用起来也非常简单，gulp.src传入需要缓存的HTML模板文件，然后<code>.pipe($.angularTemplatecache(filename, options))</code>即可。其中filename表示生成后的js文件的名字，默认为templates.js，常用的options有：</p>
<ul>
<li><code>module</code>：指定希望将这个模板放入哪个Angular的module中。</li>
<li><code>root</code>：指定注册后的模板路径前缀。</li>
</ul>
<p>生成后的文件如下：</p>
<figure class="highlight javascript"><figcaption><span>templates.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">"module name"</span>).run([$templateCache,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">$templateCache</span>) </span>&#123;</div><div class="line">    $templateCache.put(<span class="string">"template1.html"</span>,</div><div class="line">      <span class="comment">// template1.html content (escaped) </span></div><div class="line">    );</div><div class="line">    $templateCache.put(<span class="string">"template2.html"</span>,</div><div class="line">      <span class="comment">// template2.html content (escaped) </span></div><div class="line">    );</div><div class="line">    <span class="comment">// etc. </span></div><div class="line">  &#125;</div><div class="line">]);</div></pre></td></tr></table></figure>
<h4 id="gulp-ng-annotate"><a href="#gulp-ng-annotate" class="headerlink" title="gulp-ng-annotate"></a><a href="https://www.npmjs.com/package/gulp-ng-annotate" target="_blank" rel="external">gulp-ng-annotate</a></h4><p>这个插件是<a href="https://github.com/olov/ng-annotate" target="_blank" rel="external">ng-annotate</a>的gulp插件版，它解决的是Angular中依赖注入的小问题。Angular中通过参数名来进行依赖注入，一旦压缩，参数名就会变化导致注入失败，所以官方推荐通过添加字符串进行注入。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">angular</div><div class="line">    .module(<span class="string">'app.dashboard'</span>)</div><div class="line">    .controller(<span class="string">'DashboardController'</span>, DashboardController);</div><div class="line"></div><div class="line">DashboardController.$inject = [<span class="string">'userAPI'</span>];</div><div class="line"><span class="comment">/* @ngInject */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DashboardController</span> (<span class="params">userAPI</span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>上面的例子中我们定义了一个叫<code>DashboardController</code>的controller，它依赖一个<code>userAPI</code>的service。这个插件的作用就是根据第6行的注释<code>/* @ngInject */</code>来帮你生成第5行的内容。当然是在你忘记写的情况下，如果你自己写了它不会重复生成。除了这种使用<code>$inject</code>赋值的方式，它同样支持inline定义的方式，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @ngInject */</span></div><div class="line">.controller(<span class="string">'DashboardController'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">userAPI</span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure>
<p>会生成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.controller(<span class="string">'DashboardController'</span>, [<span class="string">'userAPI'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">userAPI</span>) </span>&#123;&#125;]);</div></pre></td></tr></table></figure>
<p>它常用的参数就是<code>{add: true}</code>，表明仅在不存在的情况下才会进行添加。</p>
<blockquote>
<p>推荐在HTML头上使用<a href="https://docs.angularjs.org/error/$injector/strictdi" target="_blank" rel="external">ng-strict-di</a>属性，这样即便在不压缩的情况下，一旦你忘记显式的用字符串声明依赖，Angular将立刻报错。</p>
</blockquote>
<h4 id="gulp-protractor"><a href="#gulp-protractor" class="headerlink" title="gulp-protractor"></a><a href="https://www.npmjs.com/package/gulp-protractor" target="_blank" rel="external">gulp-protractor</a></h4><p>Angular的e2e测试工具<a href="https://github.com/angular/protractor" target="_blank" rel="external">protractor</a>的配套插件，可以通过它非常方便的在gulp中调用protractor。有了这玩意，你就不需要手动在gulp中调用protractor的可执行文件，然后处理进程神马的，只要一句简单的<code>.pipe($.protractor.protractor(options)</code>即可。常用的options包括：</p>
<ul>
<li><code>configFile</code>：即protractor的配置文件路径。</li>
<li><code>args</code>：调用protractor时传入的参数，是个数组。最常用的就是指定protractor只跑一个suite了，如<code>[&#39;--suite&#39;, &#39;loginSuite&#39;]</code>，这样protractor只会跑配置文件中定义的loginSuite所包括的spec文件了。</li>
</ul>
<h4 id="gulp-order"><a href="#gulp-order" class="headerlink" title="gulp-order"></a><a href="https://www.npmjs.com/package/gulp-order" target="_blank" rel="external">gulp-order</a></h4><p>这个插件严格来说不是专门给Angular用的，但非常适合用在Angular的场景下。如果你的程序使用的是Angular自带的包管理系统，那么有一个无法避开的问题就是：所有<code>angular.module</code>的定义要最先执行，也就是说包含module定义的文件的script标签要在别的文件之前。而我们在使用gulp-inject这类插件将JS文件插入的时候通常都是通过匹配符直接选中一堆文件插入的。这时就需要解决插入的顺序问题，而这个插件就是干这个事的。它通过一个数组参数来指定排序，这个数组包含一组匹配模式，匹配到靠前模式的文件在前，匹配靠后的文件在后。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gulp</div><div class="line">    .src(<span class="string">'**/*.js'</span>)</div><div class="line">    .pipe($.order([</div><div class="line">        <span class="string">'**/app.module.js'</span>,</div><div class="line">        <span class="string">'**/*.module.js'</span>,</div><div class="line">        <span class="string">'**/*.js'</span></div><div class="line">    ]))</div></pre></td></tr></table></figure>
<p>这样，定义<code>app</code>module的文件就会在最前面，然后是其它各个module的定义，最后是剩余的JS文件。</p>
<h3 id="压缩工具类"><a href="#压缩工具类" class="headerlink" title="压缩工具类"></a>压缩工具类</h3><p>这个部分介绍对CSS、HTML、JS、图片等资源进行压缩的插件。</p>
<h4 id="gulp-csso"><a href="#gulp-csso" class="headerlink" title="gulp-csso"></a><a href="https://www.npmjs.com/package/gulp-csso" target="_blank" rel="external">gulp-csso</a></h4><p>压缩CSS的工具，官方说它比其它工具压得更小，因为它可以重建CSS代码结构信息，不知道什么鬼。</p>
<h4 id="gulp-minify-html"><a href="#gulp-minify-html" class="headerlink" title="gulp-minify-html"></a><a href="https://www.npmjs.com/package/gulp-minify-html" target="_blank" rel="external">gulp-minify-html</a></h4><p>压缩HTML的工具，通常在给gulp-angular-templatecache处理前先使用，这样$tempalteCache得到的就是压缩后的HTML字符串了。</p>
<h4 id="gulp-uglify"><a href="#gulp-uglify" class="headerlink" title="gulp-uglify"></a><a href="https://www.npmjs.com/package/gulp-uglify" target="_blank" rel="external">gulp-uglify</a></h4><p>压缩JS的工具，这个不多介绍了。</p>
<h4 id="gulp-imagemin"><a href="#gulp-imagemin" class="headerlink" title="gulp-imagemin"></a><a href="https://www.npmjs.com/package/gulp-imagemin" target="_blank" rel="external">gulp-imagemin</a></h4><p>压缩图片的工具。在发布到生产环境之前对图片进行压缩是一个非常好的习惯，可以极大的提高页面加载的速度。如果你用<a href="https://developers.google.com/speed/pagespeed/" target="_blank" rel="external">Google PageSpeed</a>给网页评过分的话，它可以给出页面上能被继续压缩的图片。使用这个插件可以在保证质量损失很小的情况下压缩图片。</p>
<h3 id="server相关"><a href="#server相关" class="headerlink" title="server相关"></a>server相关</h3><p>这部分介绍与本地起server相关的插件。</p>
<h4 id="browser-sync"><a href="#browser-sync" class="headerlink" title="browser-sync"></a><a href="https://www.npmjs.com/package/browser-sync" target="_blank" rel="external">browser-sync</a></h4><p><a href="http://www.browsersync.io/" target="_blank" rel="external">Browsersync</a>应该算是本地起server的标配了吧，最大的特性是可以在不同浏览器之间同步（这也是名字的由来吧），这在测试时非常有用：起server以后根据配置自动打开多个浏览器，你操作一个，其他的浏览器会同步你的操作。另外，它还可以配合gulp的<code>watch()</code>函数实现类似live-reload的功能。之所以没有gulp对应的插件，是因为这玩意本来就可以直接require进来使用。支持非常多的参数，一整篇文章也介绍不完，具体可以参考<a href="http://www.browsersync.io/docs/options/" target="_blank" rel="external">它的文档</a>。这里要简单介绍的就是server底下的配置，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server: &#123;</div><div class="line">    <span class="attr">baseDir</span>: <span class="string">'./app/'</span>,</div><div class="line">    <span class="attr">index</span>: <span class="string">'index.html'</span>,</div><div class="line">    <span class="attr">middleware</span>: [</div><div class="line">        <span class="comment">// middleware</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前两个参数就不多说了，一看就明白意思，重点来看第3个参数<code>middleware</code>。middleware就是中间件，类似这样的函数<code>function (req, res, next){}</code>。简单来说，一个request请求到达server，会经过middleware数组里面的中间件函数逐个处理，这里就可以在Browsersync层面上定义很多自定义的操作。适用于Node的<a href="https://github.com/senchalabs/connect" target="_blank" rel="external">connect框架</a>的中间件都可以在这里使用，下面介绍的两个插件都是可用于Browsersync的中间件。</p>
<h4 id="connect-history-api-fallback"><a href="#connect-history-api-fallback" class="headerlink" title="connect-history-api-fallback"></a><a href="https://www.npmjs.com/package/connect-history-api-fallback" target="_blank" rel="external">connect-history-api-fallback</a></h4><p>这个中间件对于像Angular这样的单页面应用来说非常的实用。我们知道，Browsersync默认起来的server是一个静态server，默认是无法支持<code>$locationProvider.html5Mode(true);</code>的。使用这个插件可以轻松的达到这一点，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> historyApiFallback = <span class="built_in">require</span>(<span class="string">'connect-history-api-fallback'</span>);</div><div class="line"><span class="comment">// ...</span></div><div class="line">middleware: [</div><div class="line">    historyApiFallback()</div><div class="line">]</div></pre></td></tr></table></figure>
<p>这样，所有的路由请求都会fallback到index.html处理，这也正是我们想要的。除此之外，这个插件还支持简单的rewrite，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">historyApiFallback(&#123;</div><div class="line">  <span class="attr">rewrites</span>: [</div><div class="line">    &#123; <span class="attr">from</span>: <span class="regexp">/\/soccer/</span>, <span class="attr">to</span>: <span class="string">'/soccer.html'</span>&#125;</div><div class="line">  ]</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可谓是非常方便，更多的rewrite规则可以参考它的文档。</p>
<h4 id="proxy-middleware"><a href="#proxy-middleware" class="headerlink" title="proxy-middleware"></a><a href="https://www.npmjs.com/package/proxy-middleware" target="_blank" rel="external">proxy-middleware</a></h4><p>这个中间件其实与上面rewrite的类似，只不过rewrite只是针对get请求，而这个proxy可以代理任何请求。设想这样一个场景，我们起了个本地的server，通常使用<a href="https://docs.angularjs.org/api/ngMock" target="_blank" rel="external">ngMock</a>来实现对API的模拟，但有的时候我们希望这个本地的server可以对接真正的API server，而这个中间件可以轻松的完成这一点：将<code>/api</code>开头的请求代理到真正的API server上去。它的使用也是非常简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">'proxy-middleware'</span>);</div><div class="line"><span class="keyword">var</span> proxyOptions = url.parse(<span class="string">'https://real-server.com/api'</span>);</div><div class="line">proxyOptions.route = <span class="string">'/api'</span>;</div><div class="line"><span class="comment">// ...</span></div><div class="line">middleware: [</div><div class="line">    proxy(proxyOptions)</div><div class="line">]</div></pre></td></tr></table></figure>
<p>这样，所有以<code>/api</code>开头的API请求就会被代理到<code>https://real-server.com/api</code>上去，如<code>/api/user/123</code>请求的真实地址是<code>https://real-server.com/api/user/123</code>。</p>
<h3 id="特定语言相关"><a href="#特定语言相关" class="headerlink" title="特定语言相关"></a>特定语言相关</h3><p>这部分的插件与你选用的具体的语言以及预处理器有关。</p>
<h4 id="gulp-jshint-与-gulp-jscs"><a href="#gulp-jshint-与-gulp-jscs" class="headerlink" title="gulp-jshint 与 gulp-jscs"></a><a href="https://www.npmjs.com/package/gulp-jshint" target="_blank" rel="external">gulp-jshint</a> 与 <a href="https://www.npmjs.com/package/gulp-jscs" target="_blank" rel="external">gulp-jscs</a></h4><p>大名鼎鼎的<a href="">jshint</a>和<a href="">jscs</a>的gulp插件版。这两个插件除了帮你做代码的一些静态检查外，还可以最大程度的帮助你定义所需要的代码风格。尤其是<code>jscs</code>，定义的非常细致。比如我们需要<code>function (a, b) {</code>，即function关键字后面空一格，参数之间空一格，参数列表后面的小括号与大括号之间空一格。这样的需求通过<code>jscs</code>的配置文件可以轻松的实现，具体可以参考其文档。可以将这两个task放在build之前，强制所有人在build代码的时候修改不符合要求的代码风格。我们还尝试过将<code>gulp jshint jscs</code>放入git commit的hook中，每次commit的时候自动检查代码风格，如果不符合要求，不准进行commit的操作。</p>
<h4 id="gulp-jade"><a href="#gulp-jade" class="headerlink" title="gulp-jade"></a><a href="https://www.npmjs.com/package/gulp-jade" target="_blank" rel="external">gulp-jade</a></h4><p>编译jade模板的插件，这个也不过多介绍。只介绍一个使用jade变量的场景，通常我们的Angular应用的<code>ng-app</code>名称在测试(e2e)与非测试时是不一样的，所以可以把这个定义成变量，在编译jade模板时传入。如我们的index.jade的头是这样定义的<code>html(lang=&quot;en&quot;, ng-app= app)</code>，在编译时使用<code>.pipe($.jade({locals: {app: &#39;test&#39;}}))</code>即可指定想要的<code>ng-app</code>的名字。</p>
<h4 id="gulp-stylus"><a href="#gulp-stylus" class="headerlink" title="gulp-stylus"></a><a href="https://www.npmjs.com/package/gulp-stylus" target="_blank" rel="external">gulp-stylus</a></h4><p>编译stylus的插件，不多说。</p>
<h4 id="gulp-autoprefixer"><a href="#gulp-autoprefixer" class="headerlink" title="gulp-autoprefixer"></a><a href="https://www.npmjs.com/package/gulp-autoprefixer" target="_blank" rel="external">gulp-autoprefixer</a></h4><p>这个插件最早在<a href="/2014/01/12/what-i-learn-from-making-resume/">从做简历中学到的知识</a>这篇文章中就介绍过，只不过当时介绍的是grunt版本，现在时gulp版本。这个插件的基本作用就是让你在书写CSS3的相关属性时不用关心不同浏览器的前缀问题，它会自动帮助添加各种浏览器前缀。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书接&lt;a href=&quot;/2015/08/02/commonly-used-gulp-plugins-part-1/&quot;&gt;上回&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AngularJS" scheme="http://pinkyjie.com/tags/AngularJS/"/>
    
      <category term="插件" scheme="http://pinkyjie.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="gulp" scheme="http://pinkyjie.com/tags/gulp/"/>
    
      <category term="generator-aio-angular" scheme="http://pinkyjie.com/tags/generator-aio-angular/"/>
    
  </entry>
  
  <entry>
    <title>常用gulp插件介绍(一)</title>
    <link href="http://pinkyjie.com/2015/08/02/commonly-used-gulp-plugins-part-1/"/>
    <id>http://pinkyjie.com/2015/08/02/commonly-used-gulp-plugins-part-1/</id>
    <published>2015-08-02T05:45:59.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>在写<a href="https://github.com/PinkyJie/generator-aio-angular" target="_blank" rel="external">generator-aio-angular</a>的过程中，gulp这一块发现了很多非常实用的插件，大大的增加了能自动化的范围，这篇文章就分门别类的简单介绍下常用的gulp插件吧。</p>
<a id="more"></a>
<h3 id="util工具类"><a href="#util工具类" class="headerlink" title="util工具类"></a>util工具类</h3><p>这个分类下主要介绍一些辅助工具类的插件。</p>
<h4 id="gulp-load-plugins"><a href="#gulp-load-plugins" class="headerlink" title="gulp-load-plugins"></a><a href="https://www.npmjs.com/package/gulp-load-plugins" target="_blank" rel="external">gulp-load-plugins</a></h4><p>顾名思义，本插件的功能就是帮你自动require你在<code>package.json</code>中声明的依赖。只要一句<code>var $ = require(&#39;gulp-load-plugins&#39;)()</code>，则<code>package.json</code>中声明的<code>gulp-</code>或<code>gulp.</code>开头的插件就会自动被放在变量<code>$</code>下面。如<code>$.util</code>就等于<code>require(&#39;gulp-util&#39;)</code>，而有两个连字符的插件则会自动命名为驼峰格式，如<code>$.taskListing</code>则等于<code>require(&#39;gulp-task-listing&#39;)</code>。有了这个插件，就不用一个一个的require了。这个插件还有一些常用的参数配置，这里列几个常用的：</p>
<ul>
<li><code>lazyload: true</code>，用到这个插件的时候再去require，默认为true。</li>
<li><code>rename: {&#39;gulp-task-listing&#39;: &#39;list&#39;}</code>，如果有些插件名字太长，可以使用该参数重命名。</li>
<li><code>scope: [&#39;dependencies&#39;]</code>，本插件默认会扫描<code>package.json</code>里的所有dependence，可以使用该参数进行限制。</li>
</ul>
<p>要使用这些参数只要在require的时候传入即可，如<code>require(&#39;gulp-load-plugins&#39;)({lazy: true})</code>。</p>
<h4 id="gulp-task-listing"><a href="#gulp-task-listing" class="headerlink" title="gulp-task-listing"></a><a href="https://www.npmjs.com/package/gulp-task-listing" target="_blank" rel="external">gulp-task-listing</a></h4><p>这个插件的作用也很容易猜，它可以打印出<code>gulpfile.js</code>中定义的所有task，这个插件我们在<a href="/2015/03/24/refactor-your-gulpfile/">重构你的gulpfile</a>这篇文章的最后介绍过，值得一提的是它还可以根据task的名字确定它是不是一个子task，比如带有<code>:</code>、<code>-</code>、<code>_</code>的task就被认为是子task。我一般把这个插件作为默认的task来调用，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'help'</span>]);</div><div class="line">gulp.task(<span class="string">'help'</span>, $.taskListing);</div></pre></td></tr></table></figure>
<p>这样，如果只执行<code>gulp</code>的话就会打印出所有定义好的task，非常实用。</p>
<h4 id="yargs"><a href="#yargs" class="headerlink" title="yargs"></a><a href="https://www.npmjs.com/package/yargs" target="_blank" rel="external">yargs</a></h4><p>严格的说，<code>yargs</code>不是专门用于gulp的，它是Node中处理命令行参数的通用解决方案。只要一句代码<code>var args = require(&#39;yargs&#39;).argv;</code>就可以让命令行的参数都放在变量<code>args</code>上，非常方便。它可以处理的参数类型也是多种多样的：</p>
<ul>
<li>单字符的简单参数，如传入<code>-m=5</code>或<code>-m 5</code>，则可得到<code>args.m = 5</code>。</li>
<li>多字符参数（必须使用双连字符），如传入<code>--test=5</code>或<code>--test 5</code>，则可得到<code>args.test = 5</code>。</li>
<li>不带值的参数，如传入<code>--mock</code>，则会被认为是布尔类型的参数，可得到<code>args.mock = true</code>。</li>
</ul>
<p>除此之外，还支持很多其他类型的传参方式，具体可参考<a href="https://www.npmjs.com/package/yargs" target="_blank" rel="external">它的文档</a>。</p>
<h4 id="gulp-util"><a href="#gulp-util" class="headerlink" title="gulp-util"></a><a href="https://www.npmjs.com/package/gulp-util" target="_blank" rel="external">gulp-util</a></h4><p>gulp-util带有很多方便的函数，其中最常用的应该就是log了。<code>$.util.log()</code>支持传入多个参数，打印结果会将多个参数用空格连接起来。它与<code>console.log</code>的区别就是所有<code>$.util.log</code>的结果会自动带上时间前缀。另外，它还支持颜色，如<code>$.util.log($.util.colors.magenta(&#39;123&#39;));</code>打印出来的123是品红色的。其实<code>$.util.colors</code>就是一个<a href="https://github.com/sindresorhus/chalk" target="_blank" rel="external">chalk</a>的实例，而chalk是专门用来处理命令行打印着色的一个工具。</p>
<h4 id="del"><a href="#del" class="headerlink" title="del"></a><a href="https://www.npmjs.com/package/del" target="_blank" rel="external">del</a></h4><p>grunt自身提供一个<a href="https://github.com/gruntjs/grunt-contrib-clean" target="_blank" rel="external">grunt-contrib-clean</a>用来处理支持glob匹配的删除，而del就是gulp上对应的工具。del支持和<code>gulp.src</code>参数同样的匹配，除此之外，它的第二个参数还支持一个回调函数，当删除完成以后执行，所以这是一个异步的删除。常用的调用方法为：<code>del([xxx], callback)</code>。</p>
<h4 id="gulp-bytediff"><a href="#gulp-bytediff" class="headerlink" title="gulp-bytediff"></a><a href="https://www.npmjs.com/package/gulp-bytediff" target="_blank" rel="external">gulp-bytediff</a></h4><p>这是一个统计文件大小变化的工具，通常与压缩类工具放在一起实用，比如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'**/*.html'</span>)</div><div class="line">    .pipe($.bytediff.start())</div><div class="line">    .pipe($.minifyHtml(&#123;<span class="attr">empty</span>: <span class="literal">true</span>&#125;))</div><div class="line">    .pipe($.bytediff.stop(bytediffFormatter))</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>));</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bytediffFormatter</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> difference = (data.savings &gt; <span class="number">0</span>) ? <span class="string">' smaller.'</span> : <span class="string">' larger.'</span>;</div><div class="line">    <span class="keyword">return</span> data.fileName + <span class="string">' went from '</span> +</div><div class="line">        (data.startSize / <span class="number">1000</span>).toFixed(<span class="number">2</span>) + <span class="string">' kB to '</span> +</div><div class="line">        (data.endSize / <span class="number">1000</span>).toFixed(<span class="number">2</span>) + <span class="string">' kB and is '</span> +</div><div class="line">        formatPercent(<span class="number">1</span> - data.percent, <span class="number">2</span>) + <span class="string">'%'</span> + difference;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在压缩的pipe前后加上<code>$.bytediff.start()</code>和<code>$.bytediff.stop(callback)</code>，即可统计压缩前后文件的变化。在callback中传入的参数data上，可以访问到很多变量，如文件名，变化前后的大小，变化百分比等等。</p>
<h4 id="gulp-print"><a href="#gulp-print" class="headerlink" title="gulp-print"></a><a href="https://www.npmjs.com/package/gulp-print" target="_blank" rel="external">gulp-print</a></h4><p>这个插件的作用很简单，打印出stream里面的所有文件名，通常调试的时候比较需要。</p>
<h4 id="gulp-bump"><a href="#gulp-bump" class="headerlink" title="gulp-bump"></a><a href="https://www.npmjs.com/package/gulp-bump" target="_blank" rel="external">gulp-bump</a></h4><p>这个插件也可以顾名思义：用来升级版本用的，废话不说，直接看例子吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> gulp</div><div class="line">    .src(<span class="string">'package.json'</span>)</div><div class="line">    .pipe($.bump(options))</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>));</div></pre></td></tr></table></figure>
<p>重点来看这里的options，我们可直接传递一个具体的version进去，也可以按照Node的版本规范传递一个type进去，让其自己生成对应的version：</p>
<ul>
<li><code>version</code>，直接传递要升级到的版本号，如<code>1.2.3</code>。</li>
<li><code>type</code>，可接受的值包括下面四个，倘若现在的版本号为<code>1.2.3</code>，则对应的新版本号为：<ul>
<li>prerelease：<code>1.2.3-0</code></li>
<li>patch：<code>1.2.4</code></li>
<li>minor：<code>1.3.0</code></li>
<li>major：<code>2.0.0</code></li>
</ul>
</li>
</ul>
<p>最终这个升级后的版本号会反映在<code>package.json</code>中，当然，你也可以在gulp.src中传入更多的文件（如<code>bower.json</code>）来替换更多的文件。</p>
<h4 id="gulp-header"><a href="#gulp-header" class="headerlink" title="gulp-header"></a><a href="https://www.npmjs.com/package/gulp-header" target="_blank" rel="external">gulp-header</a></h4><p>这个工具用来在压缩后的JS、CSS文件中添加头部注释，你可以包含任意想要的信息，通常就是作者、描述、版本号、license等，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHeader</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> pkg = <span class="built_in">require</span>(<span class="string">'package.json'</span>);</div><div class="line">    <span class="keyword">var</span> template = [<span class="string">'/**'</span>,</div><div class="line">        <span class="string">' * &lt;%= pkg.name %&gt; - &lt;%= pkg.description %&gt;'</span>,</div><div class="line">        <span class="string">' * @authors &lt;%= pkg.authors %&gt;'</span>,</div><div class="line">        <span class="string">' * @version v&lt;%= pkg.version %&gt;'</span>,</div><div class="line">        <span class="string">' * @link &lt;%= pkg.homepage %&gt;'</span>,</div><div class="line">        <span class="string">' * @license &lt;%= pkg.license %&gt;'</span>,</div><div class="line">        <span class="string">' */'</span>,</div><div class="line">        <span class="string">''</span></div><div class="line">    ].join(<span class="string">'\n'</span>);</div><div class="line">    <span class="keyword">return</span> $.header(template, &#123;</div><div class="line">        <span class="attr">pkg</span>: pkg</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数将<code>package.json</code>中的各种信息提取出来，变成头部注释，只要在压缩的pipe中调用<code>.pipe(getHeader())</code>即可。</p>
<h3 id="stream相关"><a href="#stream相关" class="headerlink" title="stream相关"></a>stream相关</h3><p>这个部分主要介绍一些跟stream操作有关的插件。</p>
<h4 id="gulp-filter"><a href="#gulp-filter" class="headerlink" title="gulp-filter"></a><a href="https://www.npmjs.com/package/gulp-filter" target="_blank" rel="external">gulp-filter</a></h4><p>gulp-filter可以把stream里的文件根据一定的规则进行筛选过滤。比如<code>gulp.src</code>中传入匹配符匹配了很多文件，可以把这些文件pipe给gulp-filter作二次筛选，如<code>gulp.src(&#39;**/*.js&#39;).pipe($.filter(**/a/*.js))</code>，本来选中了所有子文件下的js文件，经过筛选后变成名为a的子文件夹下的js文件。那有人要问了，为什么不直接将需要的筛选传入<code>gulp.src</code>，干嘛要多筛选一步呢？这里面有两种情况：</p>
<ul>
<li><code>gulp.src</code>与<code>$.filter</code>中间可能需要别的处理，比如我对所有文件做了操作1以后，还需要筛选出一部分做操作2。</li>
<li>第二种情况就要谈到gulp-filter的另外一个特性：筛选之后还可以restore回去。比如我对所有文件做了操作1，筛选了一部分做操作2，最后要把所有的文件都拷贝到最终的位置。代码如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> filter = $.filter(<span class="string">'**/a/*.js'</span>);</div><div class="line">gulp.src(<span class="string">'**/*.js'</span>)</div><div class="line">    .pipe(action1())</div><div class="line">    .pipe(filter)</div><div class="line">    .pipe(action2())</div><div class="line">    .pipe(filter.restore())</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>))</div></pre></td></tr></table></figure>
<p>可以看到，如果没有restore这个操作，那么拷贝到最终位置的文件将只包含被过滤出来的文件，这样一restore，所有的文件都被拷贝了。</p>
<h4 id="gulp-flatten"><a href="#gulp-flatten" class="headerlink" title="gulp-flatten"></a><a href="https://www.npmjs.com/package/gulp-flatten" target="_blank" rel="external">gulp-flatten</a></h4><p>gulp-flatten非常实用，可能知道别的库中flatten函数的同学已经猜到它是干嘛的了。比如<code>gulp.src(&#39;**/*.js&#39;)</code>匹配了很多文件，包括<code>a/b/c.js</code>，<code>d/e.js</code>，<code>f/g/h/i/j/k.js</code>，<code>l.js</code>，这些文件的层级都不一样，一旦我们将这个文件pipe给<code>$.flatten()</code>，则所有的文件夹层级都会去掉，最终的文件将是<code>c.js</code>，<code>e.js</code>，<code>k.js</code>，<code>l.js</code>，在一些场景下还是非常有用的。</p>
<h4 id="gulp-plumber"><a href="#gulp-plumber" class="headerlink" title="gulp-plumber"></a><a href="https://www.npmjs.com/package/gulp-plumber" target="_blank" rel="external">gulp-plumber</a></h4><p>这个插件的作用简单来说就是一旦pipe中的某一steam报错了，保证下面的steam还继续执行。因为pipe默认的onerror函数会把剩下的stream给unpipe掉，这个插件阻止了这种行为。那它一般用于哪种场景呢？比如，代码每次build之前要跑一遍jshint和jscs来确保所有代码都符合规范，但一旦某些代码不符合规范，整个build流程就会停止，这个时候就需要gulp-plumber出场了。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'build'</span>, [<span class="string">'jslint'</span>, <span class="string">'xxxx'</span>]);</div><div class="line">gulp.task(<span class="string">'jslint'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> gulp</div><div class="line">        .src(config.js.all)</div><div class="line">        .pipe($.plumber())</div><div class="line">        .pipe($.jshint())</div><div class="line">        .pipe($.jscs()); </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这样，一旦jshint或jscs报错，整个build流程还是可以继续走下去的，而且gulp-plumber会给出一个报错提醒我们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[16:52:36] Plumber found unhandled error:</div><div class="line"> Error in plugin &apos;gulp-jshint&apos;</div><div class="line">Message:</div><div class="line">    JSHint failed for: xxxx.js</div></pre></td></tr></table></figure>
<h4 id="gulp-if"><a href="#gulp-if" class="headerlink" title="gulp-if"></a><a href="https://www.npmjs.com/package/gulp-if" target="_blank" rel="external">gulp-if</a></h4><p>这个插件的功能也很简单，可以条件性的添加stream，如<code>.pipe($.if(flag, action1()))</code>，则只会在<code>flag</code>变量为true时才会将<code>action1()</code>添加到stream中去。其实不用这个插件也可以达到类似的效果，那就是gulp-util里有一个函数叫做<code>noop()</code>，也就是no operation，这个函数其实是返回一个什么都不干的空stream。利用这个函数我们可以这么写：<code>.pipe(flag ? action1() : $.util.noop())</code>，与上例的效果是一样的。</p>
<h4 id="merge-stream"><a href="#merge-stream" class="headerlink" title="merge-stream"></a><a href="https://www.npmjs.com/package/merge-stream" target="_blank" rel="external">merge-stream</a></h4><p>一个gulp的task只能返回一个stream，但有的时候有这么一种情景：有两类文件，它们的原始位置和处理后的位置都是不同的，但它们的处理流程相同。由于<code>gulp.src</code>和<code>gulp.dest</code>的参数不同，我们就需要写两个task来分别完成这个任务，一方面略显重复，另一方面逻辑上来讲这两个task本来就是处理同样的事情的。这种情况就需要merge-stream登场了，它的作用就是将多个stream合成一个返回。比如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> merge = <span class="built_in">require</span>(<span class="string">'merge-stream'</span>);</div><div class="line">gulp.task(<span class="string">'jade'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> stream1 = jade(src1, dest1);</div><div class="line">    <span class="keyword">var</span> stream2 = jade(src2, dest2);</div><div class="line">    <span class="keyword">return</span> merge(stream1, stream2);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jade</span> (<span class="params">src, dest</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> gulp</div><div class="line">        .src(src)</div><div class="line">        .pipe($.jade())</div><div class="line">        .pipe(gulp.dest(dest));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，处理的流程被提取出来放入一个函数，它接受两个参数，分别是src和dest。然后在task中直接调用这个函数生成两个stream，然后返回merge-stream合并后的结果。</p>
<h4 id="run-sequence"><a href="#run-sequence" class="headerlink" title="run-sequence"></a><a href="https://www.npmjs.com/package/run-sequence" target="_blank" rel="external">run-sequence</a></h4><p>gulp里的task都是异步并发执行的，有的时候我们需要一连串的task按顺序执行，这时就需要run-sequence登场了。它的调用很简单：<code>runSequence(&#39;task1&#39;, &#39;task2&#39;, [&#39;task3&#39;, &#39;task4&#39;], &#39;task5&#39;)</code>，这里的task都是gulp定义好的task名称，task1完成后才会执行task2，以此类推。注意到task3和task4被放在中括号里了，这表明，task3和task4可以并发执行的，但两个都执行完后才会执行task5。这里要说明的是，每个task要么返回一个stream，即<code>return gulp.src().pipe().pipe()</code>，要么支持回调函数，即<code>gulp.task(&#39;task1&#39;, function (done) { action1(done); })</code>，满足了这两点才能保证正常的执行顺序，因为这是gulp对<a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md#async-task-support" target="_blank" rel="external">异步task的基本要求</a>。</p>
<h3 id="inject相关"><a href="#inject相关" class="headerlink" title="inject相关"></a>inject相关</h3><p>这个部分主要介绍一些将JS/CSS自动插入到HTML的相关插件。</p>
<h4 id="wiredep"><a href="#wiredep" class="headerlink" title="wiredep"></a><a href="https://www.npmjs.com/package/wiredep" target="_blank" rel="external">wiredep</a></h4><p>wiredep就是wire dependence的意思，它的作用就是把<code>bower.json</code>中声明的dependence自动的包含到HTML中去。要插入文件，wiredep需要解决两个问题：</p>
<ul>
<li>插入的位置：wiredep通过识别HTML中的注释来识别插入位置，如</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- bower:css --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbower --&gt;</span></div><div class="line"><span class="comment">&lt;!-- bower:js --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbower --&gt;</span></div></pre></td></tr></table></figure>
<p>不同类型的文件被插入到不同的区块。</p>
<ul>
<li>插入什么文件：要插入的文件列表自然来自<code>bower.json</code>，每个bower安装的依赖库，根目录下边都有一个自己的<code>bower.json</code>文件，其中的<code>main</code>字段指明了使用这个库需要包含的文件，wiredep最终包含的文件列表就来自这个字段。有些情况下，库自身的<code>bower.json</code>的main字段可能会多包含文件或少包含文件，如果想要定制这个列表，则可以在自己的<code>bower.json</code>中使用<code>overrides</code>字段，如下面的代码覆盖了<code>mdi</code>这个库的<code>main</code>字段。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="string">"overrides"</span>: &#123;</div><div class="line">  <span class="string">"mdi"</span>: &#123;</div><div class="line">    <span class="string">"main"</span>: [</div><div class="line">      <span class="string">"css/materialdesignicons.css"</span></div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>wiredep插件支持很多参数，常用的主要有两个：</p>
<ul>
<li>bowerJson：指定<code>bower.json</code>的内容，注意这个字段不是<code>bower.json</code>文件的位置，这个参数需要使用require后的结果赋值：<code>require(&#39;bower.json&#39;)</code>。</li>
<li>directory：指定存放bower安装后的依赖包的路径，通常是bower_components。注意最终插入到HTML中的文件列表的路径是index.html文件相对于本文件夹的相对路径。</li>
</ul>
<p>使用wiredep也比较简单，直接把它传入到stream中即可，如<code>gulp.src(&#39;index.html&#39;).pipe(wiredep(options))</code>。</p>
<h4 id="gulp-inject"><a href="#gulp-inject" class="headerlink" title="gulp-inject"></a><a href="https://www.npmjs.com/package/gulp-inject" target="_blank" rel="external">gulp-inject</a></h4><p>这个插件的作用与wiredep类似，不同的是可以自己任意指定需要插入文件的列表。它同样是利用注释来寻找插入的位置，它识别的默认注释为<code>&lt;!-- inject:js --&gt;</code>，但更加智能：</p>
<ul>
<li>支持各种模板语言：可以根据<code>gulp.src</code>指定的源文件自动识别注释和插入内容，除了支持HTML外，还支持jade、haml等。若源为jade文件，则识别的注释为<code>//- inject:js</code>，插入的内容为：<code>script(src=&quot;&lt;filename&gt;.js&quot;)</code>。</li>
<li>配置非常灵活：<ul>
<li>name：默认识别的注释标签格式为<code>&lt;!-- name:ext --&gt;</code>，这里的name默认值就是“inject”，而ext的默认值是要插入的文件的扩展名。那么name属性可配置意味着可以添加自定义的插入区块，如<code>&lt;!-- production:js --&gt;</code>，这个标签可以只插入生产环境需要包含的JS文件。</li>
<li>starttag和endtag：支持自定义需要识别的注释内容。</li>
<li>addPrefix和addSuffix：支持在插入文件的路径上自定义前缀、后缀。</li>
<li>relative：指定插入文件的路径是否为相对路径。</li>
<li>ingorePath：指定插入文件的路径前面会忽略掉指定的路径。</li>
<li>read：这个参数通常给false，不需要真正的去读取文件。</li>
</ul>
</li>
</ul>
<p>这个插件的使用场景通常是，我们需要index里有多个区块，比如上面name的例子，只有当为production环境编译的时候才去包含相关的文件。</p>
<h4 id="gulp-useref-与-gulp-rev、gulp-rev-replace"><a href="#gulp-useref-与-gulp-rev、gulp-rev-replace" class="headerlink" title="gulp-useref 与 gulp-rev、gulp-rev-replace"></a><a href="https://www.npmjs.com/package/gulp-useref" target="_blank" rel="external">gulp-useref</a> 与 <a href="https://www.npmjs.com/package/gulp-rev" target="_blank" rel="external">gulp-rev</a>、<a href="https://www.npmjs.com/package/gulp-rev-replace" target="_blank" rel="external">gulp-rev-replace</a></h4><p>这三个工具之所以放在一起讲，是因为它们一般都是一起使用的。它们要解决什么问题呢？通过上面的wiredep也好，gulp-inject也好，插入了一堆JS、CSS文件到HTML中，一旦部署到生产环境，这么多文件必然是要合并压缩的。光是压缩还不够，为了解决缓存问题，每次合并压缩后要给最终的文件加hash，这样每次文件内容一变动，hash也会跟着变动，就不存在浏览器依然使用缓存的老文件的问题。这样得到最终的文件以后，肯定还要将这个文件替换回HTML中去，一大堆的script和link标签替换成最终合并压缩带hash的版本。</p>
<p>前面啰啰嗦嗦的一大堆工作就是这三个插件要解决的问题了。首先，gulp-useref根据注释将HTML中需要合并压缩的区块找出来，对区块内的所有文件进行合并。<strong>注意：它只负责合并，不负责压缩！</strong>所以合并出来的文件我们要自行压缩，压缩以后调用gulp-rev负责在文件名后追加hash。最后调用gulp-rev-replace负责把最终的文件名替换回HTML中去。扯了大半天，还是直接上例子吧。先来看看HTML中的注释：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- build:css static/styles/lib.css --&gt;</span></div><div class="line"><span class="comment">&lt;!-- bower:css --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbower --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- build:css static/styles/app.css --&gt;</span></div><div class="line"><span class="comment">&lt;!-- inject:css --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endinject --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- build:js static/js/lib.js --&gt;</span></div><div class="line"><span class="comment">&lt;!-- bower:js --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbower --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- build:js static/js/app.js --&gt;</span></div><div class="line"><span class="comment">&lt;!-- inject:js --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endinject --&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></div></pre></td></tr></table></figure>
<p>gulp-useref识别的就是build开头的注释，build后面首先跟的是类型扩展名，然后后面的路径就是build区块中的所有文件进行合并后的文件路径，这个相对路径是相对于这个HTML的路径。上面的例子中我们用build区块把bower和inject进来的文件包起来，这些文件就可以被gulp-useref合并了。再来看gulp中useref相关task的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> assets = $.useref.assets(&#123;<span class="attr">searchPath</span>: <span class="string">'app/src/'</span>&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> cssFilter = $.filter(<span class="string">'**/*.css'</span>);</div><div class="line"><span class="keyword">var</span> jsAppFilter = $.filter(<span class="string">'**/app.js'</span>);</div><div class="line"><span class="keyword">var</span> jslibFilter = $.filter(<span class="string">'**/lib.js'</span>);</div><div class="line"></div><div class="line"><span class="keyword">return</span> gulp</div><div class="line">    .src(<span class="string">'index.html'</span>)</div><div class="line">    .pipe(assets)</div><div class="line">    .pipe(cssFilter)</div><div class="line">    .pipe($.csso())</div><div class="line">    .pipe(cssFilter.restore())</div><div class="line">    .pipe(jsAppFilter)</div><div class="line">    .pipe($.uglify())</div><div class="line">    .pipe(getHeader())</div><div class="line">    .pipe(jsAppFilter.restore())</div><div class="line">    .pipe(jslibFilter)</div><div class="line">    .pipe($.uglify())</div><div class="line">    .pipe(jslibFilter.restore())</div><div class="line">    .pipe($.rev())</div><div class="line">    .pipe(assets.restore())</div><div class="line">    .pipe($.useref())</div><div class="line">    .pipe($.revReplace())</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>));</div></pre></td></tr></table></figure>
<p>首先一上来，先调用<code>$.useref.assets()</code>函数，这个函数返回一个stream，包含已经合并后的文件。可以尝试在第9行后面加上前面介绍过的gulp-print插件<code>.pipe($.print())</code>，打印出stream里的文件，发现就是前面HTML中4个build注释块后面的4个文件。注意这里调用的时候跟了一个<code>searchPath</code>的参数，它的用处就是指定从哪个路径开始寻找build区块底下的文件。比如build区块底下有这么一行<code>&lt;script src=&quot;static/js/a.js&quot;&gt;&lt;/script&gt;</code>，那最终gulp-useref将从这个路径<code>app/src/static/js/a.js</code>找到这个文件。第3到5行定义了3个filter，这主要是为了后面压缩准备的。下面正式看stream的pipe流程。先选出要处理的HTML文件，然后调用刚才得到的<code>assets</code>得到合并后的4个文件，第10到12行筛选出合并后的CSS文件进行压缩（压缩类插件下篇文章再讲），第13到16行筛选出app.js进行压缩，第17到19行筛选出lib.js进行压缩。之所以要区别对待app.js和lib.js，是因为app.js是我们自己写的代码，压缩后要加上header（第15行，使用前面介绍过的gulp-header插件），而lib.js是第三方的各种库，直接压缩即可。后面调用gulp-rev给压缩后的4个文件加hash，然后调用<code>assets.restore()</code>将src源换回HTML文件，这是为了后面调用<code>$.useref()</code>，因为<code>$.useref()</code>做替换的src源是HTML文件，同样后面调用gulp-rev-replace将带hash的文件替换回HTML，它要求的src源也必须是HTML文件。这里的顺序很重要，因为这几个插件接受的源不一样，gulp-rev接受的是JS、CSS文件，而gulp-useref和gulp-rev-replace接受的是HTML。还有一个问题：gulp-rev-replace是怎么知道gulp-rev进行hash前后的文件名对应关系呢？其实gulp-rev会生成一个manifest的文件，内容是类似下面的JSON：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"static/styles/lib.css"</span>: <span class="string">"static/styles/lib-d41d8cd98f.css"</span></div><div class="line">    <span class="string">"static/js/lib.js"</span>: <span class="string">"static/js/lib-273c2cin3f.js"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然这个文件默认是不会生成在文件系统里的，可以通过<code>.pipe($.rev.manifest())</code>将这个文件保存到本地。有了这个文件，gulp-rev-replace甚至可以脱离gulp-rev独立工作哦！</p>
<p>好了，这篇就到这里，还有好多工具没介绍到，留着给下篇吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写&lt;a href=&quot;https://github.com/PinkyJie/generator-aio-angular&quot;&gt;generator-aio-angular&lt;/a&gt;的过程中，gulp这一块发现了很多非常实用的插件，大大的增加了能自动化的范围，这篇文章就分门别类的简单介绍下常用的gulp插件吧。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AngularJS" scheme="http://pinkyjie.com/tags/AngularJS/"/>
    
      <category term="插件" scheme="http://pinkyjie.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="gulp" scheme="http://pinkyjie.com/tags/gulp/"/>
    
      <category term="generator-aio-angular" scheme="http://pinkyjie.com/tags/generator-aio-angular/"/>
    
  </entry>
  
  <entry>
    <title>基于ui-router的简单布局及其他应用</title>
    <link href="http://pinkyjie.com/2015/07/25/simple-layout-based-on-ui-router/"/>
    <id>http://pinkyjie.com/2015/07/25/simple-layout-based-on-ui-router/</id>
    <published>2015-07-25T05:24:44.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/angular-ui/ui-router" target="_blank" rel="external">ui-router</a>与Angular自带的ngRoute最大的区别就是它是基于状态（state）的，而不是基于URL的。它带来的最大的便捷性就在于：</p>
<ul>
<li>支持多个ui-view</li>
<li>支持ui-view的嵌套</li>
<li>支持state的继承（嵌套）</li>
</ul>
<p>这篇文章就简单谈谈怎么利用ui-router去搭建一个网站的布局以及实现一些便捷的小功能。</p>
<a id="more"></a>
<h3 id="一个ui-view对应一块区域"><a href="#一个ui-view对应一块区域" class="headerlink" title="一个ui-view对应一块区域"></a>一个ui-view对应一块区域</h3><p>先来看一张网站的模块图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/simple-layout-based-on-ui-router-1.png" class="center-img" title="图1">
<p>可以看到整个页面分为5个模块，有了多ui-view的支持，我们可以非常直观的用一个ui-view来对应一个模块，那么我们的主template（即<code>index.jade</code>，单页面应用通常只有一个index页面）可以这么写（使用<a href="http://jade-lang.com/" target="_blank" rel="external">Jade</a>模板引擎）：</p>
<figure class="highlight plain"><figcaption><span>index.jade</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.wrapper</div><div class="line">    header.header-view(ui-view=&quot;header&quot;)</div><div class="line">    .content</div><div class="line">        .sidebar-view(ui-view=&quot;sidebar&quot;)</div><div class="line">        .main-content</div><div class="line">            .breadcrumb-view(ui-view=&quot;breadcrumb&quot;)</div><div class="line">            .main-view(ui-view=&quot;main&quot;)</div><div class="line">    footer.footer-view(ui-view=&quot;footer&quot;)</div></pre></td></tr></table></figure>
<p>这样的结构非常清晰，整个页面分为5个模块，不同的模块由不同的controller来处理：</p>
<figure class="highlight javascript"><figcaption><span>layout.route.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'root'</span>, &#123;</div><div class="line">    <span class="attr">abstract</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">url</span>: <span class="string">''</span>,</div><div class="line">    <span class="attr">views</span>: &#123;</div><div class="line">        <span class="string">'header'</span>: &#123;</div><div class="line">            <span class="attr">templateUrl</span>: <span class="string">'static/layout/header.html'</span>,</div><div class="line">            <span class="attr">controller</span>: <span class="string">'HeaderController as vm'</span></div><div class="line">        &#125;,</div><div class="line">        <span class="string">'sidebar'</span>: &#123;</div><div class="line">            <span class="attr">templateUrl</span>: <span class="string">'static/layout/sidebar.html'</span>,</div><div class="line">            <span class="attr">controller</span>: <span class="string">'SidebarController as vm'</span></div><div class="line">        &#125;,</div><div class="line">        <span class="string">'breadcrumb'</span>: &#123;</div><div class="line">            <span class="attr">templateUrl</span>: <span class="string">'static/layout/breadcrumb.html'</span>,</div><div class="line">            <span class="attr">controller</span>: <span class="string">'BreadcrumbController as vm'</span></div><div class="line">        &#125;,</div><div class="line">        <span class="string">'footer'</span>: &#123;</div><div class="line">            <span class="attr">templateUrl</span>: <span class="string">'static/layout/footer.html'</span>,</div><div class="line">            <span class="attr">controller</span>: <span class="string">'FooterController as vm'</span></div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>眼尖的同学可能注意到了，root这个state被定义成了抽象。之所以定义成抽象的原因是，我们并不直接使用root这个state（抽象的state不能被直接激活），这个state放在这里纯粹是为了继承用的。说到继承，有3个方面：</p>
<ul>
<li>子state可以沿用父state的View模板定义，通常公用的模块在大多数子state中都是不变的，即使用同样的template和controller，这些模块就可以直接定义在父state中。</li>
<li>子state可以覆盖父state的View模块定义，公用的模块在某些页面可能需要不同的template或controller，这时就需要覆盖定义。</li>
<li>子state可以添加新的View模块定义，自己独有的模块或非公用的模块需要自己添加。</li>
</ul>
<p>回到刚才那个截图上，这个页面是用户登录后的dashboard页面，显然并不是所有的页面都需要显示这5个模块，比如主页可能不需要Sidebar和Breadcrumb模块，未登录之前的其他页面也不需要显示Sidebar模块。那么主页home的state可以按如下代码定义：</p>
<figure class="highlight javascript"><figcaption><span>home.route.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'root.home'</span>, &#123;</div><div class="line">    <span class="attr">url</span>: <span class="string">'/'</span>,</div><div class="line">    <span class="attr">views</span>: &#123;</div><div class="line">        <span class="string">'sidebar@'</span>: &#123;&#125;,</div><div class="line">        <span class="string">'breadcrumb@'</span>: &#123;&#125;,</div><div class="line">        <span class="string">'main@'</span>: &#123;</div><div class="line">            <span class="attr">templateUrl</span>: <span class="string">'static/home/home.html'</span></div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注意state的名字，<code>parent.child</code>这种命名方式可以让ui-router知道state之间的继承关系。上面直接将Sidebar和Breadcrumb的模块赋空值，则这两个模块就不再显示了，而其他的模块如Header和Footer，则可以继承父state的定义，正常的显示。另外，我们在root这个state里没有定义Main的View模块，这是因为每个state的Main模块肯定是不一样的，所以属于非公用的模块，需要每个子state中自己来定义，可以看到上面的home state里自己定义了Main模块。</p>
<p>还有两点也值得一提，一个是root state的<code>url</code>为空，这是因为子state的url会自动追加在父state的url上，则home这个state的最终url为<code>&#39;&#39; + &#39;/&#39;</code>。另外一个，注意到在子state中定义View时，ui-view的名字后面都加了<code>@</code>符号，这是ui-router约定俗成的写法：<code>viewname@statename</code>，称为“View绝对定位”。这里省略了后面的statename，代表的就是index页面定义的<code>ui-view=&quot;viewname&quot;</code>。当然，有“View绝对定位”，自然就有“View相对定位”，相对定位的方法就是只写一个viewname，此时这个View指的就是父state中指定的template里对应的<code>ui-view=viewname</code>。关于相对和绝对定位，可以看<a href="https://github.com/angular-ui/ui-router/wiki/Multiple-Named-Views#view-names---relative-vs-absolute-names" target="_blank" rel="external">官方WIKI中的介绍</a>。</p>
<p>到这里大致的布局架子就搭起来了，每个页面可以定义一个自己的state继承自root，覆盖或添加新的View模块，同样子state还可以派生出另外的子state，非常灵活，整个布局结构也非常清晰。</p>
<h3 id="ui-router带来的其他便利"><a href="#ui-router带来的其他便利" class="headerlink" title="ui-router带来的其他便利"></a>ui-router带来的其他便利</h3><p>除了简单的布局，ui-router还支持自定义data，这个data也是可以随state进行继承的。这就给了我们很多畅想，通过把一些配置放在这个data里可以实现很多有意思的应用。下面就简单讲几个<a href="https://github.com/PinkyJie/generator-aio-angular" target="_blank" rel="external">generator-aio-angular</a>里的应用场景。</p>
<h4 id="页面的title和class"><a href="#页面的title和class" class="headerlink" title="页面的title和class"></a>页面的title和class</h4><p>单页面应用必然要解决的一个问题就是页面的title需要跟着不同的state进行变化，这就需要每次进行state切换时页面的标题需要跟着变化。而class的变化是同样的意思，我希望每次state变化时都能在页面的body标签上加一个顶级的class样式，这样同样的一个Header的ui-view，我就可以定义其在home页面和在dashboard页面不同的样式了。通常在index页面中需要这么写：</p>
<figure class="highlight plain"><figcaption><span>index.jade</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">head</div><div class="line">    title(ng-bind=&quot;title&quot;)</div><div class="line">body(ng-class=&quot;_class + &apos;-page&apos;&quot;)</div></pre></td></tr></table></figure>
<p>显然，这两个变量<code>title</code>和<code>_class</code>都需要定义在<code>$rootScope</code>上面，以前我都是在controller里做这个赋值的，但语义上讲它又不太属于controller的职责。有了ui-router的自定义data，可以把这两个变量放在state的config当中了：</p>
<figure class="highlight javascript"><figcaption><span>home.route.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'root.home'</span>, &#123;</div><div class="line">    <span class="attr">data</span>: &#123;</div><div class="line">        <span class="attr">title</span>: <span class="string">'Home'</span>,</div><div class="line">        <span class="attr">_class</span>: <span class="string">'home'</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>然后，在<code>$stateChangeSuccess</code>的事件响应中统一来将新state中的这两个变量赋值到<code>$rootScope</code>上去：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$rootScope.$on(<span class="string">'$stateChangeSuccess'</span>,</div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">event, toState, toParams, fromState, fromParams</span>) </span>&#123;</div><div class="line">        $rootScope.title = toState.data.title;</div><div class="line">        $rootScope._class = toState.data._class;</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这样做代码的职责更加明确，集中在一个地方处理title和class的变动，也比分散在不同的controller中更加简洁，更有优势。前面也有说到，data里的变量是可以随state进行继承的，倘若一个子state想和父state的title保持一致，那就不用再次定义了。</p>
<h4 id="Breadcrumb和Sidebar导航的实现"><a href="#Breadcrumb和Sidebar导航的实现" class="headerlink" title="Breadcrumb和Sidebar导航的实现"></a>Breadcrumb和Sidebar导航的实现</h4><p>说到导航，那肯定是与state有关的，与state有关的东西我们都可以尝试放到state的config定义中去。拿dashboard这个状态的定义来举例：</p>
<figure class="highlight javascript"><figcaption><span>dashboard.route.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$stateProvider.state(<span class="string">'root.dashboard'</span>, &#123;</div><div class="line">    <span class="attr">sidebar</span>: &#123;</div><div class="line">        <span class="attr">icon</span>: <span class="string">'mdi-view-dashboard'</span>,</div><div class="line">        <span class="attr">text</span>: <span class="string">'Dashboard'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">breadcrumb</span>: <span class="string">'Dashboard'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>想要什么值就可以放什么值，上面的例子中我们放了要显示的文本和显示的图标样式。还要注意一点，这里我们并没有将这个两项定义在data之中，而是直接定义在config对象里。这是因为data是可继承的，而这两种导航我们显然不希望子状态将其继承过去。</p>
<p>定义好了之后怎么使用呢？在BreadcrumbController和SidebarController中我们分别来处理这些逻辑。先来看看BreadcrumbController的实现：</p>
<figure class="highlight javascript"><figcaption><span>breadcrumb.controller.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    _applyNewBreadcrumb($state.current, $state.params);</div><div class="line">    $rootScope.$on(<span class="string">'$stateChangeSuccess'</span>,</div><div class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">event, toState, toParams, fromState, fromParams</span>) </span>&#123;</div><div class="line">            _applyNewBreadcrumb(toState, toParams);</div><div class="line">        &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> _applyNewBreadcrumb (<span class="params">state, params</span>) </span>&#123;</div><div class="line">    vm.breadcrumbs = [];</div><div class="line">    <span class="keyword">var</span> name = state.name;</div><div class="line">    <span class="keyword">var</span> stateNames = _getAncestorStates(name);</div><div class="line">    stateNames.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> stateConfig = $state.get(name);</div><div class="line">        <span class="keyword">var</span> breadcrumb = &#123;</div><div class="line">            <span class="attr">link</span>: name,</div><div class="line">            <span class="attr">text</span>: stateConfig.breadcrumb</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">if</span> (params) &#123;</div><div class="line">            breadcrumb.link = name + <span class="string">'('</span> + <span class="built_in">JSON</span>.stringify(params) + <span class="string">')'</span>;</div><div class="line">        &#125;</div><div class="line">        vm.breadcrumbs.push(breadcrumb);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> _getAncestorStates (<span class="params">stateName</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ancestors = [];</div><div class="line">    <span class="keyword">var</span> pieces = stateName.split(<span class="string">'.'</span>);</div><div class="line">    <span class="keyword">if</span> (pieces.length &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; pieces.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> name = pieces.slice(<span class="number">0</span>, i + <span class="number">1</span>);</div><div class="line">            ancestors.push(name.join(<span class="string">'.'</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ancestors;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们需要在两个地方处理面包屑导航，一个是面包屑这块区域第一次初始化的时候，需要应用当前的state，另外当每次state发生变化时还需要应用最新的state。主要的逻辑都放在<code>_applyNewBreadcrumb</code>这个函数中实现，它先拿到自己的所有父state，然后从包括自身在内的所有state的config定义中提取信息，组装成breadcrumb对象最终应用于模板上。同样，SidebarController的实现与之类似，不同的是Sidebar只需要在第一次初始化时应用state即可：</p>
<figure class="highlight javascript"><figcaption><span>sidebar.controller.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// generate sidebar nav menus</span></div><div class="line">    vm.navs = _getNavMenus();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> _getNavMenus (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> navs = [];</div><div class="line">    <span class="keyword">var</span> allStates = routerHelper.getStates();</div><div class="line">    allStates.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">state</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (state.sidebar) &#123;</div><div class="line">            <span class="keyword">var</span> nav = state.sidebar;</div><div class="line">            nav.link = state.name;</div><div class="line">            navs.push(nav);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> navs;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，初始化时利用<code>routerHelper.getStates()</code>（即<code>$state.get()</code>）来拿到所有的state，然后将所有定义了sidebar的state应用于模板上。</p>
<p>有了这些自定义的数据，导航的实现是不是非常的简洁呢？</p>
<h4 id="简单的authentication和authorization"><a href="#简单的authentication和authorization" class="headerlink" title="简单的authentication和authorization"></a>简单的authentication和authorization</h4><p>传统的登录验证（authentication）和权限管理（authorization）都是通过route的resolve来实现的，有了ui-router，它们的实现还可以更简洁。直接来看一个例子，dashboard页面必须要登录以后才可以访问，那么它的state可以这样定义：</p>
<figure class="highlight javascript"><figcaption><span>dashboard.route.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">routerHelper.configureStates(getStates());</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStates</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">state</span>: <span class="string">'root.dashboard'</span>,</div><div class="line">            <span class="attr">config</span>: &#123;</div><div class="line">                <span class="attr">data</span>: &#123;</div><div class="line">                    <span class="attr">requireLogin</span>: <span class="literal">true</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到，直接在data里定义了一个自定义的属性<code>requireLogin</code>即可，是不是既简单又非常具有可读性。显然，ui-router自己并不知道这个requireLogin的属性应该怎么处理，所以这里我们并没有直接调用<code>$stateProvider.state()</code>来定义state，而是封装了一个自己的<code>configureStates</code>函数（参考了<a href="https://github.com/johnpapa/generator-hottowel" target="_blank" rel="external">John Papa的实现</a>）。在这个函数中我们来处理requireLogin属性：</p>
<figure class="highlight javascript"><figcaption><span>route-helper.provider.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">configureStates</span> (<span class="params">states</span>) </span>&#123;</div><div class="line">    states.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">state</span>) </span>&#123;</div><div class="line">        <span class="comment">// add login check if requireLogin is true</span></div><div class="line">        <span class="keyword">var</span> data = state.config.data;</div><div class="line">        <span class="keyword">if</span> (data &amp;&amp; data.requireLogin === <span class="literal">true</span>) &#123;</div><div class="line">            state.config.resolve = angular.extend(</div><div class="line">                state.config.resolve || &#123;&#125;,</div><div class="line">                &#123;<span class="string">'loginResolve'</span>: resolve.login&#125;</div><div class="line">            );</div><div class="line">        &#125;</div><div class="line">        state.config.resolve =</div><div class="line">            angular.extend(state.config.resolve || &#123;&#125;, config.resolveAlways);</div><div class="line">        $stateProvider.state(state.state, state.config);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个函数中，我们先判断，如果一个state定义了requireLogin属性，则给它添加一个loginResolve检查它是否已经正常登录了。另外，有了这个自定义的函数，我们还可以为所有state添加统一的resolve（11、12行）。route-helper.provider.js的完整实现可以参见<a href="https://github.com/PinkyJie/generator-aio-angular/blob/master/app/templates/client/source/app/helper/router-helper.provider.js" target="_blank" rel="external">generator-aio-angular项目</a>，<a href="https://github.com/PinkyJie/generator-aio-angular/blob/master/app/templates/client/source/app/core/resolve.service.js" target="_blank" rel="external">loginResolve的实现</a>也在里面哟。</p>
<p>同样，依葫芦画瓢，授权同样可以通过添加类似<code>onlyAllowed: &#39;admin&#39;</code>等类似的定义来实现。这里就不多谈了，值得一提的是resolve本身就是可以被子state继承的，这也是非常符合逻辑的，如果父state需要权限，那么子state也必然需要。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到，ui-router不仅让整个布局结构更加清晰，更加易于理解，还带来了很多其他有意思的便捷特性。它让我们把跟页面路由相关的配置都统一在一个地方管理，使整个程序更加的模块化。还在用老ngRoute的同学不妨一试，根本停不下来啊！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/angular-ui/ui-router&quot;&gt;ui-router&lt;/a&gt;与Angular自带的ngRoute最大的区别就是它是基于状态（state）的，而不是基于URL的。它带来的最大的便捷性就在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持多个ui-view&lt;/li&gt;
&lt;li&gt;支持ui-view的嵌套&lt;/li&gt;
&lt;li&gt;支持state的继承（嵌套）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章就简单谈谈怎么利用ui-router去搭建一个网站的布局以及实现一些便捷的小功能。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AngularJS" scheme="http://pinkyjie.com/tags/AngularJS/"/>
    
      <category term="generator-aio-angular" scheme="http://pinkyjie.com/tags/generator-aio-angular/"/>
    
      <category term="ui-router" scheme="http://pinkyjie.com/tags/ui-router/"/>
    
      <category term="breadcrumb" scheme="http://pinkyjie.com/tags/breadcrumb/"/>
    
      <category term="sidebar" scheme="http://pinkyjie.com/tags/sidebar/"/>
    
      <category term="authentication" scheme="http://pinkyjie.com/tags/authentication/"/>
    
      <category term="authorization" scheme="http://pinkyjie.com/tags/authorization/"/>
    
  </entry>
  
  <entry>
    <title>Promise，其实我真的不懂你</title>
    <link href="http://pinkyjie.com/2015/07/20/promise-actually-i-really-do-not-know-you/"/>
    <id>http://pinkyjie.com/2015/07/20/promise-actually-i-really-do-not-know-you/</id>
    <published>2015-07-20T14:25:26.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>写过Angular的service的孩子肯定对Promise不陌生了吧，这玩意的出现可以说是极大改变了异步编程的写法，告别了让代码不停横向发展的<a href="http://callbackhell.com/" target="_blank" rel="external">Callback Hell</a>。一直以来自己都是按照网上流行的写法来写Promise的，并没有觉得有什么问题，直到看到这篇神一般的文章：<a href="http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="external">We have a problem with promises</a>，以及文中提到的Bluebird的Wiki中关于<a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern" target="_blank" rel="external">Promise的Anti-pattern</a>，顿时有一种醍醐灌顶的感觉，敢情自己以前根本就没理解Promise啊。这篇文章就来讲讲最近在Promise上的心得体会。</p>
<a id="more"></a>
<p>开始前先放两张Callback Hell的搞笑图吧，虽然不是我们今天的主题，但是太搞笑啦！哈哈哈！</p>
<blockquote>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/promise-actually-i-really-do-not-know-you-1.png" class="center-img" title="图1">
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/promise-actually-i-really-do-not-know-you-2.png" class="center-img" title="图2">
</blockquote>
<h3 id="Promise应该这么写"><a href="#Promise应该这么写" class="headerlink" title="Promise应该这么写"></a>Promise应该这么写</h3><p>先来看一下原先我是怎么写controller和service里的Promise的。</p>
<figure class="highlight plain"><figcaption><span>service-old.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function login (email, password) &#123;</div><div class="line">    var d = $q.defer();</div><div class="line">    var req = &#123;</div><div class="line">        email: email,</div><div class="line">        password: password</div><div class="line">    &#125;;</div><div class="line">    $http.post(&apos;api/user/login&apos;, req)</div><div class="line">        .success(_success)</div><div class="line">        .error(_fail);</div><div class="line">    return d.promise;</div><div class="line"></div><div class="line">    function _success (response, status) &#123;</div><div class="line">        if (status === 200 &amp;&amp; response.code === 0) &#123;</div><div class="line">            d.resolve(response.result.user);</div><div class="line">        &#125; else &#123;</div><div class="line">            _clearUser();</div><div class="line">            d.reject(response.message);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function _fail () &#123;</div><div class="line">        _clearUser();</div><div class="line">        d.reject(&apos;$SERVER&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>controller-old.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">userAPI.login(credential.email, credential.password)</div><div class="line">    .then(_success, _error);</div><div class="line"></div><div class="line">function _success (data) &#123;</div><div class="line">    // xxx</div><div class="line">&#125;</div><div class="line"></div><div class="line">function _error (reason) &#123;</div><div class="line">    // xxx</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>乍一看没啥问题啊，就应该这么写的哇。先放着不管，我们再看看更改后的写法，有对比才有发现嘛：</p>
<figure class="highlight plain"><figcaption><span>service-new.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function login (email, password) &#123;</div><div class="line">    var req = &#123;</div><div class="line">        email: email,</div><div class="line">        password: password</div><div class="line">    &#125;;</div><div class="line">    return $http.post(&apos;api/user/login&apos;, req)</div><div class="line">        .then(_success)</div><div class="line">        .catch(_fail);</div><div class="line"></div><div class="line">    function _success (response) &#123;</div><div class="line">        var data = response.data;</div><div class="line">        if (response.status === 200 &amp;&amp; data.code === 0) &#123;</div><div class="line">            return data.result.user;</div><div class="line">        &#125; else &#123;</div><div class="line">            return $q.reject(data.message);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function _fail (reason) &#123;</div><div class="line">        _clearUser();</div><div class="line">        return $q.reject(reason || &apos;$SERVER&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>controller-new.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">userAPI.login(credential.email, credential.password)</div><div class="line">    .then(_success)</div><div class="line">    .catch(_error);</div><div class="line"></div><div class="line">function _success (data) &#123;</div><div class="line">    // xxx</div><div class="line">&#125;</div><div class="line"></div><div class="line">function _error (reason) &#123;</div><div class="line">    // xxx</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看出区别了吗？我来捋一捋：</p>
<ul>
<li>抛弃了<code>$q.defer()</code>，也就是不使用deferred对象</li>
<li>不使用then的第二个参数，而是直接<code>then().catch()</code></li>
<li>文件<code>service-old.js</code>的第15行的那句<code>_clearUser()</code>在<code>service-new.js</code>中不见了，而且<code>_fail</code>函数的写法咋还改了呢</li>
<li>抛弃了$http的success和error方法</li>
</ul>
<p>下面我们就一个一个来解释！</p>
<h3 id="为啥不要用Deferred对象？"><a href="#为啥不要用Deferred对象？" class="headerlink" title="为啥不要用Deferred对象？"></a>为啥不要用Deferred对象？</h3><p>其实这个问题可以换个方式问：为啥要用Deferred对象？不靠谱版回答：你傻啊，因为很多教程里就是这么用的笨蛋！靠谱版回答：因为我们要指明这个异步API调用返回的两种状态啊，成功返回就resolve掉这个Promise，失败就reject掉。但你没有想过，<code>$http.post()</code>本来就是一个Promise，为啥还要用<code>$q.defer()</code>构造另一个Promise来再包一层呢？换句话讲，人家<code>$http.post()</code>本来就知道什么时候应该resolve，什么时候应该reject，你Deferred对象瞎操心啥玩意！人家<code>$http.post()</code>返回的本来就是一个Promise对象，何必返回<code>deferred.promise</code>这另一个Promise对象呢。那没有deferred对象怎么resolve和reject呢？很简单，<strong>想要resolve就直接return你想resolve的值，想要reject就直接调用<code>$q.reject()</code></strong>。这就是为什么在<code>service-new.js</code>的第13行我们直接return想要返回的值。那这个值controller可以正常的接受到吗？Promise的链式调用保证了这种机制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise().then(handlerB).then(handlerC);</div></pre></td></tr></table></figure>
<p>这里hanlderB会在promise结束或执行，并且参数是promise的return值，即<code>handlerB(returnValueOfPromise)</code>，同样，handlerC也是一样，即<code>handlerC(returnValueOfHandlerB)</code>。也就是说，<strong>Promise链式调用始终返回上一个Promise中return的值</strong>。Angular中的interceptor正是利用这个机制工作的。</p>
<p>那么有人要问了，什么时候才需要用Deferred对象呢？前面说了，deferred对象是又包了一层Promise，那显然，里面如果是非Promise的异步调用，用它包住就成为正常的Promise了！比如<code>setTimeout</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncGreet</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> deferred = $q.defer();</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (okToGreet(name)) &#123;</div><div class="line">            deferred.resolve(<span class="string">'Hello, '</span> + name + <span class="string">'!'</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            deferred.reject(<span class="string">'Greeting '</span> + name + <span class="string">' is not allowed.'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">    <span class="keyword">return</span> deferred.promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个来自官方文档的例子就很好说明了问题。Deferred对象的意义在于将非Promise的异步流程包装成Promise。</p>
<h3 id="为啥不让then里面传俩参数？"><a href="#为啥不让then里面传俩参数？" class="headerlink" title="为啥不让then里面传俩参数？"></a>为啥不让then里面传俩参数？</h3><p>文档里说了，<code>catch(errorCallback) – shorthand for promise.then(null, errorCallback)</code>，你这<code>.then(callback1).catch(callback2)</code>就是一个简写嘛，我用<code>then(callback1, callback2)</code>为啥就不推荐呢？这里我要说：文档里面写错了！两种写法并不是完全等价的！区别就在于：</p>
<ul>
<li><code>promise.then(callback1, callback2)</code>中，如果callback1抛错，callback2无法捕捉到。也就是说执行了callback1，就不会执行callback2。只有前面的promise抛错时才会进入callback2。</li>
<li>而<code>promise.then(callback1).catch(callback2)</code>中，如果callback1抛错，则callback2可以捕捉到。当然，promise如果抛错的话callback2自然也会被执行。那就是说，存在一种可能性，callback1和callback2都会被执行，那就是promise没抛错，但callback1抛错了。而这种情形常见吗？回答是非常常见，就拿我们上面的例子，server虽然正常返回了(promise没抛错)，但正常的返回中检查出code不等于0，这个时候我们就需要“抛错”。这里的抛错加了引号，因为这里的“抛错”不只包含显式的<code>throw</code>出一个错，而且包括reject。这样的好处非常明显，我的callback2不需要care这个“错”是上面哪个Promise（注意，因为<code>then()</code>同样返回一个新的Promise）抛出来的，是第一个promise中API请求因为网络原因（非200）挂了，还是第二个promise中发现账号密码不正确，这些我都不管，我希望在callback2中统一的处理这些异常。这也解释了我们为什么在<code>service-new.js</code>中的第15行删掉了<code>_clearUser()</code>调用，因为我们在<code>_success</code>中的分支中调用了<code>return $q.reject(data.message)</code>，这样就会进入后面的<code>_fail</code>函数，而里面有调用<code>_clearUser()</code>就可以了。并且，我们还给<code>_fail</code>加了参数，这个参数就用来接受callback1中<code>$q.reject()</code>传递过来的错误原因。</li>
</ul>
<h3 id="http的success和error方法咋不能用啊？"><a href="#http的success和error方法咋不能用啊？" class="headerlink" title="$http的success和error方法咋不能用啊？"></a>$http的success和error方法咋不能用啊？</h3><p>为啥不让用这个两个方便的函数呢，你看，它直接把<code>response</code>对象给你拆成四个参数，多方便啊！说实话，我也挺喜欢这个便利性的，但如果我们尝试将<code>service-new.js</code>中第7、8两行的<code>.then().catch()</code>替换成Angular的$http给我们提供的<code>.success().error()</code>会怎么样呢？嗒嗒！发现service是正常工作的，但是controller不正常了。在<code>controller-new.js</code>中的<code>_success</code>函数中，参数<code>data</code>并不是我们预想的在<code>service-new.js</code>中第13行返回的值，而是和<code>service-new.js</code>中<code>_success</code>函数的参数<code>response</code>一致。我香蕉你个疤瘌，博主，我读书少你怎么能骗我！你刚才不是说Promise在链式调用的时候总是拿到上一个Promise的返回值嘛，我controller里的<code>userAPI.login()</code>后面的then拿到的为什么不是service里<code>login</code>函数中返回的Promise的返回值呢！</p>
<p>我们再来捋一捋啊，倘若把service和controller写到一起，这个链式调用应该是这样的：<code>$http.post(xxx).success(_successInService).error(_fail).then(_successInController)</code>，这里最后的then里拿到的参数是第一个Promise，即<code>$http.post(xxx)</code>的返回结果。这是为什么呢？并不是博主骗人，问题就出在这个<code>success</code>和<code>error</code>上。我们可以看看这两个函数的实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">promise.success = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">        fn(response.data, response.status, response.headers, config);</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以发现，success和error的实现并不符合Promise的标准，它们并没有返回一个新的Promise（<code>then(...)</code>会生成的新Promise），而是将前面原来的Promise给返回了！所以我们拿到的才会是第一个Promise的返回值！这就是我不建议使用success和error这两个函数的原因，不光是我，官方也注意到了，可以参看<a href="https://github.com/angular/angular.js/issues/10508" target="_blank" rel="external">Github上面Angular的这个issue</a>，有人表示后面的版本将考虑废弃这两个不正规的函数。</p>
<h3 id="补充问题：以前的deferred-resolve-应该怎么整呢？"><a href="#补充问题：以前的deferred-resolve-应该怎么整呢？" class="headerlink" title="补充问题：以前的deferred.resolve()应该怎么整呢？"></a>补充问题：以前的<code>deferred.resolve()</code>应该怎么整呢？</h3><p>这个场景也是比较常见的，有些情况下，我们只是想resolve一个Promise，并不想具体的返回什么值。比如，一个API去请求用户的session还在不在，在的话返回0，不在的话返回1。我们的逻辑就是在的话我不管，不在的话才有所行动，比如登出用户什么的。这个时候我们就对<code>then(callback1).catch(callback2)</code>里的callback1不管兴趣了，那还需要手动的去写一句<code>return &#39;&#39;;</code>或<code>return;</code>吗？答案是否定的，这种情形只需要写<code>.catch()</code>就好了，直接删掉<code>then()</code>。</p>
<h3 id="还有问题？"><a href="#还有问题？" class="headerlink" title="还有问题？"></a>还有问题？</h3><p>在提别的问题之前，还是强烈建议阅读开篇推荐的那篇<a href="http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="external">We have a problem with promises</a>，里面非常详细的讲解了各种关于Promise的误区！用醍醐灌顶来形容一点也不为过。</p>
<p>博主这整篇光列几行代码，也没有可运行的东西给看看有啥意思啊！有！完整的程序可以看我写的一个generator：<a href="https://github.com/PinkyJie/generator-aio-angular" target="_blank" rel="external">generator-aio-angular</a>。也可以看看我如何将原来的写法重构成推荐的写法，都在<a href="https://github.com/PinkyJie/generator-aio-angular/commit/18de9f01f73eff138ea1c42a08444e72b03bdfbb" target="_blank" rel="external">这个commit</a>里。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写过Angular的service的孩子肯定对Promise不陌生了吧，这玩意的出现可以说是极大改变了异步编程的写法，告别了让代码不停横向发展的&lt;a href=&quot;http://callbackhell.com/&quot;&gt;Callback Hell&lt;/a&gt;。一直以来自己都是按照网上流行的写法来写Promise的，并没有觉得有什么问题，直到看到这篇神一般的文章：&lt;a href=&quot;http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html&quot;&gt;We have a problem with promises&lt;/a&gt;，以及文中提到的Bluebird的Wiki中关于&lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern&quot;&gt;Promise的Anti-pattern&lt;/a&gt;，顿时有一种醍醐灌顶的感觉，敢情自己以前根本就没理解Promise啊。这篇文章就来讲讲最近在Promise上的心得体会。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AngularJS" scheme="http://pinkyjie.com/tags/AngularJS/"/>
    
      <category term="generator-aio-angular" scheme="http://pinkyjie.com/tags/generator-aio-angular/"/>
    
      <category term="promise" scheme="http://pinkyjie.com/tags/promise/"/>
    
      <category term="异步编程" scheme="http://pinkyjie.com/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>重构你的gulpfile</title>
    <link href="http://pinkyjie.com/2015/03/24/refactor-your-gulpfile/"/>
    <id>http://pinkyjie.com/2015/03/24/refactor-your-gulpfile/</id>
    <published>2015-03-24T14:02:22.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在公司的新项目中尝试使用gulp替换grunt，体验非常棒！两者最大的区别就是grunt整个就像是一个配置文件，而gulp更像代码。这样的好处就是调试起来更方便直观。另外，利用Node.js的stream概念，让gulp的task看起来像管道一样，输入连着输出，输出又导入另一个输入，流程非常清晰易懂。自打用了这个，就再也不想回到闹心的grunt了。在用了一段时间后，问题来了：不知不觉gulpfile.js已经超过1000行了！每次要修改一个task就要费劲找半天，各种路径也是一团糟，非常难以维护了。那么，是时候重构gulpfile了！</p>
<a id="more"></a>
<h3 id="把各种配置独立出去"><a href="#把各种配置独立出去" class="headerlink" title="把各种配置独立出去"></a>把各种配置独立出去</h3><p>对于一个复杂的项目来说，在gulpfile里可能各种文件路径的定义都要占掉好多行，各种各样其他的配置就更不用多说了。所以重构的第一步，就是将这些配置提取到一个独立的文件中去。官方<a href="https://github.com/gulpjs/gulp/blob/master/docs/recipes/using-external-config-file.md" target="_blank" rel="external">有一篇recipe</a>有说到这个。在这篇recipe中，直接将所有的配置放入一个json文件中去，然后在gulpfile中使用require引入。当然，json可能不是太灵活，可以将其写成一个Node.js的模块。</p>
<figure class="highlight plain"><figcaption><span>gulp.config.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.exports = function () &#123;</div><div class="line">  var client = &apos;./src/client/&apos;;</div><div class="line">  var server = &apos;./src/server/&apos;;</div><div class="line">  var config = &#123;</div><div class="line">    client: client,</div><div class="line">    server: server,</div><div class="line">    js: client + &apos;**/*.js&apos;,</div><div class="line">    css: client + &apos;**/*.css&apos;</div><div class="line">  &#125;;</div><div class="line">  return config;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样，在gulpfile中使用<code>var config = require(&#39;./gulp.config&#39;)();</code>即可将该配置文件引入进来了。</p>
<h3 id="将task分割到不同的文件中"><a href="#将task分割到不同的文件中" class="headerlink" title="将task分割到不同的文件中"></a>将task分割到不同的文件中</h3><p>配置只是gulpfile的一小部分，其余的大部分都是具体的task。要想更清晰的管理各种task，最好的方法是将不同的task分类，每一类task分割到一个文件中去。比如clean的放一个文件，编译stylus的放一个文件等等。关于分割task到不同的文件，官方也有<a href="https://github.com/gulpjs/gulp/blob/master/docs/recipes/split-tasks-across-multiple-files.md" target="_blank" rel="external">一篇recipe</a>来专门讲这个。这篇recipe中介绍了一个module叫<a href="https://github.com/aseemk/requireDir" target="_blank" rel="external"><code>require-dir</code></a>，使用这个模块就可以简单粗暴的将各个task扔到不同的文件中去。文件夹结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gulpfile.js</div><div class="line">tasks/</div><div class="line">├── css.task.js</div><div class="line">└── js.task.js</div></pre></td></tr></table></figure>
<p>3个文件的内容分别是：</p>
<figure class="highlight plain"><figcaption><span>gulpfile.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var requireDir = require(&apos;require-dir&apos;);</div><div class="line">requireDir(&apos;./tasks&apos;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>css.task.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var gulp = require(&apos;gulp&apos;);</div><div class="line">gulp.task(&apos;css&apos;, function () &#123;</div><div class="line">  console.log(&apos;css task&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>js.task.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var gulp = require(&apos;gulp&apos;);</div><div class="line">gulp.task(&apos;js&apos;, function () &#123;</div><div class="line">  console.log(&apos;js task&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种方法重构的成本非常小，只需简单的将任务移到对应的文件中，无需其他更改。但这样做的问题也很明显：<strong>重复的引入依赖</strong>。在上面的例子中可以看到，每个子任务文件中都重复引入<code>gulp</code>模块。虽然<code>require</code>可以保证模块只被引入一次，但这样每次重复写代码还是很闹心啊，而且这还只是一个非常简单的例子，在实际项目中重复引入的模块会更多。比如上面提到的提取出来的<code>gulp.config.js</code>，比如各种gulp的插件，如果每个任务都要使用某个gulp的插件，那么每个子任务文件都需要引入一遍，非常麻烦。很显然，一个最容易想到的方法就是，在gulpfile中统一的引入这些依赖，然后通过参数传递到各个子任务文件中去。</p>
<h3 id="给每个task文件传参"><a href="#给每个task文件传参" class="headerlink" title="给每个task文件传参"></a>给每个task文件传参</h3><p>为了传参，就需要把每个task文件写成一个module，然后暴露出来一个函数。下面的例子是改写后的<code>js.task.js</code>文件。</p>
<figure class="highlight javascript"><figcaption><span>js.task.js(update)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">gulp, config, $, args</span>) </span>&#123;</div><div class="line">  <span class="comment">// config -- gulp.config.js</span></div><div class="line">  <span class="comment">// $ -- gulp-load-plugins</span></div><div class="line">  <span class="comment">// args --- yargs</span></div><div class="line">  gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (args.debug) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'debug'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'js task'</span>);</div><div class="line">  &#125;);</div><div class="line">  gulp.task(<span class="string">'jshint'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> gulp</div><div class="line">      .src(config.js)</div><div class="line">      .pipe($.jshint());</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，暴露出的函数接受4个参数：</p>
<ul>
<li><code>gulp</code>：gulp本身。</li>
<li><code>config</code>：前面讲到的<code>gulp.config.js</code>模块。</li>
<li><code>$</code>：这里的<code>$</code>可不是jQeury，而是一个叫做<a href="https://github.com/jackfranklin/gulp-load-plugins" target="_blank" rel="external"><code>gulp-load-plugins</code></a>的gulp插件，这个插件的作用就是自动加载<code>package.json</code>里的所有以<code>gulp-*</code>开头的gulp插件。有了这个，就再也不用一个一个的引入gulp插件了，所有插件模块都可以通过<code>$.xxx</code>的方式来引用。在上面的例子中<code>$.jshint()</code>就是调用的插件<code>gulp-jshint</code>所提供的功能。</li>
<li><code>args</code>：<a href="https://github.com/bcoe/yargs" target="_blank" rel="external">模块<code>yargs</code></a>。这个模块的功能是用来接受命令行参数的，比如例子中的<code>js</code>任务，如果运行时使用<code>gulp js --debug</code>就会让代码执行到指定的分支。</li>
</ul>
<p>显然，这4个参数基本上是每个task都用使用到的，所以都需要传递进去。再来看看gulpfile中如何将调用这个子任务模块吧。</p>
<figure class="highlight javascript"><figcaption><span>gulpfile.js(update)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'./gulp.config'</span>)();</div><div class="line"><span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'gulp-load-plugins'</span>)(&#123;<span class="attr">lazy</span>: <span class="literal">true</span>&#125;);</div><div class="line"><span class="keyword">var</span> args = <span class="built_in">require</span>(<span class="string">'yargs'</span>).argv;</div><div class="line"><span class="built_in">require</span>(<span class="string">'./tasks/js.task'</span>)(gulp, config, $, args);</div></pre></td></tr></table></figure>
<p>可以看到，加载<code>gulp-load-plugins</code>的时候传入了<code>{lazy: true}</code>参数，这个参数可以让gulp的插件按需加载。另外一点，在调用子模块的时候我们只调了一个文件，那调多个文件时可以像上面那样使用<code>require-dir</code>这个模块吗？很不幸，从<code>require-dir</code>的文档中没有发现可以传参数的功能。那么为了使用传参数的的方式加载tasks文件夹里的所有子任务，应该怎么做呢？其实要做的只是拿到tasks文件夹下所有的文件名，然后require进来就OK。那么利用Node.js的文件操作模块<code>fs</code>就可以做到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> taskList = <span class="built_in">require</span>(<span class="string">'fs'</span>).readdirSync(<span class="string">'./tasks/'</span>);</div><div class="line">taskList.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</div><div class="line">  <span class="built_in">require</span>(<span class="string">'./tasks/'</span> + file)(gulp, config, $, args);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用fs模块的<code>readdirSync</code>方法列出所有文件夹里的所有文件，使用for循环依次require即可。</p>
<p>那么还有个问题，如果除开这4个参数以外，还想传别的参数呢？比如，很多task共用一个公共的log函数，那么怎么共享这个函数呢？一个最简单的办法就是把公共的函数写在<code>gulp.config.js</code>中，这也是我们为何将这个文件写成模块而不是简单的json文件。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">config.fn = &#123;</div><div class="line">  <span class="attr">log</span>: log</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>这样，在各个task文件中，可以轻松的使用<code>config.fn.log</code>来调用这个函数了。</p>
<h3 id="将gulp相关文件移入单独文件夹"><a href="#将gulp相关文件移入单独文件夹" class="headerlink" title="将gulp相关文件移入单独文件夹"></a>将gulp相关文件移入单独文件夹</h3><p>其实重构到这里已经差不多了，但其实还可以再进一步，将所有和gulp相关的文件全部移到一个单独的文件夹，这样，gulpfile中只写一句就可以了<code>require(&#39;./gulp/&#39;)</code>就可以了。现在的文件夹结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gulpfile.js</div><div class="line">├── gulp</div><div class="line">    ├── gulp.config.js</div><div class="line">    ├── index.js</div><div class="line">    └── tasks/</div><div class="line">        ├── css.task.js</div><div class="line">        └── js.task.js</div></pre></td></tr></table></figure>
<p>将现有的gulpfile中的内容放到<code>/gulp/index.js</code>中即可。有一点值得注意，由于文件夹结构的改变，在读取task时需要将路径改成<code>./gulp/tasks/</code>，即<code>var taskList = require(&#39;fs&#39;).readdirSync(&#39;./gulp/tasks/&#39;);</code>。</p>
<h3 id="方便的列出所有gulp的任务"><a href="#方便的列出所有gulp的任务" class="headerlink" title="方便的列出所有gulp的任务"></a>方便的列出所有gulp的任务</h3><p>分散管理gulp任务以后，也带来了一些不便。比如，如何知道到底有多少gulp任务呢？有一个插件恰恰是用来解决这个问题的，叫<a href="https://github.com/OverZealous/gulp-task-listing" target="_blank" rel="external"><code>gulp-task-listing</code></a>。这个模块使用起来也非常简单，只要在<code>/gulp/index.js</code>中添加<code>gulp.task(&#39;default&#39;, $.taskListing);</code>即可。这样使用<code>gulp</code>命令即可列出所有的gulp任务，更方便的是，如果task的名字中含有<code>-</code>或<code>_</code>或<code>:</code>则这个任务会被认为是子任务。比如，我们将<code>jshint</code>这个任务名改成<code>js:hint</code>，则<code>gulp</code>即会输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Main Tasks</div><div class="line">------------------------------</div><div class="line">    css</div><div class="line">    default</div><div class="line">    js</div><div class="line"></div><div class="line">Sub Tasks</div><div class="line">------------------------------</div><div class="line">    js:hint</div></pre></td></tr></table></figure>
<p>是不是一目了然？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间在公司的新项目中尝试使用gulp替换grunt，体验非常棒！两者最大的区别就是grunt整个就像是一个配置文件，而gulp更像代码。这样的好处就是调试起来更方便直观。另外，利用Node.js的stream概念，让gulp的task看起来像管道一样，输入连着输出，输出又导入另一个输入，流程非常清晰易懂。自打用了这个，就再也不想回到闹心的grunt了。在用了一段时间后，问题来了：不知不觉gulpfile.js已经超过1000行了！每次要修改一个task就要费劲找半天，各种路径也是一团糟，非常难以维护了。那么，是时候重构gulpfile了！&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端自动化" scheme="http://pinkyjie.com/tags/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="gulp" scheme="http://pinkyjie.com/tags/gulp/"/>
    
      <category term="gulpfile" scheme="http://pinkyjie.com/tags/gulpfile/"/>
    
      <category term="重构" scheme="http://pinkyjie.com/tags/%E9%87%8D%E6%9E%84/"/>
    
      <category term="分割task" scheme="http://pinkyjie.com/tags/%E5%88%86%E5%89%B2task/"/>
    
      <category term="generator-aio-angular" scheme="http://pinkyjie.com/tags/generator-aio-angular/"/>
    
  </entry>
  
  <entry>
    <title>一道有(bian)趣(tai)的CSS面试题</title>
    <link href="http://pinkyjie.com/2015/03/02/an-interesting-css-interview/"/>
    <id>http://pinkyjie.com/2015/03/02/an-interesting-css-interview/</id>
    <published>2015-03-02T14:27:50.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在登录CodePen的时候看到一个弹窗，推荐一些网站的用法，其中<a href="http://blog.codepen.io/2015/01/22/interviewing-front-end-hires-codepen/" target="_blank" rel="external">有一篇</a>说很多公司通过CodePen来面试前端工程师，网站支持合作模式，可以实时观察被面试者敲代码，也可以实时沟通，觉得挺有意思，国外就是高端！点进去发现一道用来面试CSS的题目，因为一直觉得自己CSS不是特别好，就想我也做做试试。初看感觉应该不难吧，实际上做下来苦不堪言啊。。。</p>
<a id="more"></a>
<p><script async src="//assets.codepen.io/assets/embed/ei.js"></script></p>
<p data-height="268" data-theme-id="12085" data-slug-hash="GtqKj" data-default-tab="css" data-user="mobify" class="codepen">See the Pen <a href="http://codepen.io/mobify/pen/GtqKj/" target="_blank" rel="external">CSS Test — Button</a> by Mobify (<a href="http://codepen.io/mobify" target="_blank" rel="external">@mobify</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>

<p>题目的HTML部分只有一个a标签，链接的文本是Checkout，然后要求是不能修改HTML的内容，纯用CSS模仿出给出的图片按钮。</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/an-interesting-css-interview-1.png" class="center-img" title="图1">
<p>题目给出的要求是15分钟内完成，不必太在意完美的匹配，可以随便google但是要能够讲得出原理。下面是我最终的答案，为了方便对比我在HTML中加了一个img标签，把原始图片放在下面了。</p>
<p data-height="280" data-theme-id="12085" data-slug-hash="raKxPz" data-default-tab="result" data-user="pinkyjie" class="codepen">See the Pen <a href="http://codepen.io/pinkyjie/pen/raKxPz/" target="_blank" rel="external">raKxPz</a> by Pinky Jie (<a href="http://codepen.io/pinkyjie" target="_blank" rel="external">@pinkyjie</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>

<p>题目要求是15分钟，可是，我花了好几个小时还没搞定我会乱说。O(∩_∩)O~ 下面就跟着我的节奏来一步一步看看具体咋模拟这个button。每一步我都会先列出代码和效果，然后讲讲这一步都可以问出哪些CSS的知识吧。</p>
<h3 id="调位置，调大小"><a href="#调位置，调大小" class="headerlink" title="调位置，调大小"></a>调位置，调大小</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">width</span>: <span class="number">250px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">62px</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">28px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下（图中黄色区域为margin）：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/an-interesting-css-interview-2.png" class="center-img" title="图2">
<p>第一步当然是调调位置和大小了。首先，必须给a标签先加上<code>display:block;</code>的样式，否则如果直接给a标签加类似width和height的属性是没效果的，why？那么第一个问题来了，<strong>问题1：什么是行内元素？什么是块级元素？两者有什么特点和区别？</strong>那么首先，a标签属于行内元素，行内元素不像div这种块级元素可以独占一行，并且对于宽高也有一定的限制：</p>
<ul>
<li>宽度：只能是内容的宽度，不能改变。</li>
<li>高度：只能是内容的高度，不能改变，类似line-height这种样式也是没用的。</li>
<li>margin：只有左右的margin才生效。</li>
<li>padding：上下左右都生效，但上下的padding比较特殊。以padding-bottom举例，如果行内元素后面紧跟一个块级元素（比如div），则块级元素会与padding的部分重合，即padding-bottom并不能使下面的行下移，如下图（图中绿色区域为padding）：</li>
</ul>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/an-interesting-css-interview-3.png" class="center-img" title="图3">
<p>也就是说，想让一个行内元素有固定的宽度和高度，必须先改变其display样式使其变为块级元素才行。</p>
<h3 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">font-family</span>: arial;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">24px</span>;</div><div class="line">  <span class="attribute">font-weight</span>: bold;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#535253</span>;</div><div class="line">  <span class="attribute">text-decoration</span>: none;</div><div class="line">  <span class="attribute">text-transform</span>: uppercase;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/an-interesting-css-interview-4.png" class="center-img" title="图4">
<p>第二步我们来设置字体，这些属性都很常见，如果你想问我怎么识别图中的字体，两个痣：猜的。。。至于字体大小，用Chrome的Dev Tools调吧。另外两个跟文字有关的样式也比较容易理解，text-decoration去掉a标签默认的下划线样式，text-transform可以指定文字为全部大写。这个可以作为<strong>问题2：怎样设置文字的样式，如大小写以及上/下划线？</strong>值得一说的时颜色的模拟，如何得知图中的颜色到底是什么值吗？大家肯定第一时间想到“取色器”，以前也用过一些插件，不过Chrome的Dev Tools自带的取色器就很好用。写的时候可以随便给color属性一个值，然后点击属性值左边的小色块，即可调出取色器，然后移动光标到想取色的图片上即可出现放大镜，定位到指定的像素上时点击鼠标，取色完成。如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/an-interesting-css-interview-5.png" class="center-img" title="图5">
<h3 id="文字的位置"><a href="#文字的位置" class="headerlink" title="文字的位置"></a>文字的位置</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">background</span>: <span class="number">#ccc</span>;</div><div class="line">  <span class="attribute">text-indent</span>: <span class="number">52px</span>;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">63px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/an-interesting-css-interview-6.png" class="center-img" title="图6">
<p>这一步要做的就是调整文字的位置了，为了方便对比，先随便设一个背景色。为了调整文体的位置，这里使用了text-indent来使文字向右偏移，使用line-height来达到使文字向下偏移的效果。也许有人会问，怎么不用padding-left和padding-top呢？那么问题来了，<strong>问题3：怎么设置字体的偏移？text-indent/line-height和padding-left/padding-top有什么区别呢？</strong>那么我们尝试将代码中的text-indent改为padding-left，line-height改为padding-top，此时的效果如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/an-interesting-css-interview-7.png" class="center-img" title="图7">
<p>可以看到，绿色区域为padding，使用padding会使整个a标签的宽度和高度增大，使得与原始图片的宽高已经不一致了，此时就需要重新调整宽度和高度。那么问题来了，<strong>问题4：元素在页面中实际占用的宽度和高度如何计算？</strong>，<strong>问题5：什么是CSS中的盒子模型？</strong>这两个问题常常被放在一起提问，因为不同的盒子模型决定不同的宽高计算方式。总共有两种盒子模型，IE的和W3C标准的。。。具体可以看<a href="http://zh.wikipedia.org/wiki/IE%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%BC%BA%E9%99%B7" target="_blank" rel="external">WIKI</a>。这里只说结论：</p>
<ul>
<li>IE盒模型：<em>实际占用的宽（高）度</em> = 内容宽（高）度[CSS值]</li>
<li>标准盒模型：<em>实际占用的宽（高）度</em> = 内容宽（高）度[CSS值] + 左（上）padding + 右（下）padding + 左（上）border + 右（下）border</li>
</ul>
<p>可以看到，在IE盒模型中，不管pading和border设置多大，元素在页面中实际占用的宽高度都与CSS设置的保持一致。在我们这个场景下，显然希望不管padding怎么变化，a标签在页面中的实际宽高都能始终等于样式里设置的width和height。可以看到恰巧IE的盒模型可以满足我们的要求，有史以来第一次觉得IE的实现很好。。。但是就没有办法在非IE浏览器解决了吗？非也！试试box-sizing属性吧。那么问题来了，<strong>问题6：box-sizing属性是干什么用的？</strong>。试着将text-indent和line-height注释掉，添加box-sizing样式，并适当调整padding的值：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">box-sizing</span>: border-box;</div><div class="line">  <span class="attribute">padding-left</span>: <span class="number">60px</span>;</div><div class="line">  <span class="attribute">padding-top</span>: <span class="number">18px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样得到的效果如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/an-interesting-css-interview-8.png" class="center-img" title="图8">
<p>可以看到，外观是一样的，除了绿色的padding。我们给box-sizing样式赋了一个<code>border-box</code>，意思就是使用类似IE的盒模型来计算宽高。除此之外，它还可以取<code>content-box</code>，就是W3C默认的标准盒模型了。正是由于这个便利，可以发现很多CSS框架（如bootstrap）都会有这么一条样式<code>* {box-sizing: border-box}</code>，即将所有的元素都按IE的盒模型处理，因为这样给我们的布局带来很多便利，避免不必要的像素计算。关于box-sizing还有很多有意思的面试题，比如在CodePen上面我还发现一个有意思的<a href="http://codepen.io/chriscoyier/pen/ClGcF" target="_blank" rel="external">布局题目</a>，要求就是将右边的侧栏恢复正常。显然，最简单有效的方式就是给section加一条样式：<code>box-sizing: border-box</code>即可。</p>
<p>总之，为了实现文字的偏移，两种方案都是可行的，根据自己的习惯选用即可。</p>
<h3 id="简单效果：文字阴影，圆角边框"><a href="#简单效果：文字阴影，圆角边框" class="headerlink" title="简单效果：文字阴影，圆角边框"></a>简单效果：文字阴影，圆角边框</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">#eee</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/an-interesting-css-interview-9.png" class="center-img" title="图9">
<p>这一步就没啥讲的了，如果几年前圆角边框还算新鲜的话，现在早已经烂大街了。至于弯几个像素，开着Dev Tools可劲调吧，调到觉得像为止。至于text-shadow，用来模拟图中CHECKOUT文字下边缘的一丝灰色。参数也很好理解，第一个是阴影向右偏移的像素，第二个是向下偏移的像素，第三个颜色照例取色器搞定。</p>
<h3 id="加星星"><a href="#加星星" class="headerlink" title="加星星"></a>加星星</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:before</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">27px</span>;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#888</span>;</div><div class="line">  <span class="attribute">content</span>: <span class="string">"★"</span>;</div><div class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">#fff</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:before</span> &#123;</div><div class="line">  <span class="attribute">margin-left</span>: -<span class="number">30px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">  <span class="attribute">margin-left</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/an-interesting-css-interview-10.png" class="center-img" title="图10">
<p>这一步给按钮加上了左右两个小星星，由于不能改变HTML结构，那么能使用的方法也就只剩<code>:before</code>和<code>:after</code>了。那么。。。<strong>问题7：before和after是干什么用的？</strong>根据字面意思理解，其实就是在指定标签的内容前面和后面插入内容，而插入的内容呢是由content属性来定义的。先来说说这个content，肯定要有人问了，这个五角星是怎么打出来呢？用Mac的同学自然不用着急，所有编辑器的“编辑”菜单下面都有这么一项子菜单：特殊字符。里面有各种字符，各种五角星。如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/an-interesting-css-interview-11.png" class="center-img" title="图11">
<p>那对于非Mac系统的同学怎么弄呢？各种输入法应该提供特殊字符的输入。除此之外，还可以使用Unicode编码来代表五角星，五角星的CSS编码是<code>\272D</code>，所以我们将content属性替换为<code>content: &quot;\272D&quot;</code>即可。关于如何在HTML/CSS/JS中使用Unicode编码可以参考<a href="http://www.qianduan.net/html-special-characters-daquan.html" target="_blank" rel="external">这篇文章</a>。除了content属性，其他属性就没有太多可说的了，设置字体颜色阴影位置等等。有一点值得一说，除了使用margin-left以外，还可以将before、after的position属性设置为absolute，使用top和left属性来随意调整。</p>
<h3 id="多层边框"><a href="#多层边框" class="headerlink" title="多层边框"></a>多层边框</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;</div><div class="line"> <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">1px</span> <span class="number">#656565</span>,<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6px</span> <span class="number">#CACACA</span>,</div><div class="line">            <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> <span class="number">#fff</span>, <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">#696969</span>,</div><div class="line">            <span class="number">0</span> <span class="number">2px</span> <span class="number">3px</span> <span class="number">11px</span> <span class="number">#CBCBCB</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/an-interesting-css-interview-12.png" class="center-img" title="图12">
<p>这一步应该是最复杂的一步了，起初看到这个按钮图，可能就只能注意到最外面的一个边框。其实，如果在不改变HTML的情况，最外面的几层都只能通过边框来实现，通过下面这个放大后的图我们应该就可以非常清晰的看到这四层边框。</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/an-interesting-css-interview-13.png" class="center-img" title="图13">
<p>图中用红色数字标出的1、2、3、4就是上面所说的四层边框。那么。。。<strong>问题8：如何实现多层边框？</strong>显然，使用border属性是无法实现的。其实在做这道题的时候我也不会，就搜索呗，谷歌搜“multiple border”第一条就是<a href="https://css-tricks.com/snippets/css/multiple-borders/" target="_blank" rel="external">这篇文章</a>（什么？搜不到？再用百度就剁手了啊）。这里我们使用的就是文章里介绍的box-shadow的方法。box-shadow属性和text-shadow属性是一样的，前面两个参数还是向右和向下的阴影偏移，第三个和第四个参数都是可选的，所以我们在前面的text-shadow里没有用这两个参数。第三个参数是阴影模糊的距离，第四个参数是阴影的宽度。讲到这里，你应该就可以想到，要想实现边框，那么只要前两个偏移给0，然后第四个参数给值就可以了，事实也正是如此。我们一层一层边框来分析，按上面截图的顺序，由内向外：</p>
<ul>
<li>第1层：最里面的边框，这里纵向偏移我们给了1px，是因为图中下边框有一点偏黑的阴影。至于模糊的距离怎么确定，三个字：慢慢调。。。</li>
<li>第2层：最宽的阴影，这个没啥讲的，只给了宽度这个参数，慢慢调吧。</li>
<li>第3层：白色边框，同样只给了宽度这个参数。</li>
<li>第4层：最外面的边框，也是只给了宽度。</li>
</ul>
<p>慢着，怎么还有一个参数，有第5层边框吗？仔细观察，可以发现最外面边框的下面有一层很淡很模糊的阴影，为了逼真，我们就也用一层边框来模拟。还有一点，这里之所以从最里面的边框开始写，是因为前面的阴影“优先级”更高，也就是越靠前越在最上面，这样才能显示出层次感。如果直接将宽度为11的写在最前面，那后面的都会被盖住的。</p>
<h3 id="分段背景"><a href="#分段背景" class="headerlink" title="分段背景"></a>分段背景</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(rgba(219, 219, 219, 0.9) <span class="number">48%</span>, <span class="built_in">rgba</span>(169, 169, 169, 0.6) <span class="number">48%</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/an-interesting-css-interview-14.png" class="center-img" title="图14">
<p>最后一步了，只剩下按钮的背景了，很显然，背景分为两层，那么很自然的会想到需要使用渐变的背景来实现。常见的渐变是给定两种颜色，从前者过渡到后者去，但是我们效果图中并没有看到渐变，而是泾渭分明的两种颜色。这时候就需要紧跟颜色后面的百分比这个参数来是实现了。那么。。。<strong>问题9：颜色渐变的时候这个百分比参数是干嘛用的？</strong>在做这个题之前，我对这个问题的认识是很模糊的。百分比参数最常见的用法就是<code>background: linear-gradient(red 0%, green 100%)</code>，也就是最上面是红色，最下面是绿色，中间渐变。那这里第一个百分比不是0%代表什么呢？其实可以理解为其前面有一个同样颜色的0%。以上面的CSS代码为例，在前面加一个<code>rgba(219, 219, 219, 0.9) 0%</code>的效果与现在是一致的。同样，最后一个百分比不是100%的话，就相当于在后面加一个同样颜色的100%。这样一来就好解释了，从0%到48%是颜色1到颜色1的渐变（显然，颜色渐变区间为0，无渐变效果），从48%到48%是颜色1到颜色2的渐变（显然，距离渐变区间为0，无渐变效果），最后，从48%到100%是颜色2到颜色2的渐变（也是无渐变效果）。通过这种方式，就实现了颜色分界的效果。那么最后一个问题来了，<strong>问题10：如果颜色分3层怎么实现呢？</strong>类推一下就可以写出来，比如从上到下分别为红绿蓝的话，CSS为：<code>background: linear-gradient(red 33%, green 33%, green 66%, blue 66%)</code>，自己试试就明白啦。</p>
<h3 id="总结与不足"><a href="#总结与不足" class="headerlink" title="总结与不足"></a>总结与不足</h3><p>到这里，大致的效果已经被还原了（当然，如果考虑浏览器兼容性，很多样式都要多写几条的，你懂得！）。之所以说大致还原，是因为对于效果图还有很多不足：很多颜色不够准确，阴影的范围也不逼真，还有一点关键的就是：分界背景的下半段的两边是有一丝弧度的，这个我目前为止还是不知道怎么实现（有更新）。。。最最变态的是，这道题的要求是15分钟，我估计做了好几个小时了吧O(∩_∩)O~ 在CSS的不归路上还有很多路要走啊。。。</p>
<p>PS: 要问为啥截图这么大？我用麦克不克瑞缇娜！</p>
<hr>

<h3 id="Update-at-2015-03-17"><a href="#Update-at-2015-03-17" class="headerlink" title="Update at 2015.03.17"></a>Update at 2015.03.17</h3><p>把这篇文章分享到<a href="https://v2ex.com/t/177397" target="_blank" rel="external">v2ex</a>后，得到了很多高手的反馈，关于背景弧度的实现，大家提出了两种解决方案：</p>
<ul>
<li>一种是只用before来实现两个五角星，然后用after来实现弧度的背景，可以看<a href="http://codepen.io/anon/pen/NPEwJp" target="_blank" rel="external">这个方案</a>。诀窍就是content属性里面用空格隔开两个五角星。还有一位提到了用box-shadow来实现第二个五角星，即第二个五角星是第一个五角星的阴影。两种方法的原理都是只使用before来实现五角星，这样就省下了after属性，可以用after来实现带弧度的阴影。</li>
<li>第二种是使用box-shadow来模拟这个背景，这个想法简直是巧夺天工！box-shadow有一个inset的值可以将由外投射的阴影改为由内，所以可以用这部分由内投射的阴影来模拟上半部分的背景，原来的背景就被挤到下面，而原来的背景正是有弧度的。直接上代码吧，将box-shadow和background改为：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">29px</span> <span class="built_in">rgba</span>(222, 222, 222, 1) inset,</div><div class="line">    <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">1px</span> <span class="number">#656565</span>,<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6px</span> <span class="number">#CACACA</span>, <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> <span class="number">#fff</span>,</div><div class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">#696969</span>, <span class="number">0</span> <span class="number">2px</span> <span class="number">3px</span> <span class="number">11px</span> <span class="number">#CBCBCB</span>;</div><div class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(182, 182, 182, 0.6);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，现在的background的颜色是背景的下半部分，颜色值同样取色器搞定，而上半部分用box-shadow的第一个值来实现，比较特殊的就是inset参数了。阴影改为inset后，由向外投影改为向内投影，向右偏移为0，向下偏移为29，这样就模拟了背景的上半部分了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在登录CodePen的时候看到一个弹窗，推荐一些网站的用法，其中&lt;a href=&quot;http://blog.codepen.io/2015/01/22/interviewing-front-end-hires-codepen/&quot;&gt;有一篇&lt;/a&gt;说很多公司通过CodePen来面试前端工程师，网站支持合作模式，可以实时观察被面试者敲代码，也可以实时沟通，觉得挺有意思，国外就是高端！点进去发现一道用来面试CSS的题目，因为一直觉得自己CSS不是特别好，就想我也做做试试。初看感觉应该不难吧，实际上做下来苦不堪言啊。。。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="CSS" scheme="http://pinkyjie.com/tags/CSS/"/>
    
      <category term="CodePen" scheme="http://pinkyjie.com/tags/CodePen/"/>
    
      <category term="box-shadow" scheme="http://pinkyjie.com/tags/box-shadow/"/>
    
      <category term="linear-gradient" scheme="http://pinkyjie.com/tags/linear-gradient/"/>
    
      <category term="多层边框" scheme="http://pinkyjie.com/tags/%E5%A4%9A%E5%B1%82%E8%BE%B9%E6%A1%86/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS中controller和service的继承与扩展</title>
    <link href="http://pinkyjie.com/2015/02/11/inheritance-or-extension-for-controller-and-service-in-angularjs/"/>
    <id>http://pinkyjie.com/2015/02/11/inheritance-or-extension-for-controller-and-service-in-angularjs/</id>
    <published>2015-02-11T11:47:00.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司要做的项目中牵扯到很多场景需要对controller和service进行继承和扩展的，总结一下心得体会。开讲之前，先明确一下这里的所谓的“继承”与“扩展”。</p>
<ul>
<li>所谓继承，比较熟悉，这里就是指定义一个<strong>新的</strong>controller/service（不同名），继承原来的controller/service，然后在其基础上重写一些功能。</li>
<li>所谓扩展，这里说的是在<strong>不产生新的</strong>controller/service的情况下，添加或修改原controller/service的功能。</li>
</ul>
<p>目前研究的结果就是service可以轻松的实现继承和扩展，而controller貌似只能继承。</p>
<a id="more"></a>
<h3 id="controller的继承"><a href="#controller的继承" class="headerlink" title="controller的继承"></a>controller的继承</h3><p>说到controller，我们在<a href="/2015/02/09/controller-as-vs-scope/">前面的文章</a>中介绍过有两种写法：使用<code>$scope</code>或使用<code>controller as</code>。针对这两种方式的区别，我们也可以使用两种不同的继承方式：</p>
<ul>
<li>使用<code>controller as</code>的情况下，特点是controller不再依赖<code>$scope</code>，就跟普通的函数差不多，这个时候可以使用Javascript原生的继承方式。</li>
<li>使用<code>$scope</code>时，可以使用AngularJS内置的<code>$controller</code>service，通过依赖注入的方式实现继承。</li>
</ul>
<p>还是直接上例子吧。</p>
<p><strong><em>使用原生的继承</em></strong></p>
<p><script async src="//assets.codepen.io/assets/embed/ei.js"></script></p>
<p data-height="268" data-theme-id="12085" data-slug-hash="zxpRbK" data-default-tab="result" data-user="pinkyjie" class="codepen">See the Pen <a href="http://codepen.io/pinkyjie/pen/zxpRbK/" target="_blank" rel="external">zxpRbK</a> by Pinky Jie (<a href="http://codepen.io/pinkyjie" target="_blank" rel="external">@pinkyjie</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>

<p>这个例子有左右两块区域，左边的是parent，右边的是child，它们分别有5行数据需要显示：</p>
<ul>
<li>第1行性别，对应属性<code>sex</code>。用于展示继承时不更改的属性。</li>
<li>第2行角色，对应属性<code>name</code>。用于展示继承后覆盖的属性。</li>
<li>第3行个数，对应属性<code>num</code>，左边是孩子的个数，右边是兄弟的个数，显然右边比左边少1。用于显示后面<code>add()</code>方法的结果。</li>
<li>第4行是个按钮，对应方法<code>add()</code>，左边是parent想多要一个孩子，右边是想child想多要一个兄弟，结果是一样的。用于展示继承时不改变的方法。</li>
<li>第5行也是个按钮，对应方法<code>test()</code>，用于展示继承时覆盖的方法。（不要在意这个随意的名字，因为我已经场景匮乏了。。。）</li>
</ul>
<p>通过这5行，这个例子就基本涵盖了继承时发生的大部分情况。那么切换到JS里看看实现吧。JS里的代码结构大致分为5部分，用注释<code>/* Section 1 */</code>来区分（由于CodePen这工具不支持显示行号，所以只能用代码里的注释来分块讲解了）。</p>
<ul>
<li>第1部分是一个典型的Javascript实现的继承函数<code>extend</code>，里面的原理不再详述，有兴趣可以看以前写的<a href="/2013/11/30/understand-backbone-extend/">《理解Backbone中extend的实现》</a>。<blockquote>
<p>这段代码怎么生成？访问<a href="http://coffeescript.org/" target="_blank" rel="external">CoffeeScript官网</a>，点击“TRY COFFEESCRIPT”，会打开一个编辑器窗口，左边写CoffeeScript，右边就会生成相应的Javascript。在左边键入<code>class A extends B</code>，右面就会有extend函数啦。机！智！</p>
</blockquote>
</li>
<li>第2部分是一个名叫<code>FamilyService</code>的AngularJS的service。两个controller都需要依赖它。它的功能很简单，parent和child需要的孩子数量和兄弟数量都由这个service来提供，分别是方法<code>getChildrenCount()</code>和<code>getSiblingCount()</code>。除此之外，每次生孩子的时候它会trigger一个<code>new-child</code>事件，并将孩子数量通过参数传播出去。</li>
<li>第3部分就是定义<code>ParentCtrl</code>这个父controller了，由于采用<code>controller as</code>写法，这里的定义跟普通的对象没区别，在构造函数里定义属性，方法则定义在<code>prototype</code>上。这里值得注意的有两点：<ul>
<li><code>add()</code>函数其实仅仅是调用<code>FamilyService</code>的<code>newChild()</code>方法。</li>
<li><code>num</code>属性的改变是通过响应<code>new-child</code>事件来实现的。</li>
</ul>
</li>
<li>第4部分就是关键的<code>ChildCtrl</code>定义了，同样，属性的定义在构造函数中，方法定义在<code>prototype</code>上。可以发现，发生继承需要以下几步：<ol>
<li>构造函数中先调用父controller的构造函数。这里是通过<code>__super__</code>来实现对父controller的引用的，因为在<code>extend</code>函数中我们已将讲<code>ParentCtrl</code>的prototype赋值给<code>__super__</code>变量了。这步可以保证把<code>ParentCtrl</code>里定义的属性以及事件响应继承过来。</li>
<li>覆盖属性和事件响应。 这里覆盖了<code>name</code>和<code>num</code>属性，并且更改了事件响应函数的内容，因为<code>new-child</code>事件返回的参数是孩子的总数，这里要减去自己才能得到兄弟的个数。</li>
<li>调用<code>extend</code>函数。</li>
<li>覆盖方法。这一步必须放在最后，如果放在<code>extend</code>函数的前面，则<code>extend</code>函数会将<code>ChildCtrl</code>重新定义的<code>add</code>方法用<code>ParentCtrl</code>的覆盖。</li>
</ol>
</li>
<li>第5部分就是各种模块、controller、service的定义了，没啥多说的。</li>
</ul>
<p><strong><em>使用<code>$controller</code>service</em></strong></p>
<p data-height="268" data-theme-id="12085" data-slug-hash="zxaZPw" data-default-tab="result" data-user="pinkyjie" class="codepen">See the Pen <a href="http://codepen.io/pinkyjie/pen/zxaZPw/" target="_blank" rel="external">zxaZPw</a> by Pinky Jie (<a href="http://codepen.io/pinkyjie" target="_blank" rel="external">@pinkyjie</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>

<p>例子的实际效果与上面的一致，我们直接看JS部分的实现吧。这个代码分为4个部分：</p>
<ul>
<li>第1部分与前面service的定义相同。</li>
<li>第2部分是<code>ParentCtrl</code>的定义，这里与前面的不同一个是全部使用<code>$scope</code>，另一个比较特殊的是<code>add</code>方法，它直接调用了一个绑定在<code>this</code>上面的<code>add</code>方法，这样做没什么特殊含义，仅为了演示后面的继承。</li>
<li>第3部分是<code>ChildCtrl</code>的定义，这里的继承是通过<code>var parentCtrl = $controller(&#39;ParentCtrl&#39;, {$scope: $scope});</code>来实现的，通过依赖注入得到父controller的实例，并将自己的<code>$scope</code>传入，这样，父controller绑定在<code>$scope</code>上面的东西就全部继承到子controller上面了。除此之外，还可以使用变量<code>parentCtrl</code>来引用父controller，跟前面的<code>__super__</code>一样。<code>add</code>方法的覆盖给出了使用<code>parentCtrl</code>的例子。</li>
<li>第4部分与前面相同，区别就是<code>ChildCtrl</code>依赖了<code>$controller</code>service。</li>
</ul>
<p><strong><em>比较</em></strong></p>
<p>可以发现，其实这两种方式最大的区别就是，原生继承中需要调用<code>extend</code>函数来继承，并且子controller里需要显式调用父controller的构造函数来是实现属性的继承。而使用<code>$controller</code>service则只需要依赖注入和传入<code>$scope</code>即可。</p>
<h3 id="service的继承"><a href="#service的继承" class="headerlink" title="service的继承"></a>service的继承</h3><p>service的继承就比较简单了，AngularJS中的service可以认为是new了service构造函数的实例。看下面这个例子，与上面的例子类似，同样是展示了继承过程中不改变或覆盖父service的属性和方法。</p>
<p data-height="268" data-theme-id="12085" data-slug-hash="WbyYdK" data-default-tab="result" data-user="pinkyjie" class="codepen">See the Pen <a href="http://codepen.io/pinkyjie/pen/WbyYdK/" target="_blank" rel="external">WbyYdK</a> by Pinky Jie (<a href="http://codepen.io/pinkyjie" target="_blank" rel="external">@pinkyjie</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>

<p>熟悉的左右布局，三个属性两个方法。直接看JS中的实现，4个部分：</p>
<ul>
<li>第1部分定义了一个controller，这个controller的所有功能基本都来自于service。页面中左右两个部分用的是同样的controller，只是名字不同，而且依赖的service不同。这一点从第4部分可以直观的看出来。</li>
<li>第2部分定义父service，没什么特别的。</li>
<li><p>第3部分定义子servcie，继承就发生在这里。首先，子service需要依赖父service，然后直接使用AngularJS内置的extend函数来实现继承，将父service实例上的属性方法都拷贝到this上，即完成了继承，后面就是一些属性和方法的覆盖了。</p>
<blockquote>
<p>这里的extend和上面自己写的extend有什么区别呢？其实<code>angular.extend</code>的功能是一个Shallow Copy，类似上面我们自己的extend中的这段</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> parent) &#123;</div><div class="line">  <span class="keyword">if</span> (hasProp.call(parent, key))</div><div class="line">    child[key] = parent[key];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>第4部分各种定义，可以看到<code>TestCtrl1</code>和<code>TestCtrl2</code>的定义都是<code>TestCtrl</code>，只是一个依赖<code>ParentService</code>，另一个依赖<code>ChildService</code>罢了。</p>
</li>
</ul>
<h3 id="service的扩展"><a href="#service的扩展" class="headerlink" title="service的扩展"></a>service的扩展</h3><p>其实扩展说白了，就是可以把一个已经定义好的service进行修改，为了保证这个修改的优先级，可以在module的config阶段来实现。废话不说，直接上例子吧。</p>
<p data-height="268" data-theme-id="12085" data-slug-hash="LErmxz" data-default-tab="result" data-user="pinkyjie" class="codepen">See the Pen <a href="http://codepen.io/pinkyjie/pen/LErmxz/" target="_blank" rel="external">LErmxz</a> by Pinky Jie (<a href="http://codepen.io/pinkyjie" target="_blank" rel="external">@pinkyjie</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>

<p>这个例子与前面的类似，只是页面只有一个部分，实现的结果跟上面的右半部分一致。直接看JS中的实现，除了第3部分其他都是一样的。第3部分中定义了一个<code>extendServcie</code>函数，这个函数是在app的config阶段调用的（见第4部分）。这个函数中依赖了一个特殊的service<code>$provide</code>，扩展功能就由它的<code>decorator</code>方法来实现，方法的第一个参数就是要扩展的service的名称，第二个参数就是实际的扩展。在第二个参数中依赖一个<code>$delegate</code>service，这个service代表的其实就是<code>TestService</code>本身，可以看到在函数中我们直接使用<code>$delegate</code>去引用原有servcie，并进行随意更改，最终将这个<code>$delegate</code>返回即可。</p>
<p>也许很多人会觉得这种场景很诡异，平常根本不可能用得到。但是我在项目中就曾经遇到一个例子：在单页面应用中我们并没有把所有JS文件压缩在一起，而是根据不同的页面去lazy load不同的文件。具体去load哪些文件定义在一个servcie中，但这些文件名在development和production阶段是不一样的，这样就需要两套不同的文件名配置。利用servcie的扩展，可以在production环境时多include一个JS文件，在这个文件中对servcie进行扩展，更新那些相应的文件名。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近公司要做的项目中牵扯到很多场景需要对controller和service进行继承和扩展的，总结一下心得体会。开讲之前，先明确一下这里的所谓的“继承”与“扩展”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所谓继承，比较熟悉，这里就是指定义一个&lt;strong&gt;新的&lt;/strong&gt;controller/service（不同名），继承原来的controller/service，然后在其基础上重写一些功能。&lt;/li&gt;
&lt;li&gt;所谓扩展，这里说的是在&lt;strong&gt;不产生新的&lt;/strong&gt;controller/service的情况下，添加或修改原controller/service的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前研究的结果就是service可以轻松的实现继承和扩展，而controller貌似只能继承。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AngularJS" scheme="http://pinkyjie.com/tags/AngularJS/"/>
    
      <category term="controller" scheme="http://pinkyjie.com/tags/controller/"/>
    
      <category term="service" scheme="http://pinkyjie.com/tags/service/"/>
    
      <category term="继承" scheme="http://pinkyjie.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="扩展" scheme="http://pinkyjie.com/tags/%E6%89%A9%E5%B1%95/"/>
    
      <category term="decorator" scheme="http://pinkyjie.com/tags/decorator/"/>
    
      <category term="$provide" scheme="http://pinkyjie.com/tags/provide/"/>
    
      <category term="$delegate" scheme="http://pinkyjie.com/tags/delegate/"/>
    
  </entry>
  
  <entry>
    <title>用$scope还是用controller as</title>
    <link href="http://pinkyjie.com/2015/02/09/controller-as-vs-scope/"/>
    <id>http://pinkyjie.com/2015/02/09/controller-as-vs-scope/</id>
    <published>2015-02-09T12:12:36.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>AngularJS中在处理controller时提供了两种语法。</p>
<ul>
<li>第一种是，在DOM中使用<code>ng-controller=&quot;TestController&quot;</code>，这样在定义controller时需要将model绑定到$scope上。</li>
<li>另一种是，在DOM中使用<code>ng-controller=&quot;TestController as test&quot;</code>，这样其实是将model直接绑定到controller的实例上。</li>
</ul>
<p>在AngularJS的官方Get Started以及各种文档中，多推荐第一种方式，导致很多人可能都不知道原来还有第二种方式，我也是最近看一篇文章时才注意到这个。那么这两种方式各有什么优劣势呢？在现实的开发中到底更推荐哪种方式呢？今天就来探究一下！</p>
<a id="more"></a>
<h3 id="controller-as方式"><a href="#controller-as方式" class="headerlink" title="controller as方式"></a>controller as方式</h3><p>$scope方式就不详细说了，大家应该最常用这种吧，看下面这段简单的代码。</p>
<p><script async src="//assets.codepen.io/assets/embed/ei.js"></script></p>
<p data-height="268" data-theme-id="12085" data-slug-hash="QwOYVe" data-default-tab="html" data-user="pinkyjie" class="codepen">See the Pen <a href="http://codepen.io/pinkyjie/pen/QwOYVe/" target="_blank" rel="external">QwOYVe</a> by Pinky Jie (<a href="http://codepen.io/pinkyjie" target="_blank" rel="external">@pinkyjie</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>

<p>对应版本的controller as方式如下：</p>
<p data-height="268" data-theme-id="12085" data-slug-hash="YPYWGO" data-default-tab="html" data-user="pinkyjie" class="codepen">See the Pen <a href="http://codepen.io/pinkyjie/pen/YPYWGO/" target="_blank" rel="external">YPYWGO</a> by Pinky Jie (<a href="http://codepen.io/pinkyjie" target="_blank" rel="external">@pinkyjie</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>

<p>在controller as方式中，可以给controller起别名，上面的例子中别名是<code>ctrl</code>。对比这两个例子，可以明显的看到controller as有两个不同的地方：</p>
<ul>
<li>在HTML中，所有的绑定都需要写别名，即需要使用点运算符<code>ctrl.</code></li>
<li>在JS中，controller的定义可以抛开<code>$scope</code>了，也就是说controller可以不依赖<code>$scope</code>了。</li>
</ul>
<p>下面就从这两个区别出发去谈谈controller as的好处。</p>
<h3 id="所有model都需要绑定在ctrl上"><a href="#所有model都需要绑定在ctrl上" class="headerlink" title="所有model都需要绑定在ctrl上"></a>所有model都需要绑定在<code>ctrl</code>上</h3><p>首先有必要澄清下，这个别名是怎么实现的呢？使用AngularJS在Chrome上的调试插件<a href="https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk" target="_blank" rel="external">AngularJS Batarang</a>可以很清楚的看出来。安装好插件后打开<a href="http://s.codepen.io/pinkyjie/debug/YPYWGO" target="_blank" rel="external">上面的例子</a>，右击页面“审查元素”打开Chrome的DevTools，在Elements标签里选中<code>&lt;div ng-controller=&quot;scopeController as ctrl&quot; class=&quot;ng-scope&quot;&gt;</code>这一行，然后点击右边的$scope标签（就是和Styles，Computed在一行的，看不到的话点击右边的小箭头），结果就是这个DOM元素所对应的<code>$scope</code>，如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/controller-as-vs-scope-1.png" class="center-img" title="图1">
<p>原来别名<code>ctrl</code>就是定义在<code>$scope</code>上的一个对象，这就是controller的一个实例，所有在JS中定义controller时绑定到<code>this</code>上的model其实都是绑定到<code>$scope.ctrl</code>上的，看到这里你想到了什么？是不是和上篇文章<a href="2015/02/07/prototypal-inheritance-of-scope-in-angularjs/">AngularJS中scope基于原型链的继承</a>里的<code>$scope.data</code>有异曲同工之妙。所以，使用controller as的一大好处就是原型链继承给scope带来的问题都不复存在了，即有效避免了在嵌套scope的情况下子scope的属性隐藏掉父scope属性的情况。</p>
<blockquote>
<p>可以发现，无论定义controller时有没有直接依赖<code>$scope</code>，DOM中的scope是始终存在的。即使使用controller as，双向绑定还是通过<code>$scope</code>的watch以及digest来实现的。</p>
</blockquote>
<p>另外，使用别名还有一个显而易见的好处：指代清晰。在嵌套scope时，子scope如果想使用父scope的属性，只需简单的使用父scope的别名引用父scope即可。比如下面这个例子，我们将<a href="2015/02/07/prototypal-inheritance-of-scope-in-angularjs/">上篇文章</a>的例子用controller as重写。</p>
<p data-height="268" data-theme-id="12085" data-slug-hash="OPzRVN" data-default-tab="result" data-user="pinkyjie" class="codepen">See the Pen <a href="http://codepen.io/pinkyjie/pen/OPzRVN/" target="_blank" rel="external">OPzRVN</a> by Pinky Jie (<a href="http://codepen.io/pinkyjie" target="_blank" rel="external">@pinkyjie</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>

<p>这里我想让子scope里直接指向父scope的属性，只需在DOM绑定model时写上<code>parent.myName</code>即可，简单明了，看代码的一下就懂了，也不用费劲去推到底这里指向的是哪个属性了。如果你的嵌套多达四五层，那这种写法的优势就一下子体现出来了。</p>
<h3 id="controller的定义不依赖-scope"><a href="#controller的定义不依赖-scope" class="headerlink" title="controller的定义不依赖$scope"></a>controller的定义不依赖<code>$scope</code></h3><p>定义controller时不用显式的依赖<code>$scope</code>，这有什么好处呢？仔细看定义，这不就是一个普通的函数定义嘛，对！这就是好处！例子中的<code>ScopeController</code>就是所谓的POJO（Plain Old Javascript Object，Java里偷来的概念），这样的Object与框架无关，里面只有逻辑。所以即便有一天你的项目不再使用AngularJS了，依然可以很方便的重用和移植这些逻辑。另外，从测试的角度看，这样的Object也是单元测试友好的。单元测试强调的就是孤立其他依赖元素，而POJO恰恰满足这个条件，可以单纯的去测试这个函数的输入输出，而不用费劲的去模拟一个假的<code>$scope</code>。</p>
<p>另外，还有一个比较牵强的好处：防止滥用<code>$scope</code>的<code>$watch</code>，<code>$on</code>，<code>$broadcast</code>方法。可能刚刚就有人想问了，不依赖<code>$scope</code>我怎么watch一个model，怎样广播和响应事件。答案是没法弄，这些事还真是只有<code>$scope</code>能干。但很多时候在controller里watch一个model是很多余的，这样做会明显的降低性能。所以，当你本来就依赖<code>$scope</code>的时候，你会习惯性的调用这些方法来实现自己的逻辑。但当使用controller as的时候，由于没有直接依赖<code>$scope</code>，使用watch前你会稍加斟酌，没准就思考到了别的实现方式了呢。</p>
<h3 id="定义route时也能用controller-as"><a href="#定义route时也能用controller-as" class="headerlink" title="定义route时也能用controller as"></a>定义route时也能用controller as</h3><p>除了在DOM中显式的指明<code>ng-controller</code>，还有一种情况是controller的绑定是route里定义好的，那这时能使用controller as吗？答案是肯定的，route提供了一个<code>controllerAs</code>参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$routeProvider</div><div class="line">  .when(<span class="string">'/'</span>, &#123;</div><div class="line">    <span class="attr">templateUrl</span>: <span class="string">'partial/home.html'</span>,</div><div class="line">    <span class="attr">controller</span>: <span class="string">'HomeCtrl'</span>,</div><div class="line">    <span class="attr">controllerAs</span>: <span class="string">'home'</span></div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<p>这样在模板里就可以直接使用别名<code>home</code>啦。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>总结下来，个人觉得还是偏向于使用controller as的，当然有一点要澄清，使用contoller as并没有什么性能上的提升，仅仅是一种好的习惯罢了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AngularJS中在处理controller时提供了两种语法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种是，在DOM中使用&lt;code&gt;ng-controller=&amp;quot;TestController&amp;quot;&lt;/code&gt;，这样在定义controller时需要将model绑定到$scope上。&lt;/li&gt;
&lt;li&gt;另一种是，在DOM中使用&lt;code&gt;ng-controller=&amp;quot;TestController as test&amp;quot;&lt;/code&gt;，这样其实是将model直接绑定到controller的实例上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在AngularJS的官方Get Started以及各种文档中，多推荐第一种方式，导致很多人可能都不知道原来还有第二种方式，我也是最近看一篇文章时才注意到这个。那么这两种方式各有什么优劣势呢？在现实的开发中到底更推荐哪种方式呢？今天就来探究一下！&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AngularJS" scheme="http://pinkyjie.com/tags/AngularJS/"/>
    
      <category term="scope" scheme="http://pinkyjie.com/tags/scope/"/>
    
      <category term="controller" scheme="http://pinkyjie.com/tags/controller/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS中scope基于原型链的继承</title>
    <link href="http://pinkyjie.com/2015/02/07/prototypal-inheritance-of-scope-in-angularjs/"/>
    <id>http://pinkyjie.com/2015/02/07/prototypal-inheritance-of-scope-in-angularjs/</id>
    <published>2015-02-07T07:17:22.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家写过AngularJS的都会发现，很多人在处理表单的数据绑定时，都习惯性的把ng-model绑定在$scope的一个对象属性上，而不是直接绑定在scope上。比如说使用<code>&lt;input name=&quot;name&quot; ng-model=&quot;data.name&quot; /&gt;</code>而不是<code>&lt;input name=&quot;name&quot; ng-model=&quot;name&quot; /&gt;</code>。这是为什么呢？这样在controller里面岂不是写起来更复杂吗？每次访问的时候都要多“点”一下，为什么不直接绑在$scope上呢？其实这样写自然是有它的好处的，而且这种写法也是推荐的最佳实践，尤其是在处理嵌套scope的情形下，这样写是很有必要的。为了弄清楚这么写的原因，我们需要深入的研究一下AngularJS里scope的继承。</p>
<a id="more"></a>
<h3 id="基于原型链的继承"><a href="#基于原型链的继承" class="headerlink" title="基于原型链的继承"></a>基于原型链的继承</h3><p>AngularJS的官方文档里有这么一句话来描述scope：<code>A &quot;child scope&quot; (prototypically) inherits properties from its parent scope.</code> 子scope从其父scope那里继承属性，而括号里的词是重点，这种继承是基于原型链的。直接来看一个最简单的例子。</p>
<p><script async src="//assets.codepen.io/assets/embed/ei.js"></script></p>
<p data-height="268" data-theme-id="12085" data-slug-hash="xbPPPJ" data-default-tab="result" data-user="pinkyjie" class="codepen">See the Pen <a href="http://codepen.io/pinkyjie/pen/xbPPPJ/" target="_blank" rel="external">xbPPPJ</a> by Pinky Jie (<a href="http://codepen.io/pinkyjie" target="_blank" rel="external">@pinkyjie</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>

<p>这段简单的代码里，<code>ChildCtrl</code>并没有定义<code>MyName</code>，但由于在DOM结构上它和<code>ParentCtrl</code>是父子关系，所以它继承了其父scope上定义的属性。这个其实不难理解，我们知道，在Javascript的世界里，继承都是通过原型链来实现的。最常见的例子就是<code>toString()</code>方法，试试运行<code>var a = {&quot;test1&quot;: 1, &quot;test2&quot;: 2}; a.toString()</code>。你自定义一个对象时，都可以调用到这个方法，因为这个方法是定义在object对象上的，自定义的对象都继承它。</p>
<p>在这个例子里，我们是直接将model绑定在scope上的，似乎目前为止也没什么问题啊。下面让我们做一些小实验：</p>
<ul>
<li>尝试在Parent Name的input框中修改，发现Child Name的input框跟着同步改变，说明父scope中model的变化同步到了子scope中，没有问题。</li>
<li>尝试在Child Name的input框中修改，发现Parent Name对应的input框并没有随着发生改变，说明子scope中model的变化并没有同步回父scope中。</li>
<li>再次尝试在Parent Name的input框中修改，发现此时Child Name的input框也不更新了，说明这个时候，父scope中的model变化已经没法同步到子scope中去了。</li>
</ul>
<p>看起来父scope和子scope之间的联系已经断了，此时两个input框的值已经无法再同步了。这个例子是现实情况中非常常见的场景，model定义在父scope上，而表单的DOM区域有自己的controller，这就势必会产生一个新的子scope。按照我们的实验，一旦用户修改了表单数据，父scope拿到的model已经不正确了，并且此时如果父scope的controller更新model，表单里的model也不对了，这显然与我们的设计初衷是相违背的。</p>
<p>我们可以从分析实验2入手，因为实验2之前父子scope是可以同步，实验2之后父子scope已经完全独立，就像是父scope和子scope操作的是不同的model一样。那究竟是不是这么回事呢？我们尝试修改代码，在<code>ChildCtrl</code>的函数中添加一行<code>$scope.myName = &#39;Child Name&#39;;</code>。这时，我们修改两个input框，发现无法同步。这个也很好理解，还拿<code>toString()</code>来举例，如果自定义的对象里重写了<code>toString()</code>方法，那么这个子对象上的方法就覆盖了继承过来的方法。同样的，这里子scope的<code>myName</code>属性覆盖了从父scope继承过来的<code>myName</code>属性。</p>
<blockquote>
<p>在父scope属性被隐藏的情况下如果要访问其属性，可以使用子scope上的<code>$parent</code>属性来显式的访问。</p>
</blockquote>
<h3 id="关于继承属性的读和写"><a href="#关于继承属性的读和写" class="headerlink" title="关于继承属性的读和写"></a>关于继承属性的读和写</h3><p>实验2造成的结果其实就是在子scope上重新定义了<code>myName</code>属性。是什么触发了这个操作呢？我们修改子Child Name的input框值，根据AngularJS的双向绑定，触发了子scope上<code>myName</code>属性的写操作，写操作发现子scope上没有自己定义这个属性（可以通过<code>hasOwnProperty()</code>函数来确定）时，触发子scope去定义一个<code>myName</code>属性。正是由于子scope现在有了自己的<code>myName</code>属性，父scope继承过来的<code>myName</code>被隐藏(shadow)，导致了两者的更改互不影响。所以可以总结在基于原型链的继承中，子类属性的读和写有这么几个特点：</p>
<ul>
<li>读子类的属性时，子类有这个属性（<code>hasOwnProperty</code>）的时候则读子类自己的，子类没有的时候读父类的，不管子类有没有这个属性，在子类上都不会有新属性被创建。</li>
<li>写子类的属性时，如果子类有这个属性（<code>hasOwnProperty</code>）则写子类的，子类没有的话就会在子类上新建一个同名的新属性，而父类继承过来的属性被隐藏。</li>
</ul>
<p>那怎么解决这个问题呢？我们按照最佳实践，将model绑定在scope的data属性上试试。看下面这个例子。</p>
<p data-height="268" data-theme-id="12085" data-slug-hash="WbXXyo" data-default-tab="result" data-user="pinkyjie" class="codepen">See the Pen <a href="http://codepen.io/pinkyjie/pen/WbXXyo/" target="_blank" rel="external">WbXXyo</a> by Pinky Jie (<a href="http://codepen.io/pinkyjie" target="_blank" rel="external">@pinkyjie</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>

<p>我们同样做上面3个实验，发现这次不管怎么修改，父scope和子scope上的model都是可以同步的。这又是为什么呢？难道写属性的时候没有在子scope上创建新属性吗？确实如此！可以发现，这里继承的属性是<code>data</code>，它是一个对象，而前面的例子中继承的是<code>myName</code>，是一个字符串。在这两种情况下，当我们尝试修改Child Namd的input为“abc”时，让我们看看分别有什么不同：</p>
<ul>
<li>例子1中，由于双向绑定，其实是执行<code>子scope.myName = &quot;abc&quot;</code>，先检查子scope上有没有<code>myName</code>属性<strong>可供写</strong>，发现没有，则新建属性，导致父scope的属性被隐藏。</li>
<li>例子2中，执行<code>子scope.data.myName = &quot;abc&quot;</code>，这个时候，先检查子scope上有没有<code>data</code>属性<strong>可供读</strong>，发现没有，则读父scope上的，读到以后，然后修改其上面的<code>myName</code>属性。</li>
</ul>
<p>区别就在于写<code>data.myName</code>的时候会尝试先去读<code>data</code>属性，正是由于这个特性，所以在处理表单的数据绑定时才推荐使用点运算符，即把model绑定在scope的某个对象属性上。</p>
<blockquote>
<p>可能有人会对这个有异议，考虑这个例子：<code>var a = {}; a.data.myName = &quot;abc&quot;;</code>，显然执行这句代码会报错，错误是<code>TypeError: Cannot set property &#39;myName&#39; of undefined</code>，说明解释器先尝试去读<code>a.data</code>，发现是undefined，然后再去写其<code>myName</code>属性，才报了这么一个错！</p>
</blockquote>
<h3 id="其他会产生子scope的标签"><a href="#其他会产生子scope的标签" class="headerlink" title="其他会产生子scope的标签"></a>其他会产生子scope的标签</h3><p>除了<code>ng-controller</code>会产生子scope外，AngularJS里的还有很多其他标签也同样会产生子scope：</p>
<ul>
<li><code>ng-repeat</code></li>
<li><code>ng-include</code></li>
<li><code>ng-switch</code></li>
</ul>
<p>所以在这些场景下也需要考虑原型链继承存在的问题。这里值得一说的是<code>ng-repeat</code>标签，对于每一轮循环它都会产生一个<strong>新的</strong>子scope基于原型链继承父scope，而且在这个新的子scope里，会定义一个新属性，属性名为循环变量，值为此轮循环的值，类似下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">子scope = 父scope.$<span class="keyword">new</span>();</div><div class="line">子scope[循环变量] = 此轮循环的值;</div></pre></td></tr></table></figure></p>
<p>这个特性在很多场景下很有用。比如说，同一个页面上有2个<code>ng-include</code>标签，使用同样的模板，模板里有一个变量<code>name</code>，针对两个不同的<code>ng-include</code>我想让<code>name</code>变量有不同的值，但是我又不想重新写两个controller，这个时候可以使用<code>ng-repeat</code>。</p>
<p data-height="268" data-theme-id="12085" data-slug-hash="VYrxEK" data-default-tab="result" data-user="pinkyjie" class="codepen">See the Pen <a href="http://codepen.io/pinkyjie/pen/VYrxEK/" target="_blank" rel="external">VYrxEK</a> by Pinky Jie (<a href="http://codepen.io/pinkyjie" target="_blank" rel="external">@pinkyjie</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>

<p>这里使用<code>ng-repeat</code>可以轻松的将不同的变量传入同一个模板中。</p>
<h3 id="directive中的scope"><a href="#directive中的scope" class="headerlink" title="directive中的scope"></a>directive中的scope</h3><p>directive比较复杂，所以单独拿出来研究，它有一个<code>scope</code>参数，根据参数的不同就有不同的行为。</p>
<ul>
<li>默认情况下，即构造directive的时候不传scope参数，等同于传入<code>scope: false</code>，这种情况不会产生新的scope，也就不存在继承的问题，directive的scope和原来是同一个。</li>
<li>构造directive时传入<code>scope: true</code>，这种情况会产生新的子scope并继承父scope，情况类似于前面介绍的，所以这时就需要注意原型链继承带来的问题。</li>
<li>构造directive时传入<code>scope: {...}</code>，这种情况会产生新的scope，但这个scope是独立的scope，不继承于任何scope，也就不存在原型链继承的问题。这种情况通常用于你想构造一个通用的directive的，不与父scope产生任何联系。<blockquote>
<p>注意尽管这种情况下scope是独立的，但它依然有<code>$parent</code>属性来指向其父scope。另外，倘若你想访问父scope的属性的话，可以使用<code>=</code>，<code>@</code>，<code>&amp;</code>等符号，来指定是双向绑定或单项绑定还是基于表达式的绑定。</p>
</blockquote>
</li>
<li>构造directive时传入<code>transclude: true</code>，这种情况下会产生子scope并继承父scope，它的独特之处时如果有独立的scope，则两者为兄弟，也就是说，两者的<code>$parent</code>是一样的，独立scope的<code>$$nextSibling</code>指向这个子scope。</li>
</ul>
<blockquote>
<p>参考：<a href="http://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs" target="_blank" rel="external">What are the nuances of scope prototypal / prototypical inheritance in AngularJS?</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信大家写过AngularJS的都会发现，很多人在处理表单的数据绑定时，都习惯性的把ng-model绑定在$scope的一个对象属性上，而不是直接绑定在scope上。比如说使用&lt;code&gt;&amp;lt;input name=&amp;quot;name&amp;quot; ng-model=&amp;quot;data.name&amp;quot; /&amp;gt;&lt;/code&gt;而不是&lt;code&gt;&amp;lt;input name=&amp;quot;name&amp;quot; ng-model=&amp;quot;name&amp;quot; /&amp;gt;&lt;/code&gt;。这是为什么呢？这样在controller里面岂不是写起来更复杂吗？每次访问的时候都要多“点”一下，为什么不直接绑在$scope上呢？其实这样写自然是有它的好处的，而且这种写法也是推荐的最佳实践，尤其是在处理嵌套scope的情形下，这样写是很有必要的。为了弄清楚这么写的原因，我们需要深入的研究一下AngularJS里scope的继承。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AngularJS" scheme="http://pinkyjie.com/tags/AngularJS/"/>
    
      <category term="Javascript继承" scheme="http://pinkyjie.com/tags/Javascript%E7%BB%A7%E6%89%BF/"/>
    
      <category term="scope" scheme="http://pinkyjie.com/tags/scope/"/>
    
      <category term="dirctive" scheme="http://pinkyjie.com/tags/dirctive/"/>
    
      <category term="ng-repeat" scheme="http://pinkyjie.com/tags/ng-repeat/"/>
    
  </entry>
  
  <entry>
    <title>Git笔记(三)——[cherry-pick, merge, rebase]</title>
    <link href="http://pinkyjie.com/2014/08/10/git-notes-part-3/"/>
    <id>http://pinkyjie.com/2014/08/10/git-notes-part-3/</id>
    <published>2014-08-10T11:37:24.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>书接<a href="/2014/08/09/git-notes-part-2/">上回</a>，直入主题！这篇继续实践剩下的几个命令。</p>
<a id="more"></a>
<p>现在的SourceTree状态如下：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-24.png" class="center-img" title="图24">
<h3 id="cherry-pick-妈妈，我也要"><a href="#cherry-pick-妈妈，我也要" class="headerlink" title="cherry-pick - 妈妈，我也要"></a>cherry-pick - 妈妈，我也要</h3><p>cherry-pick其实在工作中还挺常用的，一种常见的场景就是，比如我在A分支做了几次commit以后，发现其实我并不应该在A分支上工作，应该在B分支上工作，这时就需要将这些commit从A分支复制到B分支去了，这时候就需要cherry-pick命令了，B分支指着这些commit说：妈妈，我也要！比如说，我们在master分支上继续做两次提交，第一次添加一行”test 10”，<code>git commit -am &quot;commit 10&quot;</code>，第二次添加“test 11”，到达如下图的状态：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-25.png" class="center-img" title="图25">
<p>这个时候我们发现，哦NO，我们不应该直接更改master分支，我们应该在自己的分支上做提交。这个时候先新建一个分支<code>git checkout -b branch3 1a222c3</code>，注意这里的最后一个参数是新分支的起点，也就是说，新的分支branch3是从“commit 8,9”开始的，现在我们需要把刚才的两次提交移动到新的分支上。运行<code>git cherry-pick 0bda20e 1a04d5f</code>，命令行会给出提示两个commit被复制到了当前分支上，此时SourceTree的状态如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-26.png" class="center-img" title="图26">
<p>确定这两个commit被复制到指定分支以后，在master分支上将这两个commit删除。先切回master分支：<code>git checkout master</code>，运行<code>git reset --hard 1a222c3</code>，此时SourceTree的状态图为：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-27.png" class="center-img" title="图27">
<p>两个commit被成功的从master分支移动到了branch3分支。</p>
<h3 id="merge-求合体"><a href="#merge-求合体" class="headerlink" title="merge - 求合体"></a>merge - 求合体</h3><p>merge命令应该也是非常的常用，比如新开了一个分支去完成某个feature，然后完成了以后要merge到master分支来。就拿刚才的例子来讲，开了新分支branch3来存放“commit 10”和“commit 11”，这两个commit可以看成是新的feature，完事以后就要合并到master分支上了。但合并之前，一般要将master分支当前最新的commit合并到branch3上，因为你的branch3的起点此时可能已经不是master分支的最新commit了。切换到branch3分支上运行<code>git merge master</code>，Git提示“Already up-to-date.”，这说明当前所在的分支branch3比master分支还要新，branch3上的commit都是master最新commit点的子commit，故不需要合并。切回master分支<code>git checkout master</code>，将分支branch3合并到master分支上，<code>git merge branch3</code>，结果如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-28.png" class="center-img" title="图28">
<p>可以看到branch3分支上的更改已经被合并到master上，其中“Fast-forward”是合并的一种类型，当当前分支（master）是目标分支（branch3）的祖先commit时会发生这种“Fast-forward”合并，其实可以理解为HEAD指针指向的快速移动。</p>
<p>前面看到的两种情况都是比较简单的合并，没有遇到任何“冲突”，我们来一次稍微复杂点的合并，比如我们需要将branch2合并到master上。在master分支上<code>git merge branch2</code>，哦NO，命令行提示“Automatic merge failed”，出现冲突了，Git无法判断如何merge，这个时候我们就需要手动解决冲突以后再提交。打开test.txt文件可以看到如下图的内容：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-29.png" class="center-img" title="图29">
<p>从图28中可以看到<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>和<code>========</code>之间的内容是当前分支的内容，而<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch2</code>之间的内容是branch2分支的内容，由于改动了同一行所以Git无法自动合并了。这个时候你可以决定最后保留哪些内容，我们就简单的将“test aaa”插入到第4行，然后删除多余的标记保存，另外，需要手动做一次提交来解决冲突：<code>git add test.txt</code>，然后这次我们不用<code>-m</code>参数直接<code>git commit</code>，可以看到如下图的提示：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-30.png" class="center-img" title="图30">
<p>Git已经发现我们是在做一次merge的提交，并且是“解决冲突的merge”，可以看到Git默认给出的提交信息非常的友好，包含了合并的分支上的commit，也写明了冲突的文件是什么，我们就使用Git默认的提交信息，直接<code>:wq</code>保存退出。此时可以直观的从SourceTree里看到branch2分支的线已经合并到master上了，如下图所示：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-31.png" class="center-img" title="图31">
<p>总结一下merge的集中情况：</p>
<ol>
<li><code>git merge 目标分支</code><ul>
<li>如果目标分支是当前分支的祖先commit节点，则merge什么也不会发生，因为当前分支已经是最新的了</li>
<li>如果当前分支是目标分支的祖先commit节点，这时会发生Fast-forward的merge，merge的结果是简单的移动HEAD指针</li>
</ul>
</li>
<li>如果以上两种情况都不是的话，则其实是做的三方合并，除了这两个分支的最新commit以外，另外一个是这两个分支的共同祖先commit点。这种情况下如果没有冲突的话会自动生成一个merge的commit，如果有冲突则手动解决后还是会有一个merge的commit。</li>
</ol>
<h3 id="rebase-我是直男，不喜欢弯的"><a href="#rebase-我是直男，不喜欢弯的" class="headerlink" title="rebase - 我是直男，不喜欢弯的"></a>rebase - 我是直男，不喜欢弯的</h3><p>从图31可以看出，branch2分支（紫色的线）最终交汇到master分支上（蓝色的线），这还只是合并了一次，并且我们当前的分支才几个，如果分支很多并且频繁合并的话，这样弯弯曲曲的线会非常多，搞得你眼花缭乱，根本搞不清楚走向，显然，直男一向是不喜欢弯的，那能把它掰直吗？答案是肯定的，rebase就是干这个事情的！为了看清楚merge和rebase的区别，我们先将刚才branch2的合并取消，使master回滚到“commit 11”的状态：<code>git reset --hard dda0f7d</code>。这时我们位于master分支上，运行<code>git rebase branch2</code>，Git同样提示我们有冲突，只是这次提示非常长，如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-32.png" class="center-img" title="图32">
<p>根据提示我们就可以发现rebase的流程，从“Applying: commit 3”这句就可以看出来，其实rebase的原理是先找到两个分支的共同祖先commit节点“commit 2,2.5”，然后把master分支上这个节点的儿子节点全部“应用”到branch2分支上。从图31中可以看到第一个儿子节点是“commit 3”，所以先apply这个，而“commit 3”和“commit aaa”编辑的都是第4行，所以立即出现了冲突！照例我们需要手动解决冲突。这次如果我们还是把“test aaa”放第4行，然后“test 3”放在第5行，那很明显后面的“commit 4”在apply时仍然会有冲突，所以为了方便，我们直接把“test 3”和“test aaa”都放在第4行，如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-33.png" class="center-img" title="图33">
<p>然后保存，注意这时需要先把改动add以后再操作：<code>git add test.txt</code>。按照图32的提示运行<code>git rebase --continue</code>，结果怎么样呢？哦NO，又尼玛冲突了！！！为嘛啊！“commit 4”的第4行还是“test 3”，而我们现在的第4行是“test 3 test aaa”，所以还是冲突！看来rebase在apply每一个commit时并不只是apply这个commit上的变化（即“test 4”这一行），而是apply整个文件！可以想象这样走下去每一步都会有冲突，唯一的办法就是放弃“test aaa”这个更改。真的是这样吗？其实不然，先运行<code>git rebase --abort</code>放弃这次rebase。其实这种场景下并不适合rebase，一般我们把别的分支合并到master时用<code>merge</code>，而把master合并到别的分支时会用到<code>rebase</code>，那我们换个思路，切换到branch2分支上<code>git checkout branch2</code>，然后运行rebase命令<code>git rebase master</code>，显然，还是会有冲突的，这次我们直接把“commit aaa”加到最后一行保存。运行<code>git add test.txt</code>，然后继续进行<code>git rebase --continue</code>，可以看到结果成功了“Applying: commit aaa”。这时的SourceTree如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-34.png" class="center-img" title="图34">
<p>可是这样与merge的结果恰恰相反，我们是把master分支merge到branch2上了，而我们初衷是将branch2分支merge到master上。简单！先切回master分支<code>git checkout master</code>然后运行<code>git merge branch2</code>即可，因为这时master分支是branch2分支的祖先commit节点，所以直接Fast-forward了！最终的状态图如下图所示：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-35.png" class="center-img" title="图35">
<p>从图35中可以看出，达到了和图31同样的效果，不同的是：首先，没有了“弯弯”的线；其次，多余的merge那一条commit没有啦！这才是直男喜欢的！</p>
<p>总结一下rebase：</p>
<ol>
<li><code>git rebase 目标分支</code>原理其实是先将HEAD指向目标分支和当前分支的共同祖先commit节点，然后将当前分支上的commit一个一个的apply到目标分支上，apply完以后再将HEAD指向当前分支。</li>
<li>rebase与merge的区别：<ul>
<li>把master分支合并到别的分支用rebase，把别的分支合并到master分支上用merge</li>
<li>rebase不会产生多余的commit，并且保持直线</li>
</ul>
</li>
</ol>
<p><em>关于rebase其他要补充的</em>：</p>
<p>当然rebase还有其他很多很牛逼的功能，其“交互模式”可以让你干很多事情，比如调整commit的顺序啊，合并一些commit啊，删除一些commit啊等等，通过<code>-i</code>参数可以实现，当然这个命令有些复杂，我们可以使用SourceTree的图形化界面更直观的使用它。比如“commit 10”和“commit 11”太不和谐了，早就看你们不爽了，人家前面的“6,7”和“8,9”都成双成对，就你俩不和谐，我要“整顿”一下！在SourceTree中的“commit 8,9”上右击，点击子菜单中的“Rebase children of 1a222c3 interactively…”：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-36.png" class="center-img" title="图36">
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-37.png" class="center-img" title="图37">
<p>然后出现了图37中的对话框，我们想整理的2个commit显示在其中，“commit aaa”也是儿子节点，所以也显示在这里，我们可以通过红色方框中的按钮来进行操作。比如，我们想合并一下“commit 10”和“commit 11”，两个commit合并为“commit 10,11”。在这个对话框中可以非常直观的进行上面的操作，先选中“commit 11”这一行，选择红框中的“Squash with previous”按钮，可以看到出现了一条新的commit——“[2 commits]”，如图38所示：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-38.png" class="center-img" title="图38">
<p>选中这条commit，点击红框中的“Edit message”，出现了更改commit信息的对话框，如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-39.png" class="center-img" title="图39">
<p>输入“commit 10,11”即可，点击OK保存，再次点击OK完成此次rebase。此时SourceTree的状态如图40所示：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-40.png" class="center-img" title="图40">
<p>可以看到，目的达到了，commit hash也跟原来的任何两个都不一样了。除了合并commit，利用图37的红色方框里的按钮，还可以实现删除commit，调整commit的顺序等功能，大家自己尝试吧，小心产生“冲突”哦！</p>
<p>好啦，到这里，感觉比较重要的git命令都介绍完了！！！其实这三篇都是小实践，要想融会贯通，还需要在真实项目中的大实践！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书接&lt;a href=&quot;/2014/08/09/git-notes-part-2/&quot;&gt;上回&lt;/a&gt;，直入主题！这篇继续实践剩下的几个命令。&lt;/p&gt;
    
    </summary>
    
      <category term="工具相关" scheme="http://pinkyjie.com/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Git" scheme="http://pinkyjie.com/tags/Git/"/>
    
      <category term="SourceTree" scheme="http://pinkyjie.com/tags/SourceTree/"/>
    
      <category term="版本控制" scheme="http://pinkyjie.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="git-cherry-pick" scheme="http://pinkyjie.com/tags/git-cherry-pick/"/>
    
      <category term="git-merge" scheme="http://pinkyjie.com/tags/git-merge/"/>
    
      <category term="git-rebase" scheme="http://pinkyjie.com/tags/git-rebase/"/>
    
  </entry>
  
  <entry>
    <title>Git笔记(二)——[diff, reset]</title>
    <link href="http://pinkyjie.com/2014/08/09/git-notes-part-2/"/>
    <id>http://pinkyjie.com/2014/08/09/git-notes-part-2/</id>
    <published>2014-08-09T14:32:41.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>书接<a href="/2014/08/02/git-notes-part-1/">上回</a>，直入主题！如果你是接着上篇来的，那么先运行<code>git reset HEAD test.txt</code>和<code>git checkout test.txt</code>来放弃当前的更改，使最新的commit回到“commit temp”，这个时候运行<code>git status</code>，会看到“nothing to commit, working directory clean”。这里，“nothing to commit”说明暂存目录是空的，“working directory clean”说明你的工作目录也没有任何修改。</p>
<a id="more"></a>
<p>回到这种状态是为了方便我们下面的讲解，此时的SourceTree状态为：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-13.png" class="center-img" title="图13">
<h3 id="diff-来，叔叔给你检查身体"><a href="#diff-来，叔叔给你检查身体" class="headerlink" title="diff - 来，叔叔给你检查身体"></a>diff - 来，叔叔给你检查身体</h3><p>好好的一个<code>diff</code>命令能让我想到的就是这句猥琐的经典台词了，diff可以让你比较项目中任意两个状态的差别。说到比较，自然就又有source和target了，那么diff命令最直观的用法其实就是<code>git diff source target</code>。这里的source和target与checkout中的类似，可以是“commit的hash”，“分支名”，“快捷方式”。比如，我们想比较图13中前两个commit，运行<code>git diff ce81811 6382c7d</code>即可，得到的结果如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-15.png" class="center-img" title="图15">
<p>可以看到，比较的结果其实是以target为基准的，也就是说target相比于source有了哪些变化，图15的结果中commit “6382c7d”比“ce81811”少了三行，多了一行，分别用减号和加号来表示。同样，使用<code>git diff master branch2</code>和<code>git diff HEAD branch2</code>得到的结果与上面是一致的，分支名和“HEAD”一类的都可以看做是commit的快捷方式。</p>
<p>这种source和target都给的情况是最容易理解的，复杂就复杂在如果我们省略一个参数会怎么样呢？比如运行<code>git diff branch2</code>结果如下图所示：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-16.png" class="center-img" title="图16">
<p>可以看到，图16的结果与图15是相反的。也就是说<code>git diff branch2</code>与<code>git diff branch2 HEAD</code>的结果是一样的，即如果只给一个参数，则这个参数为source，target默认为当前所在分支的最新的commit。现在就下这个结论对吗？注意我们现在处在“暂存目录为空”+“工作目录clean”的状况下，现在我们把工作目录搞成dirty试试，给test.txt再加一行“test 6”并保存。这时再试试<code>git diff branch2</code>，结果如图17所示：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-17.png" class="center-img" title="图17">
<p>可以看到新建的“test 6”也进去了。可以断定，在工作目录不clean的情况下，target默认表示的是工作目录。这个结论是否还是为时尚早呢，如果暂存目录有东西会怎么样？运行<code>git add test.txt</code>，然后继续<code>git diff branch2</code>，发现结果与图17是一致的，这还是不能说明问题，因为此时工作目录与暂存目录是一致的（都到test 6）。那么我们再加一行“test 7”，这时工作目录为“test 7”，暂存目录还是“test 6”，此时运行<code>git diff branch2</code>，发现“test 7”这一行也被加了进去。这个时候我们基本可以断定，target默认显示的确实是工作目录。</p>
<p>前面看了省略一个参数的情况，那俩参数都省略会咋样呢？运行<code>git diff</code>结果如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-18.png" class="center-img" title="图18">
<p>可以看到比较结果为只增加了“test 7”，所以这个时候的source是暂存目录，而target还是工作目录。为了验证这个推测，我们运行<code>git add test.txt</code>，将“test 7”的修改也add到暂存目录，这时运行<code>git diff</code>，返回结果为空，因为此时暂存目录和工作目录是一致。我们做一次提交<code>git commit -m &quot;commit 6,7&quot;</code>，这时，暂存目录为空，工作目录clean，继续运行<code>git diff</code>，还是空的。到这里我们可以断定，如果两个参数都省略，那么默认source为暂存目录，默认target为工作目录。</p>
<p>前面的情况涉及到“各个commit之间的比较”，“各个commit与工作目录的比较”，“暂存目录与工作目录的比较”，那么只差一种情况了，我想比较“暂存目录”和“各个commit”怎么整呢？为了实现这个，我们先给暂存目录来点东西：加一行“test 8”并保存，然后<code>git add test.txt</code>，然后在编辑test.txt加一行“test 9”，这么做的原因是让暂存区有东西而且暂存区与工作目录不同。这时运行<code>git diff --cached branch2</code>，可以发现结果为下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-19.png" class="center-img" title="图19">
<p>从图中可以发现“test 8”在而“test 9”不在，说明此时的target已经变成暂存区了。</p>
<p>总结一下diff的各种情况：</p>
<ol>
<li><code>git diff source target</code>返回的结果是target相对于source的变化，这里的source和target可以是<code>commit的hash/分支名/快捷方式</code></li>
<li>如果只给一个参数，则这个参数就是source，而默认的target是工作目录，如果工作目录clean的话，则target为当前所在分支的最新commit</li>
<li>如果一个参数都不给，默认的source是暂存目录，而target还是工作目录</li>
<li>如果想要使暂存目录作为target的话，需要使用<code>--cached</code>参数</li>
</ol>
<p>在继续往下走之前，先将刚才的更改全部提交，运行<code>git add test.txt</code>和<code>git commit -m &quot;commit 8,9&quot;</code>。</p>
<h3 id="reset-有了我你随便咋折腾都行"><a href="#reset-有了我你随便咋折腾都行" class="headerlink" title="reset - 有了我你随便咋折腾都行"></a>reset - 有了我你随便咋折腾都行</h3><p>版本控制最大的好处就是可以方便的找到以前的版本并恢复，所以从这个角度来说reset命令的地位还是比较重要的，可以让你无所顾忌的随便蹂躏整个项目。说到恢复，也有source和target的概念，这里的source肯定就是各个commit（包含分支名和快捷方式），而target根据不同的参数可能是暂存目录或工作目录或两者同时都是target。比如我们选定当前commit的父commit作为source，运行<code>git reset HEAD~ test.txt</code>，提示有Unstaged change，此时SourceTree里的Uncommitted changes的状态如下图：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-20.png" class="center-img" title="图20">
<p>从图20中可以发现，暂存区域的文件状态与父commit时一致，而改变是减掉了“test 8”和“test 9”两行，说明工作目录并没有发生变化（工作目录含有这两行）。可以看到这种情况下的target其实是暂存目录，它并没有改变工作目录。说到这里，把前面欠的课补上，还记得前面我们做git add的反操作时用了<code>git reset HEAD test.txt</code>，其实也是将HEAD状态的文件恢复到了暂存区，工作目录保持不变，而那时最新commit的文件状态和工作目录是一致的，所以最终产生的效果就是“git add反操作”。其实这里的<code>HEAD</code>也可以省略，因为默认的source就是当前所在分支的最新commit。更进一步，文件名<code>test.txt</code>也可以省略，默认会将Repo里的所有文件恢复，因为此时我们就只有这一个文件，所以效果是一样的。</p>
<p>再介绍reset的其他参数之前，我们想把刚才的reset再给reset掉，很简单，只要再运行一遍<code>git reset</code>即可，因为我们需要的其实是“git add的反操作”。然后加参数运行reset，<code>git reset --soft HEAD~</code>，注意这里我们并不是省略文件名，而是一旦加了<code>--soft</code>就不能跟文件路径，而是恢复整个项目的所有文件了，结果如下图所示：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-21.png" class="center-img" title="图21">
<p>可以看到，这次reset直接改变了HEAD，原先的“commit 8,9”消失了，最新的commit变成了原先的<code>HEAD~</code>，但这次reset仍然没有修改工作目录，只是将“commit 8,9”的文件状态add到了暂存区。既然有<code>--soft</code>参数，那肯定会有<code>--hard</code>参数，这次我们保持当前的状态，直接运行<code>git reset --hard ce81811</code>（commit temp所对应的hash），发现当前最新的commit变成“commit temp”，并且暂存区域是空的，然后工作目录也是clean的，说明<code>--hard</code>参数不管运行命令前处于什么状态，都直接将工作目录恢复到“commit temp”的状态，清空暂存区域。这也比较符合<code>--hard</code>这个单词强硬的意思。此时的SourceTree状态图为：</p>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-22.png" class="center-img" title="图22">
<p>从图中可以看出，“commit temp”之前的commit都已经丢失了，整个项目被强制恢复到了“commit temp”所在的状态。</p>
<p>总结一下reset的用法：</p>
<ol>
<li><code>git reset [commit hash/分支名/快捷方式] [文件名]</code>类似“git add的反操作”，直接将所在commit的文件状态恢复到暂存区域。省略commit则默认为HEAD，省略文件名默认为所有文件。只改变暂存目录，不改变工作目录，当前commit不变。</li>
<li><code>git reset --soft [commit hash/分支名/快捷方式]</code>软恢复，将恢复前所在commit的文件状态恢复到暂存区，当前最新commit为参数中的commit。只改变暂存目录，不改变工作目录，当前commit改变。</li>
<li><code>git reset --hard [commit hash/分支名/快捷方式]</code>硬恢复，强制将整个项目恢复为参数中的commit时的文件状态，清空暂存目录，工作目录clean。暂存目录和工作目录同时被改变，当前commit改变。</li>
</ol>
<p>关于reset命令的其他补充：当前HEAD已经位于“commit temp”，是不是前面的commit都找不回来了？当然不会，reset过的操作也是可以被reset的。有两种方法：</p>
<ul>
<li>如果记得“commit 8,9”的hash（从图20中可以看到），则直接<code>git reset --hard 1a222c3</code>，则项目直接强制恢复到“commit 8,9”所在的状态。</li>
<li>如果不记得的话，运行<code>git reflog</code>，这个命令会输出一个列表，包含HEAD发生的所有变化。如下图：</li>
</ul>
<img src="http://7jptbo.com1.z0.glb.clouddn.com/images/git-notes-23.png" class="center-img" title="图23">
<p>在图23中可以发现“commit 8,9”所对应的条目为<code>1a222c3 HEAD@{9}: commit: commit 8,9</code>，第一项就是commit hash，第二项自然是快捷方式了。那么只要我们运行<code>git reset --hard HEAD@{9}</code>即可。注意，我的reflog输出结果可能与你的不同，因为写教程的需要我可能做了很多额外的操作。</p>
<p>P.S. 显然两篇也不够啊，发现主要是Retina屏的截图太尼玛大了。。。下篇再讲剩下的吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书接&lt;a href=&quot;/2014/08/02/git-notes-part-1/&quot;&gt;上回&lt;/a&gt;，直入主题！如果你是接着上篇来的，那么先运行&lt;code&gt;git reset HEAD test.txt&lt;/code&gt;和&lt;code&gt;git checkout test.txt&lt;/code&gt;来放弃当前的更改，使最新的commit回到“commit temp”，这个时候运行&lt;code&gt;git status&lt;/code&gt;，会看到“nothing to commit, working directory clean”。这里，“nothing to commit”说明暂存目录是空的，“working directory clean”说明你的工作目录也没有任何修改。&lt;/p&gt;
    
    </summary>
    
      <category term="工具相关" scheme="http://pinkyjie.com/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Git" scheme="http://pinkyjie.com/tags/Git/"/>
    
      <category term="SourceTree" scheme="http://pinkyjie.com/tags/SourceTree/"/>
    
      <category term="版本控制" scheme="http://pinkyjie.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="git-diff" scheme="http://pinkyjie.com/tags/git-diff/"/>
    
      <category term="git-reset" scheme="http://pinkyjie.com/tags/git-reset/"/>
    
  </entry>
  
  <entry>
    <title>使用AngularJS解决IE 8/9不支持placeholder的问题</title>
    <link href="http://pinkyjie.com/2014/08/06/solve-placeholder-incompatibility-using-angular-on-legacy-ie/"/>
    <id>http://pinkyjie.com/2014/08/06/solve-placeholder-incompatibility-using-angular-on-legacy-ie/</id>
    <published>2014-08-06T13:23:25.000Z</published>
    <updated>2017-02-20T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Curse You IE!</p>
</blockquote>
<p>这句开场白是我司项目源码里的常见注释，我司的项目主要是海外市场，IE 6/7是不用折腾了，但是IE 8/9还是要整的，老版本的IE有多闹心我就不惜的说了，谁整谁知道！前段时间我被assign了一个bug要修，IE 8/9不支持input和textarea的placeholder属性，说体验很不好，让修复下。 大早上看到这个我整个人都不好了，这篇文章就记录一下我是如何解决这个问题的。</p>
<a id="more"></a>
<h3 id="方案1：用value属性来模拟placeholder"><a href="#方案1：用value属性来模拟placeholder" class="headerlink" title="方案1：用value属性来模拟placeholder"></a>方案1：用value属性来模拟placeholder</h3><p>有问题，先google！最快捷的方式自然是一大堆的jQuery插件了，包一个JS/CSS文件，然后调一下<code>.placeholder()</code>函数就搞定了。但是，一个是为了这么个小功能去用一个插件感觉没啥必要，另外一个原因是jQuery插件要应用到AngularJS上就需要改写成directive，感觉也很麻烦。所以，最终的结论是还不如自己写一个directive来解决这个问题。</p>
<p>自己实现directive就需要搞清楚如何在IE上模拟placeholder的原理，网上比较常见的解决方案是直接用input或textarea的value属性来模拟placeholder，代码大致和下面的类似：</p>
<figure class="highlight javascript"><figcaption><span>ie-placeholder.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'[placeholder]'</span>).focus(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> input = $(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (input.val() == input.attr(<span class="string">'placeholder'</span>)) &#123;</div><div class="line">        input.val(<span class="string">''</span>);</div><div class="line">        input.removeClass(<span class="string">'placeholder'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;).blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> input = $(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (input.val() == <span class="string">''</span> || input.val() == input.attr(<span class="string">'placeholder'</span>)) &#123;</div><div class="line">        input.addClass(<span class="string">'placeholder'</span>);</div><div class="line">        input.val(input.attr(<span class="string">'placeholder'</span>));</div><div class="line">    &#125;</div><div class="line">&#125;).blur();</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出，原理还是比较简单的。给所有包含placeholder的标签（input/textarea）的focus和blur事件绑定回调函数：</p>
<ul>
<li>当focus事件发生时，即用户点击input框时，检查如果input的value属性等于它的placeholder属性，则认为用户还没有输入过任何东西，这时清空input框并移除class。</li>
<li>当blur事件发生时，即用户点击别的地方时，检查如果input的value属性为空或者等它的placeholder属性，则认为用户并没有输入任何东西，这时将placeholder的值设置为value属性并添加class。</li>
<li>最后先手动触发一下blur事件，好让input框初始化的状态是显示placeholder。</li>
<li>这里的class属性一般是用来添加字体颜色的样式，因为一般placeholder的颜色为灰色。</li>
</ul>
<h3 id="方案1需要考虑的问题"><a href="#方案1需要考虑的问题" class="headerlink" title="方案1需要考虑的问题"></a>方案1需要考虑的问题</h3><p>乍一看，这种模拟方式基本可以满足placeholder的需求。但是有几个问题需要解决：</p>
<ol>
<li>type为password时placeholder也会以mask的方式显示。这个应该是最棘手的问题了，由于是使用value属性，而password的value默认是以圆点mask的方式显示的，这样给人很奇怪的感觉。</li>
<li>无法准确判断input框是不是dirty的。如果你输入的内容恰好就和placeholder的内容一样的话，则一旦你点击input框，focus事件发生，输入的内容会被清掉。</li>
<li>提交form表单时需要格外注意。这个问题其实和问题2差不多，由于value属性模拟placeholder，一个表单你即便什么也不填也都是有值的，这就要求提交表单的时候要对每个input框做检查，判断value属性是否与placeholder不同来判断这个form是否dirty。如果你的表单提交逻辑已经写好的情况下，则需要很多额外的修改工作。</li>
</ol>
<p>抛开2、3两个问题不说，问题1是无法接受的，显然这种方案不太可行。</p>
<h3 id="方案2：直接添加一个span标签模拟placeholder"><a href="#方案2：直接添加一个span标签模拟placeholder" class="headerlink" title="方案2：直接添加一个span标签模拟placeholder"></a>方案2：直接添加一个span标签模拟placeholder</h3><p>既然从input框本身下手不行，那就需要借助其他的标签来模拟了。试想我们在每个input框同样的位置上放一个span标签来模拟placeholder，这个span标签和input框同样的大小，当点击这个span时隐藏自己并使input框focus，当input框blur时若input框为空则重新显示这个span，这样就可以模拟placeholder的功能了。带着这个思路我们可以写一个自定义的directive来模拟placeholder：</p>
<figure class="highlight plain"><figcaption><span>myPlaceholderDirective.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">app.directive(&apos;myPlaceholder&apos;, [&apos;$compile&apos;, function($compile)&#123;</div><div class="line">    return &#123;</div><div class="line">        restrict: &apos;A&apos;,</div><div class="line">        scope: &#123;&#125;,</div><div class="line">        link: function(scope, ele, attr) &#123;</div><div class="line">            var input = document.createElement(&apos;input&apos;);</div><div class="line">            var isSupportPlaceholder = &apos;placeholder&apos; in input;</div><div class="line">            if (!isSupportPlaceholder) &#123;</div><div class="line">                var fakePlaceholder = angular.element(</div><div class="line">                    &apos;&lt;span class=&quot;plcaeholder&quot;&gt;&apos; + attr[&apos;placeholder&apos;] + &apos;&lt;/span&gt;&apos;);</div><div class="line">                fakePlaceholder.on(&apos;click&apos;, function(e)&#123;</div><div class="line">                    e.stopPropagation();</div><div class="line">                    ele.focus();</div><div class="line">                &#125;);</div><div class="line">                ele.before(fakePlaceholder);</div><div class="line">                $compile(fakePlaceholder)(scope);</div><div class="line">                ele.on(&apos;focus&apos;, function()&#123;</div><div class="line">                    fakePlaceholder.hide();</div><div class="line">                &#125;).on(&apos;blur&apos;, function()&#123;</div><div class="line">                    if (ele.val() === &apos;&apos;) &#123;</div><div class="line">                        fakePlaceholder.show();</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;]);</div></pre></td></tr></table></figure>
<p>这里我们定义了一个叫做myPlaceholder的directive，按照directive的定义指定这个directive只能作为属性存在，并且它的scope是独立的，然后就是最重要的link函数，主要的逻辑都放在这里面。先看6、7两行，这两行的作用主要是为了判断当前的浏览器是否支持placeholder属性，这个神一般的方法来自于<a href="http://stackoverflow.com/questions/3937818/how-to-test-if-the-browser-supports-the-native-placeholder-attribute" target="_blank" rel="external">StackOverflow</a>，当然这里也可以使用<a href="http://modernizr.com/" target="_blank" rel="external">Modernizr</a>这样的第三方库来判断。而我们后面的逻辑都是发生在不支持placeholder的前提下的，如果支持的话就什么也不做了。第9-16行是添加span的过程，先定义一个span标签，内容就是input框的placeholder属性，然后为其绑定click事件，当用户点击这个假的placeholder时，触发input框的focus事件。最后将这个假的placeholder插入到DOM树中去。这里值得注意的有三点：</p>
<ol>
<li>为什么使用span标签？这可不是随便拿来用的，其实这个场景使用label标签非常合适，语义上比较符合，但杯具的是label标签在IE 8中不支持click事件。</li>
<li>第12行为何停止事件的冒泡？防止对其他部分产生影响，因为这个span标签是硬塞进来的，一旦click事件往上传播可能会影响现有的逻辑。</li>
<li>第16行的作用？这是AngularJS里特有的问题，在link函数里对DOM树进行更改后只有使用<code>$compile</code>函数这个更改才能生效。当然你也可以将DOM更改放入compile函数中去。</li>
</ol>
<p>接下去的17-23行就跟方案1差不多了，focus事件发生时隐藏假的placeholder，blur事件发生时若input框内容为空则重新显示假的placeholder。不同之处就在于这里我们不用管input框的内容是否与placeholder属性相不相同了。</p>
<h3 id="方案2需要考虑的问题"><a href="#方案2需要考虑的问题" class="headerlink" title="方案2需要考虑的问题"></a>方案2需要考虑的问题</h3><p>那么到现在为止这个方案2能工作吗？答案是能，但是有很多问题！下面一个一个来分析：</p>
<p><em>1. 位置问题</em></p>
<p>这个恐怕是最首当其冲的问题，方案1由于使用就是input框本身，所以根本不存在错位的问题，而方案2是新插入一个标签，所以必须让新的span标签与原来的input框位置重合，这样才能以假乱真。首先，一些必要的样式是要有的，比如</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.placeholder</span> &#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">color</span>: <span class="number">#aaa</span>;</div><div class="line">    <span class="attribute">cursor</span>: text;</div><div class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>绝对定位可以保证span可以叠加在input框之上，同样<code>z-index</code>样式也是为了保证这个，而<code>cursor</code>样式是为了让鼠标更逼真，普通的input框当鼠标移上去时显示的就是text的样式。这些样式仅仅是一个开始，要知道，input框的位置在页面渲染好以后也可能是会发生变化的。举个例子，有两个input框上下相邻，如果第一个输入的错误的信息，则两个input框之间可能会需要一条报错提示，这样，下面的input框的位置就会发生变化。所以，必须时刻根据input框的位置调整span的位置。而AngularJS里恰好有这么一个特性：<code>$watch</code>，我们要做的就是watch这个input框的位置，一旦发生变化立马调整span的位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scope.getElementPosition = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> ele.position();    </div><div class="line">&#125;;</div><div class="line">scope.$watch(scope.getElementPosition, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    fakePlaceholder.css(&#123;</div><div class="line">        <span class="string">'top'</span>: ele.position().top + <span class="string">'px'</span>,</div><div class="line">        <span class="string">'left'</span>: ele.position().left + <span class="string">'px'</span></div><div class="line">    &#125;); </div><div class="line">&#125;, <span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>jQuery的<code>position()</code>函数可以获取元素的位置，一旦原始input框的top、left发生变化，则将span元素的top、left属性与其保持一致。注意<code>$watch</code>函数的第三个参数，默认<code>$watch</code>判断是否发生变化使用的是<code>===</code>，这样的话两个object是永远不可能相等的，而加上第三个参数并给true，则会使<code>$watch</code>函数比较object的各个property是否相等。</p>
<p><em>2. 大小和样式问题</em></p>
<p>解决了位置问题会发现，有些情况下还是会有错位的问题，比如span的内容要比input框偏左一点，span框的行高与input框不一致等等，这些牵涉到span的大小和样式必须要与input框一致。同样我们可以用<code>$watch</code>来解决：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">scope.getElementHeight = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> ele.outerHeight();  </div><div class="line">&#125;;</div><div class="line">scope.$watch(scope.getElementHeight, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    fakePlaceholder.css(<span class="string">'line-height'</span>, ele.outerHeight() + <span class="string">'px'</span>); </div><div class="line">&#125;);</div><div class="line"><span class="keyword">if</span> (ele.css(<span class="string">'font-size'</span>))&#123;</div><div class="line">    fakePlaceholder.css(<span class="string">'font-size'</span>, ele.css(<span class="string">'font-size'</span>));</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (ele.css(<span class="string">'text-indent'</span>))&#123;</div><div class="line">    fakePlaceholder.css(<span class="string">'text-indent'</span>, </div><div class="line">        <span class="built_in">parseInt</span>(ele.css(<span class="string">'text-indent'</span>)) + </div><div class="line">        <span class="built_in">parseInt</span>(ele.css(<span class="string">'border-left-width'</span>))</div><div class="line">    );</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (ele.css(<span class="string">'padding-left'</span>))&#123;</div><div class="line">    fakePlaceholder.css(<span class="string">'padding-left'</span>, ele.css(<span class="string">'padding-left'</span>));</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (ele.css(<span class="string">'margin-top'</span>))&#123;</div><div class="line">    fakePlaceholder.css(<span class="string">'margin-top'</span>, ele.css(<span class="string">'margin-top'</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可能还有很多样式没有考虑到，这就要看具体的情况了，发现有问题再去看是哪个样式影响的，再进行添加。</p>
<p><em>3. 随input框的隐藏而隐藏</em> </p>
<p>这个应该是AngularJS特有的问题吧，因为有<code>ng-show</code>的影响，即便页面渲染完成后很多input框的显示与隐藏也是会变化的，所以，这个自然也需要<code>$watch</code>了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">scope.isElementVisible = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> ele.is(<span class="string">':visible'</span>); </div><div class="line">&#125;;</div><div class="line">scope.$watch(scope.isElementVisible, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> displayVal = ele.is(<span class="string">':visible'</span>) ? <span class="string">'block'</span> : <span class="string">'none'</span>;</div><div class="line">    fakePlaceholder.css(<span class="string">'display'</span>, displayVal);</div><div class="line">    <span class="keyword">if</span> (displayVal === <span class="string">'blcok'</span> &amp;&amp; ele.val()) &#123;</div><div class="line">        fakePlaceholder.hide();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里同样使用jQuery的工具函数来做判断，将input框的显示状态赋值给span。注意7、8两行，如果input框在隐藏的过程中突然有值了，这时再显示的时候就要隐藏假的placeholder了。</p>
<p><em>4. 若input框有值则隐藏</em></p>
<p>这个同样是AngularJS的问题吧，因为有<code>ng-model</code>属性，有时即便你不手动输入，input框的内容也是会变化的，所以，这个也需要<code>$watch</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scope.hasValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> ele.val(); </div><div class="line">&#125;;</div><div class="line">scope.$watch(scope.hasValue, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (ele.val()) &#123;</div><div class="line">        fakePlaceholder.hide();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>好了，到这里为止，我们才可以说这个假的placeholder比较稳定了。当然，实际情况很复杂，具体情况具体分析，无非是善用<code>$watch</code>了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Curse You IE!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句开场白是我司项目源码里的常见注释，我司的项目主要是海外市场，IE 6/7是不用折腾了，但是IE 8/9还是要整的，老版本的IE有多闹心我就不惜的说了，谁整谁知道！前段时间我被assign了一个bug要修，IE 8/9不支持input和textarea的placeholder属性，说体验很不好，让修复下。 大早上看到这个我整个人都不好了，这篇文章就记录一下我是如何解决这个问题的。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://pinkyjie.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AngularJS" scheme="http://pinkyjie.com/tags/AngularJS/"/>
    
      <category term="IE兼容性" scheme="http://pinkyjie.com/tags/IE%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
      <category term="placeholder" scheme="http://pinkyjie.com/tags/placeholder/"/>
    
  </entry>
  
</feed>
